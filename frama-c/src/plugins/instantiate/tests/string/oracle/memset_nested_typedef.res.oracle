[kernel] Parsing memset_nested_typedef.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
typedef unsigned int t;
struct X {
   t s_addr ;
};
/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ (ptr + j0)->s_addr ≡ 0;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_0(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,0,len);
  return __retres;
}

void test(void)
{
  struct X x;
  memset_st_X_0(& x,sizeof(x));
  return;
}


[kernel] Parsing ocode_memset_nested_typedef.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
typedef unsigned int t;
struct X {
   t s_addr ;
};
/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ (\old(ptr) + j0)->s_addr ≡ 0;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_0(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,0,len);
  return __retres;
}

void test(void)
{
  struct X x;
  memset_st_X_0(& x,sizeof(x));
  return;
}


