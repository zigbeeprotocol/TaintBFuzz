[kernel] Parsing memset_value.c (with preprocessing)
[instantiate] memset_value.c:26: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:27: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:32: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:33: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:37: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:38: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:42: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:43: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:47: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:48: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:52: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:53: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:57: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:58: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:62: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:63: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:67: Warning: 
  memset instantiator cannot replace call
[instantiate] memset_value.c:68: Warning: 
  memset instantiator cannot replace call
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
struct incomplete;
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10], char value)
{
  char *res = memset_char(dest,value,(size_t)10);
  memset_char(res,value,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(char dest[10], unsigned char value)
{
  unsigned char *res = memset_char(dest,(char)value,(size_t)10);
  memset_uchar(res,value,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(ptr + j0))[j1] ≡ value);
    ensures result: \result ≡ ptr;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10], char value)
{
  char (*res)[10] = memset_arr10_char(dest,value,(size_t)100);
  memset_arr10_char(res,value,(size_t)100);
  return;
}

void integer(int dest[10], int value)
{
  int *res = memset((void *)dest,value,(unsigned long)10 * sizeof(int));
  memset((void *)res,value,(unsigned long)10 * sizeof(int));
  return;
}

void with_enum(enum E dest[10], int value)
{
  enum E *res =
    memset((void *)dest,value,(unsigned long)10 * sizeof(enum E));
  memset((void *)res,value,(unsigned long)10 * sizeof(enum E));
  return;
}

void with_named(named dest[10], int value)
{
  named *res = memset((void *)dest,value,(unsigned long)10 * sizeof(named));
  memset((void *)res,value,(unsigned long)10 * sizeof(named));
  return;
}

void structure(struct X dest[10], int value)
{
  struct X *res =
    memset((void *)dest,value,(unsigned long)10 * sizeof(struct X));
  memset((void *)res,value,(unsigned long)10 * sizeof(struct X));
  return;
}

void pointers(int *dest[10], int value)
{
  int **res = memset((void *)dest,value,(unsigned long)10 * sizeof(int *));
  memset((void *)res,value,(unsigned long)10 * sizeof(int *));
  return;
}

void nested(int (*dest)[10], int n, int value)
{
  int (*res)[10] =
    memset((void *)dest,value,(unsigned long)n * sizeof(int [10]));
  memset((void *)res,value,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest, int value)
{
  void *res = memset(dest,value,(size_t)10);
  memset(res,value,(size_t)10);
  return;
}

void with_incomplete(struct incomplete *dest, int value)
{
  struct incomplete *res = memset((void *)dest,value,(size_t)10);
  memset((void *)res,value,(size_t)10);
  return;
}

void with_null_or_int(int value)
{
  memset((void *)0,value,(size_t)10);
  memset((void *)((int *)42),value,(size_t)10);
  return;
}


[kernel] Parsing ocode_memset_value.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
struct incomplete;
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10], char value)
{
  char *res = memset_char(dest,value,(size_t)10);
  memset_char(res,value,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(char dest[10], unsigned char value)
{
  unsigned char *res = memset_char(dest,(char)value,(size_t)10);
  memset_uchar(res,value,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1;
             0 ≤ j1 < 10 ⇒ (*(\old(ptr) + j0))[j1] ≡ \old(value));
    ensures result: \result ≡ \old(ptr);
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10], char value)
{
  char (*res)[10] = memset_arr10_char(dest,value,(size_t)100);
  memset_arr10_char(res,value,(size_t)100);
  return;
}

void integer(int dest[10], int value)
{
  int *res = memset((void *)dest,value,(unsigned long)10 * sizeof(int));
  memset((void *)res,value,(unsigned long)10 * sizeof(int));
  return;
}

void with_enum(enum E dest[10], int value)
{
  enum E *res =
    memset((void *)dest,value,(unsigned long)10 * sizeof(enum E));
  memset((void *)res,value,(unsigned long)10 * sizeof(enum E));
  return;
}

void with_named(named dest[10], int value)
{
  named *res = memset((void *)dest,value,(unsigned long)10 * sizeof(named));
  memset((void *)res,value,(unsigned long)10 * sizeof(named));
  return;
}

void structure(struct X dest[10], int value)
{
  struct X *res =
    memset((void *)dest,value,(unsigned long)10 * sizeof(struct X));
  memset((void *)res,value,(unsigned long)10 * sizeof(struct X));
  return;
}

void pointers(int *dest[10], int value)
{
  int **res = memset((void *)dest,value,(unsigned long)10 * sizeof(int *));
  memset((void *)res,value,(unsigned long)10 * sizeof(int *));
  return;
}

void nested(int (*dest)[10], int n, int value)
{
  int (*res)[10] =
    memset((void *)dest,value,(unsigned long)n * sizeof(int [10]));
  memset((void *)res,value,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest, int value)
{
  void *res = memset(dest,value,(size_t)10);
  memset(res,value,(size_t)10);
  return;
}

void with_incomplete(struct incomplete *dest, int value)
{
  struct incomplete *res = memset((void *)dest,value,(size_t)10);
  memset((void *)res,value,(size_t)10);
  return;
}

void with_null_or_int(int value)
{
  memset((void *)0,value,(size_t)10);
  memset((void *)((int *)42),value,(size_t)10);
  return;
}


