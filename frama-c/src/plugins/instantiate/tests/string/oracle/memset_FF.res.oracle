[kernel] Parsing memset_FF.c (with preprocessing)
[instantiate] memset_FF.c:88: Warning: memset instantiator cannot replace call
[instantiate] memset_FF.c:89: Warning: memset instantiator cannot replace call
[instantiate] memset_FF.c:93: Warning: memset instantiator cannot replace call
[instantiate] memset_FF.c:94: Warning: memset instantiator cannot replace call
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10])
{
  char *res = memset_char(dest,(char)0xFF,(size_t)10);
  memset_char(res,(char)0xFF,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(unsigned char dest[10])
{
  unsigned char *res = memset_uchar(dest,(unsigned char)0xFF,(size_t)10);
  memset_uchar(res,(unsigned char)0xFF,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(ptr + j0))[j1] ≡ value);
    ensures result: \result ≡ ptr;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10])
{
  char (*res)[10] = memset_arr10_char(dest,(char)0xFF,(size_t)100);
  memset_arr10_char(res,(char)0xFF,(size_t)100);
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ ~((int)0);
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int *memset_int_FF(int *ptr, size_t len)
{
  int *__retres;
  __retres = (int *)memset((void *)ptr,255,len);
  return __retres;
}

void integer(int dest[10])
{
  int *res = memset_int_FF(dest,(unsigned long)10 * sizeof(int));
  memset_int_FF(res,(unsigned long)10 * sizeof(int));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 4294967295;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
enum E *memset_e_E_FF(enum E *ptr, size_t len)
{
  enum E *__retres;
  __retres = (enum E *)memset((void *)ptr,255,len);
  return __retres;
}

void with_enum(enum E dest[10])
{
  enum E *res = memset_e_E_FF(dest,(unsigned long)10 * sizeof(enum E));
  memset_e_E_FF(res,(unsigned long)10 * sizeof(enum E));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 4294967295;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned int *memset_uint_FF(unsigned int *ptr, size_t len)
{
  unsigned int *__retres;
  __retres = (unsigned int *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_integer(unsigned int dest[10])
{
  unsigned int *res =
    memset_uint_FF(dest,(unsigned long)10 * sizeof(unsigned int));
  memset_uint_FF(res,(unsigned long)10 * sizeof(unsigned int));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ ~((long)0);
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
long *memset_long_FF(long *ptr, size_t len)
{
  long *__retres;
  __retres = (long *)memset((void *)ptr,255,len);
  return __retres;
}

void long_integer(long dest[10])
{
  long *res = memset_long_FF(dest,(unsigned long)10 * sizeof(long));
  memset_long_FF(res,(unsigned long)10 * sizeof(long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 18446744073709551615;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned long *memset_ulong_FF(unsigned long *ptr, size_t len)
{
  unsigned long *__retres;
  __retres = (unsigned long *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_long_integer(unsigned long dest[10])
{
  unsigned long *res =
    memset_ulong_FF(dest,(unsigned long)10 * sizeof(unsigned long));
  memset_ulong_FF(res,(unsigned long)10 * sizeof(unsigned long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ ~((long long)0);
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
long long *memset_llong_FF(long long *ptr, size_t len)
{
  long long *__retres;
  __retres = (long long *)memset((void *)ptr,255,len);
  return __retres;
}

void long_long_integer(long long dest[10])
{
  long long *res =
    memset_llong_FF(dest,(unsigned long)10 * sizeof(long long));
  memset_llong_FF(res,(unsigned long)10 * sizeof(long long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 18446744073709551615;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned long long *memset_ullong_FF(unsigned long long *ptr, size_t len)
{
  unsigned long long *__retres;
  __retres = (unsigned long long *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_long_long_integer(unsigned long long dest[10])
{
  unsigned long long *res =
    memset_ullong_FF(dest,(unsigned long)10 * sizeof(unsigned long long));
  memset_ullong_FF(res,(unsigned long)10 * sizeof(unsigned long long));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ \is_NaN(*(ptr + j0));
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
float *memset_float_FF(float *ptr, size_t len)
{
  float *__retres;
  __retres = (float *)memset((void *)ptr,255,len);
  return __retres;
}

void floats(float dest[10])
{
  float *res = memset_float_FF(dest,(unsigned long)10 * sizeof(float));
  memset_float_FF(res,(unsigned long)10 * sizeof(float));
  return;
}

void with_named(named dest[10])
{
  named *res = memset_int_FF(dest,(unsigned long)10 * sizeof(named));
  memset_int_FF(res,(unsigned long)10 * sizeof(named));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (ptr + j0)->x ≡ ~((int)0) ∧ (ptr + j0)->y ≡ ~((int)0);
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_FF(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,255,len);
  return __retres;
}

void structure(struct X dest[10])
{
  struct X *res = memset_st_X_FF(dest,(unsigned long)10 * sizeof(struct X));
  memset_st_X_FF(res,(unsigned long)10 * sizeof(struct X));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ ¬\valid_read(*(ptr + j0));
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int **memset_ptr_int_FF(int **ptr, size_t len)
{
  int **__retres;
  __retres = (int **)memset((void *)ptr,255,len);
  return __retres;
}

void pointers(int *dest[10])
{
  int **res = memset_ptr_int_FF(dest,(unsigned long)10 * sizeof(int *));
  memset_ptr_int_FF(res,(unsigned long)10 * sizeof(int *));
  return;
}

/*@ requires aligned_end: len % 40 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 40; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 40;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(ptr + j0))[j1] ≡ ~((int)0));
    ensures result: \result ≡ ptr;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1] \from \nothing;
    assigns \result \from ptr;
 */
int (*memset_arr10_int_FF(int (*ptr)[10], size_t len))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])memset((void *)ptr,255,len);
  return __retres;
}

void nested(int (*dest)[10], int n)
{
  int (*res)[10] =
    memset_arr10_int_FF(dest,(unsigned long)n * sizeof(int [10]));
  memset_arr10_int_FF(res,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest)
{
  void *res = memset(dest,0xFF,(size_t)10);
  memset(res,0xFF,(size_t)10);
  return;
}

void with_null_or_int(void)
{
  memset((void *)0,0xFF,(size_t)10);
  memset((void *)((int *)42),0xFF,(size_t)10);
  return;
}


[kernel] Parsing ocode_memset_FF.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10])
{
  char *res = memset_char(dest,(char)0xFF,(size_t)10);
  memset_char(res,(char)0xFF,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(unsigned char dest[10])
{
  unsigned char *res = memset_uchar(dest,(unsigned char)0xFF,(size_t)10);
  memset_uchar(res,(unsigned char)0xFF,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1;
             0 ≤ j1 < 10 ⇒ (*(\old(ptr) + j0))[j1] ≡ \old(value));
    ensures result: \result ≡ \old(ptr);
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10])
{
  char (*res)[10] = memset_arr10_char(dest,(char)0xFF,(size_t)100);
  memset_arr10_char(res,(char)0xFF,(size_t)100);
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ ~((int)0);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int *memset_int_FF(int *ptr, size_t len)
{
  int *__retres;
  __retres = (int *)memset((void *)ptr,255,len);
  return __retres;
}

void integer(int dest[10])
{
  int *res = memset_int_FF(dest,(unsigned long)10 * sizeof(int));
  memset_int_FF(res,(unsigned long)10 * sizeof(int));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 4294967295;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
enum E *memset_e_E_FF(enum E *ptr, size_t len)
{
  enum E *__retres;
  __retres = (enum E *)memset((void *)ptr,255,len);
  return __retres;
}

void with_enum(enum E dest[10])
{
  enum E *res = memset_e_E_FF(dest,(unsigned long)10 * sizeof(enum E));
  memset_e_E_FF(res,(unsigned long)10 * sizeof(enum E));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 4294967295;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned int *memset_uint_FF(unsigned int *ptr, size_t len)
{
  unsigned int *__retres;
  __retres = (unsigned int *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_integer(unsigned int dest[10])
{
  unsigned int *res =
    memset_uint_FF(dest,(unsigned long)10 * sizeof(unsigned int));
  memset_uint_FF(res,(unsigned long)10 * sizeof(unsigned int));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ ~((long)0);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
long *memset_long_FF(long *ptr, size_t len)
{
  long *__retres;
  __retres = (long *)memset((void *)ptr,255,len);
  return __retres;
}

void long_integer(long dest[10])
{
  long *res = memset_long_FF(dest,(unsigned long)10 * sizeof(long));
  memset_long_FF(res,(unsigned long)10 * sizeof(long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 18446744073709551615;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned long *memset_ulong_FF(unsigned long *ptr, size_t len)
{
  unsigned long *__retres;
  __retres = (unsigned long *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_long_integer(unsigned long dest[10])
{
  unsigned long *res =
    memset_ulong_FF(dest,(unsigned long)10 * sizeof(unsigned long));
  memset_ulong_FF(res,(unsigned long)10 * sizeof(unsigned long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ ~((long long)0);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
long long *memset_llong_FF(long long *ptr, size_t len)
{
  long long *__retres;
  __retres = (long long *)memset((void *)ptr,255,len);
  return __retres;
}

void long_long_integer(long long dest[10])
{
  long long *res =
    memset_llong_FF(dest,(unsigned long)10 * sizeof(long long));
  memset_llong_FF(res,(unsigned long)10 * sizeof(long long));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 18446744073709551615;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
unsigned long long *memset_ullong_FF(unsigned long long *ptr, size_t len)
{
  unsigned long long *__retres;
  __retres = (unsigned long long *)memset((void *)ptr,255,len);
  return __retres;
}

void unsigned_long_long_integer(unsigned long long dest[10])
{
  unsigned long long *res =
    memset_ullong_FF(dest,(unsigned long)10 * sizeof(unsigned long long));
  memset_ullong_FF(res,(unsigned long)10 * sizeof(unsigned long long));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ \is_NaN(*(\old(ptr) + j0));
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
float *memset_float_FF(float *ptr, size_t len)
{
  float *__retres;
  __retres = (float *)memset((void *)ptr,255,len);
  return __retres;
}

void floats(float dest[10])
{
  float *res = memset_float_FF(dest,(unsigned long)10 * sizeof(float));
  memset_float_FF(res,(unsigned long)10 * sizeof(float));
  return;
}

void with_named(named dest[10])
{
  named *res = memset_int_FF(dest,(unsigned long)10 * sizeof(named));
  memset_int_FF(res,(unsigned long)10 * sizeof(named));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (\old(ptr) + j0)->x ≡ ~((int)0) ∧
          (\old(ptr) + j0)->y ≡ ~((int)0);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_FF(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,255,len);
  return __retres;
}

void structure(struct X dest[10])
{
  struct X *res = memset_st_X_FF(dest,(unsigned long)10 * sizeof(struct X));
  memset_st_X_FF(res,(unsigned long)10 * sizeof(struct X));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ ¬\valid_read(*(\old(ptr) + j0));
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int **memset_ptr_int_FF(int **ptr, size_t len)
{
  int **__retres;
  __retres = (int **)memset((void *)ptr,255,len);
  return __retres;
}

void pointers(int *dest[10])
{
  int **res = memset_ptr_int_FF(dest,(unsigned long)10 * sizeof(int *));
  memset_ptr_int_FF(res,(unsigned long)10 * sizeof(int *));
  return;
}

/*@ requires aligned_end: len % 40 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 40; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 40;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1;
             0 ≤ j1 < 10 ⇒ (*(\old(ptr) + j0))[j1] ≡ ~((int)0));
    ensures result: \result ≡ \old(ptr);
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1] \from \nothing;
    assigns \result \from ptr;
 */
int (*memset_arr10_int_FF(int (*ptr)[10], size_t len))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])memset((void *)ptr,255,len);
  return __retres;
}

void nested(int (*dest)[10], int n)
{
  int (*res)[10] =
    memset_arr10_int_FF(dest,(unsigned long)n * sizeof(int [10]));
  memset_arr10_int_FF(res,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest)
{
  void *res = memset(dest,0xFF,(size_t)10);
  memset(res,0xFF,(size_t)10);
  return;
}

void with_null_or_int(void)
{
  memset((void *)0,0xFF,(size_t)10);
  memset((void *)((int *)42),0xFF,(size_t)10);
  return;
}


