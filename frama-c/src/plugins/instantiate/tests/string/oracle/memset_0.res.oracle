[kernel] Parsing memset_0.c (with preprocessing)
[instantiate] memset_0.c:62: Warning: memset instantiator cannot replace call
[instantiate] memset_0.c:63: Warning: memset instantiator cannot replace call
[instantiate] memset_0.c:67: Warning: memset instantiator cannot replace call
[instantiate] memset_0.c:68: Warning: memset instantiator cannot replace call
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10])
{
  char *res = memset_char(dest,(char)0,(size_t)10);
  memset_char(res,(char)0,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content: ∀ ℤ j0; 0 ≤ j0 < len ⇒ *(ptr + j0) ≡ value;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(unsigned char dest[10])
{
  unsigned char *res = memset_uchar(dest,(unsigned char)0,(size_t)10);
  memset_uchar(res,(unsigned char)0,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(ptr + j0))[j1] ≡ value);
    ensures result: \result ≡ ptr;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10])
{
  char (*res)[10] = memset_arr10_char(dest,(char)0,(size_t)100);
  memset_arr10_char(res,(char)0,(size_t)100);
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 0;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int *memset_int_0(int *ptr, size_t len)
{
  int *__retres;
  __retres = (int *)memset((void *)ptr,0,len);
  return __retres;
}

void integer(int dest[10])
{
  int *res = memset_int_0(dest,(unsigned long)10 * sizeof(int));
  memset_int_0(res,(unsigned long)10 * sizeof(int));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 0;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
enum E *memset_e_E_0(enum E *ptr, size_t len)
{
  enum E *__retres;
  __retres = (enum E *)memset((void *)ptr,0,len);
  return __retres;
}

void with_enum(enum E dest[10])
{
  enum E *res = memset_e_E_0(dest,(unsigned long)10 * sizeof(enum E));
  memset_e_E_0(res,(unsigned long)10 * sizeof(enum E));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ 0.;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
float *memset_float_0(float *ptr, size_t len)
{
  float *__retres;
  __retres = (float *)memset((void *)ptr,0,len);
  return __retres;
}

void floats(float dest[10])
{
  float *res = memset_float_0(dest,(unsigned long)10 * sizeof(float));
  memset_float_0(res,(unsigned long)10 * sizeof(float));
  return;
}

void with_named(named dest[10])
{
  named *res = memset_int_0(dest,(unsigned long)10 * sizeof(named));
  memset_int_0(res,(unsigned long)10 * sizeof(named));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒ (ptr + j0)->x ≡ 0 ∧ (ptr + j0)->y ≡ 0;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_0(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,0,len);
  return __retres;
}

void structure(struct X dest[10])
{
  struct X *res = memset_st_X_0(dest,(unsigned long)10 * sizeof(struct X));
  memset_st_X_0(res,(unsigned long)10 * sizeof(struct X));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(ptr + j0) ≡ \null;
    ensures result: \result ≡ ptr;
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int **memset_ptr_int_0(int **ptr, size_t len)
{
  int **__retres;
  __retres = (int **)memset((void *)ptr,0,len);
  return __retres;
}

void pointers(int *dest[10])
{
  int **res = memset_ptr_int_0(dest,(unsigned long)10 * sizeof(int *));
  memset_ptr_int_0(res,(unsigned long)10 * sizeof(int *));
  return;
}

/*@ requires aligned_end: len % 40 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 40; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = len / 40;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(ptr + j0))[j1] ≡ 0);
    ensures result: \result ≡ ptr;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1] \from \nothing;
    assigns \result \from ptr;
 */
int (*memset_arr10_int_0(int (*ptr)[10], size_t len))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])memset((void *)ptr,0,len);
  return __retres;
}

void nested(int (*dest)[10], int n)
{
  int (*res)[10] =
    memset_arr10_int_0(dest,(unsigned long)n * sizeof(int [10]));
  memset_arr10_int_0(res,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest)
{
  void *res = memset(dest,0,(size_t)10);
  memset(res,0,(size_t)10);
  return;
}

void with_null_or_int(void)
{
  memset((void *)0,0,(size_t)10);
  memset((void *)((int *)42),0,(size_t)10);
  return;
}


[kernel] Parsing ocode_memset_0.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
#include "string.h"
#include "strings.h"
struct X {
   int x ;
   int y ;
};
typedef int named;
enum E {
    A = 0,
    B = 1,
    C = 2
};
/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
char *memset_char(char *ptr, char value, size_t len)
{
  char *__retres;
  __retres = (char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void chars(char dest[10])
{
  char *res = memset_char(dest,(char)0,(size_t)10);
  memset_char(res,(char)0,(size_t)10);
  return;
}

/*@ requires in_bounds_value: 0 ≤ value < 256;
    requires valid_dest: \valid(ptr + (0 .. len - 1));
    ensures
      set_content:
        ∀ ℤ j0;
          0 ≤ j0 < \old(len) ⇒ *(\old(ptr) + j0) ≡ \old(value);
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len - 1)), \result;
    assigns *(ptr + (0 .. len - 1)) \from value;
    assigns \result \from ptr;
 */
unsigned char *memset_uchar(unsigned char *ptr, unsigned char value,
                            size_t len)
{
  unsigned char *__retres;
  __retres = (unsigned char *)memset((void *)ptr,(int)value,len);
  return __retres;
}

void uchars(unsigned char dest[10])
{
  unsigned char *res = memset_uchar(dest,(unsigned char)0,(size_t)10);
  memset_uchar(res,(unsigned char)0,(size_t)10);
  return;
}

/*@ requires in_bounds_value: -128 ≤ value < 128;
    requires
      valid_dest: \let __fc_len = len / 10; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 10;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1;
             0 ≤ j1 < 10 ⇒ (*(\old(ptr) + j0))[j1] ≡ \old(value));
    ensures result: \result ≡ \old(ptr);
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 10 - 1)))[0 .. 10 - 1] \from value;
    assigns \result \from ptr;
 */
char (*memset_arr10_char(char (*ptr)[10], char value, size_t len))[10]
{
  char (*__retres)[10];
  __retres = (char (*)[10])memset((void *)ptr,(int)value,len);
  return __retres;
}

void nested_chars(char dest[10][10])
{
  char (*res)[10] = memset_arr10_char(dest,(char)0,(size_t)100);
  memset_arr10_char(res,(char)0,(size_t)100);
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 0;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int *memset_int_0(int *ptr, size_t len)
{
  int *__retres;
  __retres = (int *)memset((void *)ptr,0,len);
  return __retres;
}

void integer(int dest[10])
{
  int *res = memset_int_0(dest,(unsigned long)10 * sizeof(int));
  memset_int_0(res,(unsigned long)10 * sizeof(int));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 0;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
enum E *memset_e_E_0(enum E *ptr, size_t len)
{
  enum E *__retres;
  __retres = (enum E *)memset((void *)ptr,0,len);
  return __retres;
}

void with_enum(enum E dest[10])
{
  enum E *res = memset_e_E_0(dest,(unsigned long)10 * sizeof(enum E));
  memset_e_E_0(res,(unsigned long)10 * sizeof(enum E));
  return;
}

/*@ requires aligned_end: len % 4 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 4; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 4;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ 0.;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 4 - 1)), \result;
    assigns *(ptr + (0 .. len / 4 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
float *memset_float_0(float *ptr, size_t len)
{
  float *__retres;
  __retres = (float *)memset((void *)ptr,0,len);
  return __retres;
}

void floats(float dest[10])
{
  float *res = memset_float_0(dest,(unsigned long)10 * sizeof(float));
  memset_float_0(res,(unsigned long)10 * sizeof(float));
  return;
}

void with_named(named dest[10])
{
  named *res = memset_int_0(dest,(unsigned long)10 * sizeof(named));
  memset_int_0(res,(unsigned long)10 * sizeof(named));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (\old(ptr) + j0)->x ≡ 0 ∧ (\old(ptr) + j0)->y ≡ 0;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
struct X *memset_st_X_0(struct X *ptr, size_t len)
{
  struct X *__retres;
  __retres = (struct X *)memset((void *)ptr,0,len);
  return __retres;
}

void structure(struct X dest[10])
{
  struct X *res = memset_st_X_0(dest,(unsigned long)10 * sizeof(struct X));
  memset_st_X_0(res,(unsigned long)10 * sizeof(struct X));
  return;
}

/*@ requires aligned_end: len % 8 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 8; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 8;
        ∀ ℤ j0; 0 ≤ j0 < __fc_len ⇒ *(\old(ptr) + j0) ≡ \null;
    ensures result: \result ≡ \old(ptr);
    assigns *(ptr + (0 .. len / 8 - 1)), \result;
    assigns *(ptr + (0 .. len / 8 - 1)) \from \nothing;
    assigns \result \from ptr;
 */
int **memset_ptr_int_0(int **ptr, size_t len)
{
  int **__retres;
  __retres = (int **)memset((void *)ptr,0,len);
  return __retres;
}

void pointers(int *dest[10])
{
  int **res = memset_ptr_int_0(dest,(unsigned long)10 * sizeof(int *));
  memset_ptr_int_0(res,(unsigned long)10 * sizeof(int *));
  return;
}

/*@ requires aligned_end: len % 40 ≡ 0;
    requires
      valid_dest: \let __fc_len = len / 40; \valid(ptr + (0 .. __fc_len - 1));
    ensures
      set_content:
        \let __fc_len = \old(len) / 40;
        ∀ ℤ j0;
          0 ≤ j0 < __fc_len ⇒
          (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(\old(ptr) + j0))[j1] ≡ 0);
    ensures result: \result ≡ \old(ptr);
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1], \result;
    assigns (*(ptr + (0 .. len / 40 - 1)))[0 .. 10 - 1] \from \nothing;
    assigns \result \from ptr;
 */
int (*memset_arr10_int_0(int (*ptr)[10], size_t len))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])memset((void *)ptr,0,len);
  return __retres;
}

void nested(int (*dest)[10], int n)
{
  int (*res)[10] =
    memset_arr10_int_0(dest,(unsigned long)n * sizeof(int [10]));
  memset_arr10_int_0(res,(unsigned long)n * sizeof(int [10]));
  return;
}

void with_void(void *dest)
{
  void *res = memset(dest,0,(size_t)10);
  memset(res,0,(size_t)10);
  return;
}

void with_null_or_int(void)
{
  memset((void *)0,0,(size_t)10);
  memset((void *)((int *)42),0,(size_t)10);
  return;
}


