[kernel] Parsing free.c (with preprocessing)
[instantiate] free.c:13: Warning: free instantiator cannot replace call
/* Generated by Frama-C */
#include "stdlib.h"
struct incomplete;
/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(ptr);
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_int(int *ptr)
{
  free((void *)ptr);
  return;
}

void foo(int *x)
{
  free_int(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(ptr);
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_float(float *ptr)
{
  free((void *)ptr);
  return;
}

void bar(float *x)
{
  free_float(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(ptr);
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_arr10_int(int (*ptr)[10])
{
  free((void *)ptr);
  return;
}

void baz(int (*x)[10])
{
  free_arr10_int(x);
  return;
}

void with_void(void *x)
{
  free(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(ptr);
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_st_incomplete(struct incomplete *ptr)
{
  free((void *)ptr);
  return;
}

void with_incomplete(struct incomplete *t)
{
  free_st_incomplete(t);
  return;
}


[kernel] Parsing ocode_free.c (with preprocessing)
/* Generated by Frama-C */
#include "stdlib.h"
struct incomplete;
/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(\old(ptr));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_int(int *ptr)
{
  free((void *)ptr);
  return;
}

void foo(int *x)
{
  free_int(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(\old(ptr));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_float(float *ptr)
{
  free((void *)ptr);
  return;
}

void bar(float *x)
{
  free_float(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(\old(ptr));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_arr10_int(int (*ptr)[10])
{
  free((void *)ptr);
  return;
}

void baz(int (*x)[10])
{
  free_arr10_int(x);
  return;
}

void with_void(void *x)
{
  free(x);
  return;
}

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(\old(ptr));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_st_incomplete(struct incomplete *ptr)
{
  free((void *)ptr);
  return;
}

void with_incomplete(struct incomplete *t)
{
  free_st_incomplete(t);
  return;
}


