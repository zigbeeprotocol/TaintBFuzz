[kernel] Parsing calloc.c (with preprocessing)
[instantiate] calloc.c:24: Warning: calloc instantiator cannot replace call
[instantiate] calloc.c:25: Warning: calloc instantiator cannot replace call
/* Generated by Frama-C */
#include "stdlib.h"
struct X {
   int x ;
   int y ;
};
struct Flex {
   int x ;
   char c ;
   int f[] ;
};
enum E {
    A = 0,
    B = 1,
    C = 2
};
struct incomplete;
/*@ requires correct_size: 0 ≤ size - 8 ∧ 0 ≡ (size - 8) % 4;
    requires only_one: num ≡ 1;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          \let __fc_flexlen = (size - 8) / 4;
            \result->x ≡ 0 ∧
            \result->c ≡ 0 ∧
            (∀ ℤ j1; 0 ≤ j1 < __fc_flexlen ⇒ \result->f[j1] ≡ 0);
      ensures
        initialization:
          \let __fc_flexlen = (size - 8) / 4;
            \initialized(&\result->x) ∧
            \initialized(&\result->c) ∧
            (∀ ℤ j1;
               0 ≤ j1 < __fc_flexlen ⇒ \initialized(&\result->f[j1]));
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
struct Flex *calloc_st_Flex(size_t num, size_t size)
{
  struct Flex *__retres;
  __retres = (struct Flex *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 40;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0;
            0 ≤ j0 < num ⇒
            (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(\result + j0))[j1] ≡ 0);
      ensures
        initialization:
          ∀ ℤ j0;
            0 ≤ j0 < num ⇒
            (∀ ℤ j1;
               0 ≤ j1 < 10 ⇒ \initialized(&(*(\result + j0))[j1]));
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int (*calloc_arr10_int(size_t num, size_t size))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 1;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
char *calloc_char(size_t num, size_t size)
{
  char *__retres;
  __retres = (char *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 8;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0;
            0 ≤ j0 < num ⇒
            (\result + j0)->x ≡ 0 ∧ (\result + j0)->y ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0;
            0 ≤ j0 < num ⇒
            \initialized(&(\result + j0)->x) ∧
            \initialized(&(\result + j0)->y);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
struct X *calloc_st_X(size_t num, size_t size)
{
  struct X *__retres;
  __retres = (struct X *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ *(\result + j0) ≡ 0.;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
float *calloc_float(size_t num, size_t size)
{
  float *__retres;
  __retres = (float *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
enum E *calloc_e_E(size_t num, size_t size)
{
  enum E *__retres;
  __retres = (enum E *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *calloc_int(size_t num, size_t size)
{
  int *__retres;
  __retres = (int *)calloc(num,size);
  return __retres;
}

int main(void)
{
  int __retres;
  int *pi = calloc_int((size_t)10,sizeof(int));
  enum E *pe = calloc_e_E((size_t)10,sizeof(enum E));
  float *pf = calloc_float((size_t)10,sizeof(float));
  struct X *px = calloc_st_X((size_t)10,sizeof(struct X));
  char *pc = calloc_char((size_t)10,sizeof(char));
  int (*pa)[10] = calloc_arr10_int((size_t)10,sizeof(int [10]));
  struct Flex *f =
    calloc_st_Flex((size_t)1,
                   sizeof(struct Flex) + (unsigned long)3 * sizeof(int));
  void *v = calloc((size_t)10,sizeof(char));
  struct incomplete *inc = calloc((size_t)10,(size_t)10);
  __retres = 0;
  return __retres;
}


[kernel] Parsing ocode_calloc.c (with preprocessing)
/* Generated by Frama-C */
#include "stdlib.h"
struct X {
   int x ;
   int y ;
};
struct Flex {
   int x ;
   char c ;
   int f[] ;
};
enum E {
    A = 0,
    B = 1,
    C = 2
};
struct incomplete;
/*@ requires correct_size: 0 ≤ size - 8 ∧ 0 ≡ (size - 8) % 4;
    requires only_one: num ≡ 1;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          \let __fc_flexlen = (\old(size) - 8) / 4;
            \result->x ≡ 0 ∧ \result->c ≡ 0 ∧
            (∀ ℤ j1; 0 ≤ j1 < __fc_flexlen ⇒ \result->f[j1] ≡ 0);
      ensures
        initialization:
          \let __fc_flexlen = (\old(size) - 8) / 4;
            \initialized(&\result->x) ∧ \initialized(&\result->c) ∧
            (∀ ℤ j1;
               0 ≤ j1 < __fc_flexlen ⇒ \initialized(&\result->f[j1]));
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
struct Flex *calloc_st_Flex(size_t num, size_t size)
{
  struct Flex *__retres;
  __retres = (struct Flex *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 40;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0;
            0 ≤ j0 < \old(num) ⇒
            (∀ ℤ j1; 0 ≤ j1 < 10 ⇒ (*(\result + j0))[j1] ≡ 0);
      ensures
        initialization:
          ∀ ℤ j0;
            0 ≤ j0 < \old(num) ⇒
            (∀ ℤ j1;
               0 ≤ j1 < 10 ⇒ \initialized(&(*(\result + j0))[j1]));
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int (*calloc_arr10_int(size_t num, size_t size))[10]
{
  int (*__retres)[10];
  __retres = (int (*)[10])calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 1;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
char *calloc_char(size_t num, size_t size)
{
  char *__retres;
  __retres = (char *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 8;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0;
            0 ≤ j0 < \old(num) ⇒
            (\result + j0)->x ≡ 0 ∧ (\result + j0)->y ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0;
            0 ≤ j0 < \old(num) ⇒
            \initialized(&(\result + j0)->x) ∧
            \initialized(&(\result + j0)->y);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
struct X *calloc_st_X(size_t num, size_t size)
{
  struct X *__retres;
  __retres = (struct X *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ *(\result + j0) ≡ 0.;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
float *calloc_float(size_t num, size_t size)
{
  float *__retres;
  __retres = (float *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
enum E *calloc_e_E(size_t num, size_t size)
{
  enum E *__retres;
  __retres = (enum E *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *calloc_int(size_t num, size_t size)
{
  int *__retres;
  __retres = (int *)calloc(num,size);
  return __retres;
}

int main(void)
{
  int __retres;
  int *pi = calloc_int((size_t)10,sizeof(int));
  enum E *pe = calloc_e_E((size_t)10,sizeof(enum E));
  float *pf = calloc_float((size_t)10,sizeof(float));
  struct X *px = calloc_st_X((size_t)10,sizeof(struct X));
  char *pc = calloc_char((size_t)10,sizeof(char));
  int (*pa)[10] = calloc_arr10_int((size_t)10,sizeof(int [10]));
  struct Flex *f =
    calloc_st_Flex((size_t)1,
                   sizeof(struct Flex) + (unsigned long)3 * sizeof(int));
  void *v = calloc((size_t)10,sizeof(char));
  struct incomplete *inc = calloc((size_t)10,(size_t)10);
  __retres = 0;
  return __retres;
}


