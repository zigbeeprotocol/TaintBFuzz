[kernel] Parsing no_fc_stdlib.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ i) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∧ i > 18446744073709551615 ⇒ ¬is_allocable(i);
  
  }

*/
void *malloc(size_t s);

void *calloc(size_t num, size_t size);

void free(void *ptr);

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(ptr);
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_int(int *ptr)
{
  free((void *)ptr);
  return;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures fresh_result: \fresh{Old, Here}(\result,num * size);
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < num ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *calloc_int(size_t num, size_t size)
{
  int *__retres;
  __retres = (int *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, size;
    assigns __fc_heap_status \from __fc_heap_status, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(size);
      ensures fresh_result: \fresh{Old, Here}(\result,size);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, size;
      assigns __fc_heap_status \from __fc_heap_status, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *malloc_int(size_t size)
{
  int *__retres;
  __retres = (int *)malloc(size);
  return __retres;
}

void foo(void)
{
  int *p = malloc_int(sizeof(int));
  int *q = calloc_int((size_t)2,sizeof(int));
  free_int(p);
  free_int(q);
  return;
}


[kernel] Parsing ocode_no_fc_stdlib.c (with preprocessing)
/* Generated by Frama-C */
#include "stddef.h"
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ i) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∧ i > 18446744073709551615 ⇒ ¬is_allocable(i);
  
  }

*/
void *malloc(size_t s);

void *calloc(size_t num, size_t size);

void free(void *ptr);

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status, ptr;
    frees ptr;
    
    behavior allocation:
      assumes ptr ≢ \null;
      ensures freed: \allocable(\old(ptr));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status, ptr;
      frees ptr;
    
    behavior no_allocation:
      assumes ptr ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void free_int(int *ptr)
{
  free((void *)ptr);
  return;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, num, size;
    assigns __fc_heap_status \from __fc_heap_status, num, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(num * size);
      ensures
        fresh_result: \fresh{Old, Here}(\result,\old(num) * \old(size));
      ensures
        zero_initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ *(\result + j0) ≡ 0;
      ensures
        initialization:
          ∀ ℤ j0; 0 ≤ j0 < \old(num) ⇒ \initialized(\result + j0);
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, num, size;
      assigns __fc_heap_status \from __fc_heap_status, num, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(num * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *calloc_int(size_t num, size_t size)
{
  int *__retres;
  __retres = (int *)calloc(num,size);
  return __retres;
}

/*@ requires correct_size: 0 ≡ size % 4;
    assigns \result, __fc_heap_status;
    assigns \result \from __fc_heap_status, size;
    assigns __fc_heap_status \from __fc_heap_status, size;
    allocates \result;
    
    behavior allocation:
      assumes allocable: is_allocable(size);
      ensures fresh_result: \fresh{Old, Here}(\result,\old(size));
      assigns \result, __fc_heap_status;
      assigns \result \from __fc_heap_status, size;
      assigns __fc_heap_status \from __fc_heap_status, size;
      allocates \result;
    
    behavior no_allocation:
      assumes allocable: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int *malloc_int(size_t size)
{
  int *__retres;
  __retres = (int *)malloc(size);
  return __retres;
}

void foo(void)
{
  int *p = malloc_int(sizeof(int));
  int *q = calloc_int((size_t)2,sizeof(int));
  free_int(p);
  free_int(q);
  return;
}


