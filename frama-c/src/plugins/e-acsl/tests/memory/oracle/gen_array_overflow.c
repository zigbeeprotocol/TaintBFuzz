/* Generated by Frama-C */
#include "pthread.h"
#include "sched.h"
#include "signal.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "time.h"
extern  __attribute__((__FC_BUILTIN__)) int __e_acsl_sound_verdict;

struct dat {
   int arr[4] ;
};
struct dat2 {
   struct dat *p[2] ;
};
void init4(int *arr, int start)
{
  int i = 0;
  while (i < 4) {
    *(arr + i) = start + i;
    i ++;
  }
  return;
}

int main(void)
{
  int __retres;
  __e_acsl_memory_init((int *)0,(char ***)0,8UL);
  int a[4] = {1, 2, 3, 4};
  __e_acsl_store_block((void *)(a),16UL);
  __e_acsl_full_init((void *)(& a));
  int b[4] = {5, 6, 7, 8};
  {
    int __gen_e_acsl_valid;
    __e_acsl_assert_data_t __gen_e_acsl_assert_data = {.values = (void *)0};
    __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data,"&a[4]",
                                 (void *)(& a[4]));
    __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data,"sizeof(int)",
                                   0,sizeof(int));
    __gen_e_acsl_valid = __e_acsl_valid((void *)(& a[4]),sizeof(int),
                                        (void *)(a),(void *)0);
    __e_acsl_assert_register_int(& __gen_e_acsl_assert_data,"\\valid(&a[4])",
                                 0,__gen_e_acsl_valid);
    __gen_e_acsl_assert_data.blocking = 1;
    __gen_e_acsl_assert_data.kind = "Assertion";
    __gen_e_acsl_assert_data.pred_txt = "!\\valid(&a[4])";
    __gen_e_acsl_assert_data.file = "array_overflow.c";
    __gen_e_acsl_assert_data.fct = "main";
    __gen_e_acsl_assert_data.line = 31;
    __e_acsl_assert(! __gen_e_acsl_valid,& __gen_e_acsl_assert_data);
    __e_acsl_assert_clean(& __gen_e_acsl_assert_data);
  }
  /*@ assert !\valid(&a[4]); */ ;
  int *ap = a;
  __e_acsl_store_block((void *)(& ap),8UL);
  __e_acsl_full_init((void *)(& ap));
  int *bp = b;
  {
    int __gen_e_acsl_valid_2;
    __e_acsl_assert_data_t __gen_e_acsl_assert_data_2 =
      {.values = (void *)0};
    __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data_2,
                                 "&(*((int (*)[])ap))[4]",
                                 (void *)(& (*((int (*)[])ap))[4]));
    __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data_2,
                                   "sizeof(int)",0,sizeof(int));
    __gen_e_acsl_valid_2 = __e_acsl_valid((void *)(& (*((int (*)[])ap))[4]),
                                          sizeof(int),
                                          (void *)(*((int (*)[])ap)),
                                          (void *)0);
    __e_acsl_assert_register_int(& __gen_e_acsl_assert_data_2,
                                 "\\valid(&(*((int (*)[])ap))[4])",0,
                                 __gen_e_acsl_valid_2);
    __gen_e_acsl_assert_data_2.blocking = 1;
    __gen_e_acsl_assert_data_2.kind = "Assertion";
    __gen_e_acsl_assert_data_2.pred_txt = "!\\valid(&(*((int (*)[])ap))[4])";
    __gen_e_acsl_assert_data_2.file = "array_overflow.c";
    __gen_e_acsl_assert_data_2.fct = "main";
    __gen_e_acsl_assert_data_2.line = 36;
    __e_acsl_assert(! __gen_e_acsl_valid_2,& __gen_e_acsl_assert_data_2);
    __e_acsl_assert_clean(& __gen_e_acsl_assert_data_2);
  }
  /*@ assert !\valid(&(*((int (*)[])ap))[4]); */ ;
  struct dat d = {.arr = {4, 5, 6, 7}};
  __e_acsl_store_block((void *)(& d),16UL);
  __e_acsl_full_init((void *)(& d));
  struct dat dd = {.arr = {1, 2, 3, 9}};
  __e_acsl_store_block((void *)(& dd),16UL);
  __e_acsl_full_init((void *)(& dd));
  struct dat2 d2 = {.p = {& d, & dd}};
  __e_acsl_store_block((void *)(& d2),16UL);
  __e_acsl_full_init((void *)(& d2));
  {
    int __gen_e_acsl_valid_3;
    __e_acsl_assert_data_t __gen_e_acsl_assert_data_3 =
      {.values = (void *)0};
    __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data_3,"&d.arr[4]",
                                 (void *)(& d.arr[4]));
    __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data_3,
                                   "sizeof(int)",0,sizeof(int));
    __gen_e_acsl_valid_3 = __e_acsl_valid((void *)(& d.arr[4]),sizeof(int),
                                          (void *)(& d.arr[0]),(void *)0);
    __e_acsl_assert_register_int(& __gen_e_acsl_assert_data_3,
                                 "\\valid(&d.arr[4])",0,__gen_e_acsl_valid_3);
    __gen_e_acsl_assert_data_3.blocking = 1;
    __gen_e_acsl_assert_data_3.kind = "Assertion";
    __gen_e_acsl_assert_data_3.pred_txt = "!\\valid(&d.arr[4])";
    __gen_e_acsl_assert_data_3.file = "array_overflow.c";
    __gen_e_acsl_assert_data_3.fct = "main";
    __gen_e_acsl_assert_data_3.line = 42;
    __e_acsl_assert(! __gen_e_acsl_valid_3,& __gen_e_acsl_assert_data_3);
    __e_acsl_assert_clean(& __gen_e_acsl_assert_data_3);
  }
  /*@ assert !\valid(&d.arr[4]); */ ;
  {
    int __gen_e_acsl_valid_4;
    __e_acsl_assert_data_t __gen_e_acsl_assert_data_4 =
      {.values = (void *)0};
    __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data_4,
                                 "&(d2.p[1])->arr[2]",
                                 (void *)(& (d2.p[1])->arr[2]));
    __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data_4,
                                   "sizeof(int)",0,sizeof(int));
    __gen_e_acsl_valid_4 = __e_acsl_valid((void *)(& (d2.p[1])->arr[2]),
                                          sizeof(int),
                                          (void *)(& (d2.p[1])->arr[0]),
                                          (void *)0);
    __e_acsl_assert_register_int(& __gen_e_acsl_assert_data_4,
                                 "\\valid(&(d2.p[1])->arr[2])",0,
                                 __gen_e_acsl_valid_4);
    __gen_e_acsl_assert_data_4.blocking = 1;
    __gen_e_acsl_assert_data_4.kind = "Assertion";
    __gen_e_acsl_assert_data_4.pred_txt = "\\valid(&(d2.p[1])->arr[2])";
    __gen_e_acsl_assert_data_4.file = "array_overflow.c";
    __gen_e_acsl_assert_data_4.fct = "main";
    __gen_e_acsl_assert_data_4.line = 43;
    __e_acsl_assert(__gen_e_acsl_valid_4,& __gen_e_acsl_assert_data_4);
    __e_acsl_assert_clean(& __gen_e_acsl_assert_data_4);
  }
  /*@ assert \valid(&(d2.p[1])->arr[2]); */ ;
  __retres = 0;
  __e_acsl_delete_block((void *)(& d2));
  __e_acsl_delete_block((void *)(& dd));
  __e_acsl_delete_block((void *)(& d));
  __e_acsl_delete_block((void *)(& ap));
  __e_acsl_delete_block((void *)(a));
  __e_acsl_memory_clean();
  return __retres;
}


