[kernel] Parsing stack.i (no preprocessing)
[kernel] Parsing TMPDIR/aorai_stack_0.i (no preprocessing)
/* Generated by Frama-C */
enum aorai_States {
    accept = 0,
    aorai_reject = 1,
    empty_stack = 2,
    emptying_stack = 3,
    filled_stack = 4,
    filling_stack = 5,
    init = 6
};
enum aorai_ListOper {
    op_main = 2,
    op_pop = 1,
    op_push = 0
};
enum aorai_OpStatusList {
    aorai_Terminated = 1,
    aorai_Called = 0
};
/*@ check lemma init_deterministic_trans{L}: \true;
 */
/*@ check lemma filling_stack_deterministic_trans{L}: \true;
 */
/*@ check lemma aorai_reject_deterministic_trans{L}: \true;
 */
/*@ check lemma accept_deterministic_trans{L}: \true;
 */
int g = 0;
/*@ ghost enum aorai_ListOper aorai_CurOperation; */
/*@ ghost enum aorai_OpStatusList aorai_CurOpStatus; */
/*@
check lemma empty_stack_deterministic_trans{L}:
  ¬(\at(aorai_CurOperation,L) ≡ op_push ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Called ∧
     \at(aorai_CurOperation,L) ≡ op_main ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Terminated);
 */
/*@ ghost int aorai_CurStates = init; */
/*@ ghost int aorai_n = 0; */
/*@
check lemma filled_stack_deterministic_trans{L}:
  ¬(\at(aorai_CurOperation,L) ≡ op_pop ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Called ∧ \at(aorai_n,L) > 0 ∧
     \at(aorai_CurOperation,L) ≡ op_push ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Called);
 */
/*@
check lemma emptying_stack_deterministic_trans{L}:
  ¬(\at(aorai_CurOperation,L) ≡ op_pop ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Terminated ∧
     \at(aorai_n,L) ≡ 1 ∧ \at(aorai_CurOperation,L) ≡ op_pop ∧
     \at(aorai_CurOpStatus,L) ≡ aorai_Terminated ∧ \at(aorai_n,L) > 1);
 */
/*@ ghost
  /@ requires
       aorai_CurStates ≡ empty_stack ∨ aorai_CurStates ≡ filled_stack;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_push;
     assigns aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_out:
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_out:
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_out:
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_out:
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_in:
       assumes
         aorai_CurStates ≡ filled_stack ∨ aorai_CurStates ≡ empty_stack;
       ensures aorai_CurStates ≡ filling_stack;
     
     behavior buch_state_filling_stack_out:
       assumes
         aorai_CurStates ≢ filled_stack ∧ aorai_CurStates ≢ empty_stack;
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
   @/
  void push_pre_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_push;
    if (4 == aorai_CurStates) aorai_CurStates = filling_stack;
    else 
      if (2 == aorai_CurStates) aorai_CurStates = filling_stack;
      else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ ghost
  /@ requires aorai_CurStates ≡ filling_stack;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_push;
     assigns aorai_n, aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_out:
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_out:
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_out:
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_in_0:
       assumes aorai_CurStates ≡ filling_stack;
       ensures aorai_CurStates ≡ filled_stack;
       ensures aorai_n ≡ \old(aorai_n) + 1;
     
     behavior buch_state_filled_stack_out:
       assumes aorai_CurStates ≢ filling_stack;
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_out:
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
     
     behavior aorai_n_unchanged:
       assumes aorai_CurStates ≢ filling_stack;
       assumes aorai_CurStates ≢ filling_stack;
       ensures aorai_n ≡ \old(aorai_n);
   @/
  void push_post_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_push;
    if (5 == aorai_CurStates) {
      aorai_CurStates = filled_stack;
      aorai_n ++;
    }
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ requires
      aorai_CurStates ≡ empty_stack ∨ aorai_CurStates ≡ filled_stack;
    requires
      aorai_CurStates ≡ filled_stack ∨ aorai_CurStates ≢ filled_stack;
    requires
      aorai_CurStates ≡ empty_stack ∨ aorai_CurStates ≢ empty_stack;
    
    behavior Buchi_property_behavior:
      ensures aorai_CurStates ≡ filled_stack;
      ensures
        \at(aorai_CurStates ≡ filled_stack,Pre) ∧
        aorai_CurStates ≡ filled_stack ⇒
        aorai_n ≡ \at(aorai_n + 1,Pre) + 0;
      ensures
        \at(aorai_CurStates ≡ empty_stack,Pre) ∧
        aorai_CurStates ≡ filled_stack ⇒
        aorai_n ≡ \at(aorai_n + 1,Pre) + 0;
 */
void push(void)
{
  /*@ ghost push_pre_func(); */
  g ++;
  /*@ ghost push_post_func(); */
  return;
}

/*@ ghost
  /@ requires aorai_CurStates ≡ filled_stack;
     requires aorai_CurStates ≡ filled_stack ⇒ aorai_n > 0;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_pop;
     assigns aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_out:
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_out:
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_in:
       assumes aorai_CurStates ≡ filled_stack ∧ aorai_n > 0;
       ensures aorai_CurStates ≡ emptying_stack;
     
     behavior buch_state_emptying_stack_out:
       assumes aorai_CurStates ≢ filled_stack ∨ ¬(aorai_n > 0);
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_out:
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_out:
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
   @/
  void pop_pre_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_pop;
    if (4 == aorai_CurStates) 
      if (aorai_n > 0) aorai_CurStates = emptying_stack;
      else aorai_CurStates = aorai_reject;
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ ghost
  /@ requires aorai_CurStates ≡ emptying_stack;
     requires
       aorai_CurStates ≡ emptying_stack ⇒ aorai_n > 1 ∨ aorai_n ≡ 1;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_pop;
     assigns aorai_n, aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_out:
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_in_0:
       assumes aorai_CurStates ≡ emptying_stack ∧ aorai_n ≡ 1;
       ensures aorai_CurStates ≡ empty_stack;
       ensures aorai_n ≡ \old(aorai_n) - 1;
     
     behavior buch_state_empty_stack_out:
       assumes aorai_CurStates ≢ emptying_stack ∨ ¬(aorai_n ≡ 1);
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_out:
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_in_0:
       assumes aorai_CurStates ≡ emptying_stack ∧ aorai_n > 1;
       ensures aorai_CurStates ≡ filled_stack;
       ensures aorai_n ≡ \old(aorai_n) - 1;
     
     behavior buch_state_filled_stack_out:
       assumes aorai_CurStates ≢ emptying_stack ∨ ¬(aorai_n > 1);
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_out:
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
     
     behavior aorai_n_unchanged_0:
       assumes aorai_CurStates ≢ emptying_stack ∨ ¬(aorai_n > 1);
       assumes aorai_CurStates ≢ emptying_stack ∨ ¬(aorai_n ≡ 1);
       ensures aorai_n ≡ \old(aorai_n);
   @/
  void pop_post_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_pop;
    if (3 == aorai_CurStates) {
      if (aorai_n == 1) {
        aorai_CurStates = empty_stack;
        aorai_n --;
      }
      else goto __aorai_label;
    }
    else {
      __aorai_label: ;
      if (3 == aorai_CurStates) 
        if (aorai_n > 1) {
          aorai_CurStates = filled_stack;
          aorai_n --;
        }
        else aorai_CurStates = aorai_reject;
      else aorai_CurStates = aorai_reject;
    }
    return;
  }

*/

/*@ requires aorai_CurStates ≡ filled_stack;
    requires aorai_CurStates ≡ filled_stack ⇒ aorai_n > 0;
    
    behavior Buchi_property_behavior:
      ensures
        (aorai_CurStates ≡ empty_stack ⇒ aorai_n ≡ 1) ∧
        (aorai_CurStates ≡ filled_stack ⇒ aorai_n > 1);
      ensures
        aorai_CurStates ≡ empty_stack ∨ aorai_CurStates ≡ filled_stack;
      ensures
        \at(aorai_CurStates ≡ filled_stack,Pre) ∧
        aorai_CurStates ≡ filled_stack ⇒
        aorai_n ≡ \at(aorai_n - 1,Pre) + 0;
      ensures
        \at(aorai_CurStates ≡ filled_stack,Pre) ∧
        aorai_CurStates ≡ empty_stack ⇒
        aorai_n ≡ \at(aorai_n - 1,Pre) + 0;
 */
void pop(void)
{
  /*@ ghost pop_pre_func(); */
  /*@ assert g > 0; */ ;
  g --;
  /*@ ghost pop_post_func(); */
  return;
}

/*@ ghost
  /@ requires aorai_CurStates ≡ init;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_n, aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_out:
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_in_0:
       assumes aorai_CurStates ≡ init;
       ensures aorai_CurStates ≡ empty_stack;
       ensures aorai_n ≡ 0;
     
     behavior buch_state_empty_stack_out:
       assumes aorai_CurStates ≢ init;
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_out:
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_out:
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_out:
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
     
     behavior aorai_n_unchanged_1:
       assumes aorai_CurStates ≢ init;
       ensures aorai_n ≡ \old(aorai_n);
   @/
  void main_pre_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_main;
    if (6 == aorai_CurStates) {
      aorai_CurStates = empty_stack;
      aorai_n = 0;
    }
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ ghost
  /@ requires aorai_CurStates ≡ empty_stack;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_CurOpStatus, aorai_CurOperation, aorai_CurStates;
     
     behavior buch_state_accept_in:
       assumes aorai_CurStates ≡ empty_stack;
       ensures aorai_CurStates ≡ accept;
     
     behavior buch_state_accept_out:
       assumes aorai_CurStates ≢ empty_stack;
       ensures aorai_CurStates ≢ accept;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_empty_stack_out:
       ensures aorai_CurStates ≢ empty_stack;
     
     behavior buch_state_emptying_stack_out:
       ensures aorai_CurStates ≢ emptying_stack;
     
     behavior buch_state_filled_stack_out:
       ensures aorai_CurStates ≢ filled_stack;
     
     behavior buch_state_filling_stack_out:
       ensures aorai_CurStates ≢ filling_stack;
     
     behavior buch_state_init_out:
       ensures aorai_CurStates ≢ init;
   @/
  void main_post_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_main;
    if (2 == aorai_CurStates) aorai_CurStates = accept;
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ requires aorai_CurStates ≡ init;
    
    behavior Buchi_property_behavior:
      ensures aorai_CurStates ≡ accept;
      ensures
        \at(aorai_CurStates ≡ init,Pre) ∧ aorai_CurStates ≡ accept ⇒
        aorai_n ≡ \at(aorai_n - 1,Pre) + 0;
 */
void main(void)
{
  /*@ ghost main_pre_func(); */
  push();
  pop();
  push();
  push();
  pop();
  push();
  push();
  pop();
  pop();
  pop();
  /*@ ghost main_post_func(); */
  return;
}


