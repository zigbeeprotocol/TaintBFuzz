[kernel] Parsing singleassignment-right.i (no preprocessing)
[kernel] Parsing TMPDIR/aorai_singleassignment-right_0.i (no preprocessing)
/* Generated by Frama-C */
enum aorai_States {
    a = 0,
    aorai_reject = 1,
    b = 2,
    c = 3
};
enum aorai_ListOper {
    op_main = 0
};
enum aorai_OpStatusList {
    aorai_Terminated = 1,
    aorai_Called = 0
};
/*@ check lemma c_deterministic_trans{L}: \true;
 */
/*@ check lemma b_deterministic_trans{L}: \true;
 */
/*@ check lemma aorai_reject_deterministic_trans{L}: \true;
 */
/*@ check lemma a_deterministic_trans{L}: \true;
 */
/*@ ghost enum aorai_ListOper aorai_CurOperation; */
/*@ ghost enum aorai_OpStatusList aorai_CurOpStatus; */
/*@ ghost int aorai_CurStates = a; */
/*@ ghost int aorai_x = 0; */
/*@ ghost int aorai_y = 0; */
/*@ ghost
  /@ requires aorai_CurStates ≡ a;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_x, aorai_y, aorai_CurOpStatus, aorai_CurOperation,
             aorai_CurStates;
     
     behavior buch_state_a_out:
       ensures aorai_CurStates ≢ a;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_b_in_0:
       assumes aorai_CurStates ≡ a;
       ensures aorai_CurStates ≡ b;
       ensures aorai_x ≡ \old(*x);
       ensures aorai_y ≡ \old(*y);
     
     behavior buch_state_b_out:
       assumes aorai_CurStates ≢ a;
       ensures aorai_CurStates ≢ b;
     
     behavior buch_state_c_out:
       ensures aorai_CurStates ≢ c;
     
     behavior aorai_y_unchanged:
       assumes aorai_CurStates ≢ a;
       ensures aorai_y ≡ \old(aorai_y);
     
     behavior aorai_x_unchanged:
       assumes aorai_CurStates ≢ a;
       ensures aorai_x ≡ \old(aorai_x);
   @/
  void main_pre_func(int *x, int *y)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_main;
    if (0 == aorai_CurStates) {
      aorai_CurStates = b;
      aorai_x = *x;
      aorai_y = *y;
    }
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ ghost
  /@ requires aorai_CurStates ≡ b;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_x, aorai_y, aorai_CurOpStatus, aorai_CurOperation,
             aorai_CurStates;
     
     behavior buch_state_a_out:
       ensures aorai_CurStates ≢ a;
     
     behavior buch_state_aorai_reject_out:
       ensures aorai_CurStates ≢ aorai_reject;
     
     behavior buch_state_b_out:
       ensures aorai_CurStates ≢ b;
     
     behavior buch_state_c_in_0:
       assumes aorai_CurStates ≡ b;
       ensures aorai_CurStates ≡ c;
       ensures aorai_x ≡ \old(aorai_y);
       ensures aorai_y ≡ aorai_x;
     
     behavior buch_state_c_out:
       assumes aorai_CurStates ≢ b;
       ensures aorai_CurStates ≢ c;
     
     behavior aorai_y_unchanged_0:
       assumes aorai_CurStates ≢ b;
       ensures aorai_y ≡ \old(aorai_y);
     
     behavior aorai_x_unchanged_0:
       assumes aorai_CurStates ≢ b;
       ensures aorai_x ≡ \old(aorai_x);
   @/
  void main_post_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_main;
    if (2 == aorai_CurStates) {
      aorai_CurStates = c;
      aorai_x = aorai_y;
      aorai_y = aorai_x;
    }
    else aorai_CurStates = aorai_reject;
    return;
  }

*/

/*@ requires aorai_CurStates ≡ a;
    
    behavior Buchi_property_behavior:
      ensures aorai_CurStates ≡ c;
      ensures
        \at(aorai_CurStates ≡ a,Pre) ∧ aorai_CurStates ≡ c ⇒
        aorai_y ≡ \at(*x,Pre) + 0;
      ensures
        \at(aorai_CurStates ≡ a,Pre) ∧ aorai_CurStates ≡ c ⇒
        aorai_x ≡ \at(*y,Pre) + 0;
 */
void main(int *x, int *y)
{
  /*@ ghost main_pre_func(x,y); */
  int t = *x;
  *x = *y;
  *y = t;
  /*@ ghost main_post_func(); */
  return;
}


