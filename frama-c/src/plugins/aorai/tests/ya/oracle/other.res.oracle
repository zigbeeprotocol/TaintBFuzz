[kernel] Parsing other.c (with preprocessing)
[kernel] Parsing TMPDIR/aorai_other_0.i (no preprocessing)
/* Generated by Frama-C */
enum aorai_ListOper {
    op_f = 2,
    op_g = 1,
    op_main = 0
};
enum aorai_OpStatusList {
    aorai_Terminated = 1,
    aorai_Called = 0
};
int x = 0;
/*@ ghost enum aorai_ListOper aorai_CurOperation; */
/*@ ghost enum aorai_OpStatusList aorai_CurOpStatus; */
/*@ ghost int init = 1; */
/*@ ghost int last = 0; */
/*@ ghost int step1 = 0; */
/*@ ghost
  /@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
     requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_f;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes (0 ≡ last ∨ ¬(x ≡ 4)) ∧ (0 ≡ init ∨ ¬(x ≢ 3));
       ensures 0 ≡ init;
     
     behavior buch_state_last_in:
       assumes
         (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
       ensures 1 ≡ last;
     
     behavior buch_state_last_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≡ 4)) ∧
         (0 ≡ last ∨ ¬(x ≢ 4 ∧ x ≢ 3));
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes
         (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
         (1 ≡ init ∧ x ≡ 3);
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≢ 4)) ∧ (0 ≡ last ∨ ¬(x ≡ 3)) ∧
         (0 ≡ init ∨ ¬(x ≡ 3));
       ensures 0 ≡ step1;
   @/
  void f_pre_func(void)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_f;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) {
      if (x == 3) step1_tmp = 1; else goto __aorai_label_2;
    }
    else {
      __aorai_label_2: ;
      if (last == 1) {
        if (x == 3) step1_tmp = 1; else goto __aorai_label_1;
      }
      else {
        __aorai_label_1: ;
        if (step1 == 1) 
          if (x != 4) step1_tmp = 1; else step1_tmp = 0;
        else step1_tmp = 0;
      }
    }
    if (last == 1) {
      if (x != 4) {
        if (x != 3) last_tmp = 1; else goto __aorai_label_0;
      }
      else goto __aorai_label_0;
    }
    else {
      __aorai_label_0: ;
      if (step1 == 1) 
        if (x == 4) last_tmp = 1; else last_tmp = 0;
      else last_tmp = 0;
    }
    if (init == 1) {
      if (x != 3) init_tmp = 1; else goto __aorai_label;
    }
    else {
      __aorai_label: ;
      if (last == 1) 
        if (x == 4) init_tmp = 1; else init_tmp = 0;
      else init_tmp = 0;
    }
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ ghost
  /@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
     requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_f;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes (0 ≡ last ∨ ¬(x ≡ 4)) ∧ (0 ≡ init ∨ ¬(x ≢ 3));
       ensures 0 ≡ init;
     
     behavior buch_state_last_in:
       assumes
         (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
       ensures 1 ≡ last;
     
     behavior buch_state_last_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≡ 4)) ∧
         (0 ≡ last ∨ ¬(x ≢ 4 ∧ x ≢ 3));
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes
         (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
         (1 ≡ init ∧ x ≡ 3);
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≢ 4)) ∧ (0 ≡ last ∨ ¬(x ≡ 3)) ∧
         (0 ≡ init ∨ ¬(x ≡ 3));
       ensures 0 ≡ step1;
   @/
  void f_post_func(void)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_f;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) {
      if (x == 3) step1_tmp = 1; else goto __aorai_label_6;
    }
    else {
      __aorai_label_6: ;
      if (last == 1) {
        if (x == 3) step1_tmp = 1; else goto __aorai_label_5;
      }
      else {
        __aorai_label_5: ;
        if (step1 == 1) 
          if (x != 4) step1_tmp = 1; else step1_tmp = 0;
        else step1_tmp = 0;
      }
    }
    if (last == 1) {
      if (x != 4) {
        if (x != 3) last_tmp = 1; else goto __aorai_label_4;
      }
      else goto __aorai_label_4;
    }
    else {
      __aorai_label_4: ;
      if (step1 == 1) 
        if (x == 4) last_tmp = 1; else last_tmp = 0;
      else last_tmp = 0;
    }
    if (init == 1) {
      if (x != 3) init_tmp = 1; else goto __aorai_label_3;
    }
    else {
      __aorai_label_3: ;
      if (last == 1) 
        if (x == 4) init_tmp = 1; else init_tmp = 0;
      else init_tmp = 0;
    }
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
    requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
    requires 1 ≡ step1 ∨ 0 ≡ step1;
    requires 1 ≡ last ∨ 0 ≡ last;
    requires 1 ≡ init ∨ 0 ≡ init;
    
    behavior Buchi_behavior_in_0:
      assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ init ∨ 0 ≡ init;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ init ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_in_1:
      assumes
        (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ init ∨ 0 ≡ init;
      ensures 1 ≡ last ∨ 0 ≡ last;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_in_2:
      assumes
        (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
        (1 ≡ init ∧ x ≡ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ last ∨ 0 ≡ last;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ last ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_out_0:
      assumes
        (0 ≡ last ∨ (x ≡ 3 ∧ x ≢ 4)) ∧
        (0 ≡ step1 ∨ x ≢ 4) ∧ (0 ≡ init ∨ x ≡ 3);
      ensures 0 ≡ init;
    
    behavior Buchi_behavior_out_1:
      assumes
        0 ≡ step1 ∧ (0 ≡ init ∨ x ≢ 3) ∧
        (0 ≡ last ∨ (x ≢ 3 ∧ x ≡ 4));
      ensures 0 ≡ last;
    
    behavior Buchi_behavior_out_2:
      assumes 0 ≡ last ∧ 0 ≡ init ∧ 0 ≡ step1;
      ensures 0 ≡ step1;
 */
void f(void)
{
  /*@ ghost f_pre_func(); */
  x = 3;
  /*@ ghost f_post_func(); */
  return;
}

/*@ ghost
  /@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
     requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_g;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes (0 ≡ last ∨ ¬(x ≡ 4)) ∧ (0 ≡ init ∨ ¬(x ≢ 3));
       ensures 0 ≡ init;
     
     behavior buch_state_last_in:
       assumes
         (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
       ensures 1 ≡ last;
     
     behavior buch_state_last_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≡ 4)) ∧
         (0 ≡ last ∨ ¬(x ≢ 4 ∧ x ≢ 3));
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes
         (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
         (1 ≡ init ∧ x ≡ 3);
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≢ 4)) ∧ (0 ≡ last ∨ ¬(x ≡ 3)) ∧
         (0 ≡ init ∨ ¬(x ≡ 3));
       ensures 0 ≡ step1;
   @/
  void g_pre_func(void)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_g;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) {
      if (x == 3) step1_tmp = 1; else goto __aorai_label_10;
    }
    else {
      __aorai_label_10: ;
      if (last == 1) {
        if (x == 3) step1_tmp = 1; else goto __aorai_label_9;
      }
      else {
        __aorai_label_9: ;
        if (step1 == 1) 
          if (x != 4) step1_tmp = 1; else step1_tmp = 0;
        else step1_tmp = 0;
      }
    }
    if (last == 1) {
      if (x != 4) {
        if (x != 3) last_tmp = 1; else goto __aorai_label_8;
      }
      else goto __aorai_label_8;
    }
    else {
      __aorai_label_8: ;
      if (step1 == 1) 
        if (x == 4) last_tmp = 1; else last_tmp = 0;
      else last_tmp = 0;
    }
    if (init == 1) {
      if (x != 3) init_tmp = 1; else goto __aorai_label_7;
    }
    else {
      __aorai_label_7: ;
      if (last == 1) 
        if (x == 4) init_tmp = 1; else init_tmp = 0;
      else init_tmp = 0;
    }
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ ghost
  /@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
     requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_g;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes (0 ≡ last ∨ ¬(x ≡ 4)) ∧ (0 ≡ init ∨ ¬(x ≢ 3));
       ensures 0 ≡ init;
     
     behavior buch_state_last_in:
       assumes
         (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
       ensures 1 ≡ last;
     
     behavior buch_state_last_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≡ 4)) ∧
         (0 ≡ last ∨ ¬(x ≢ 4 ∧ x ≢ 3));
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes
         (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
         (1 ≡ init ∧ x ≡ 3);
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≢ 4)) ∧ (0 ≡ last ∨ ¬(x ≡ 3)) ∧
         (0 ≡ init ∨ ¬(x ≡ 3));
       ensures 0 ≡ step1;
   @/
  void g_post_func(void)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_g;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) {
      if (x == 3) step1_tmp = 1; else goto __aorai_label_14;
    }
    else {
      __aorai_label_14: ;
      if (last == 1) {
        if (x == 3) step1_tmp = 1; else goto __aorai_label_13;
      }
      else {
        __aorai_label_13: ;
        if (step1 == 1) 
          if (x != 4) step1_tmp = 1; else step1_tmp = 0;
        else step1_tmp = 0;
      }
    }
    if (last == 1) {
      if (x != 4) {
        if (x != 3) last_tmp = 1; else goto __aorai_label_12;
      }
      else goto __aorai_label_12;
    }
    else {
      __aorai_label_12: ;
      if (step1 == 1) 
        if (x == 4) last_tmp = 1; else last_tmp = 0;
      else last_tmp = 0;
    }
    if (init == 1) {
      if (x != 3) init_tmp = 1; else goto __aorai_label_11;
    }
    else {
      __aorai_label_11: ;
      if (last == 1) 
        if (x == 4) init_tmp = 1; else init_tmp = 0;
      else init_tmp = 0;
    }
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
    requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
    requires 1 ≡ step1 ∨ 0 ≡ step1;
    requires 1 ≡ last ∨ 0 ≡ last;
    requires 1 ≡ init ∨ 0 ≡ init;
    
    behavior Buchi_behavior_in_0:
      assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ init ∨ 0 ≡ init;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ init ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_in_1:
      assumes
        (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ init ∨ 0 ≡ init;
      ensures 1 ≡ last ∨ 0 ≡ last;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_in_2:
      assumes
        (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
        (1 ≡ init ∧ x ≡ 3);
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ last ∨ 0 ≡ last;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures 1 ≡ last ∨ 1 ≡ step1;
    
    behavior Buchi_behavior_out_0:
      assumes
        (0 ≡ last ∨ (x ≡ 3 ∧ x ≢ 4)) ∧
        (0 ≡ step1 ∨ x ≢ 4) ∧ (0 ≡ init ∨ x ≡ 3);
      ensures 0 ≡ init;
    
    behavior Buchi_behavior_out_1:
      assumes
        0 ≡ step1 ∧ (0 ≡ init ∨ x ≢ 3) ∧
        (0 ≡ last ∨ (x ≢ 3 ∧ x ≡ 4));
      ensures 0 ≡ last;
    
    behavior Buchi_behavior_out_2:
      assumes 0 ≡ last ∧ 0 ≡ init ∧ 0 ≡ step1;
      ensures 0 ≡ step1;
 */
void g(void)
{
  /*@ ghost g_pre_func(); */
  x = 4;
  /*@ ghost g_post_func(); */
  return;
}

/*@ ghost
  /@ requires 1 ≡ init ∧ 0 ≡ last ∧ 0 ≡ step1;
     ensures aorai_CurOpStatus ≡ aorai_Called;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes 1 ≡ init ∧ x ≢ 3;
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes 0 ≡ init ∨ ¬(x ≢ 3);
       ensures 0 ≡ init;
     
     behavior buch_state_last_out:
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes 1 ≡ init ∧ x ≡ 3;
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes 0 ≡ init ∨ ¬(x ≡ 3);
       ensures 0 ≡ step1;
   @/
  void main_pre_func(void)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_main;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) 
      if (x == 3) step1_tmp = 1; else step1_tmp = 0;
    else step1_tmp = 0;
    last_tmp = 0;
    if (init == 1) 
      if (x != 3) init_tmp = 1; else init_tmp = 0;
    else init_tmp = 0;
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ ghost
  /@ requires 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
     requires 1 ≡ last ⇒ x ≡ 3 ∨ (x ≢ 4 ∧ x ≢ 3) ∨ x ≡ 4;
     ensures aorai_CurOpStatus ≡ aorai_Terminated;
     ensures aorai_CurOperation ≡ op_main;
     assigns aorai_CurOpStatus, aorai_CurOperation, init, last, step1;
     
     behavior buch_state_init_in:
       assumes (1 ≡ last ∧ x ≡ 4) ∨ (1 ≡ init ∧ x ≢ 3);
       ensures 1 ≡ init;
     
     behavior buch_state_init_out:
       assumes (0 ≡ last ∨ ¬(x ≡ 4)) ∧ (0 ≡ init ∨ ¬(x ≢ 3));
       ensures 0 ≡ init;
     
     behavior buch_state_last_in:
       assumes
         (1 ≡ step1 ∧ x ≡ 4) ∨ (1 ≡ last ∧ x ≢ 4 ∧ x ≢ 3);
       ensures 1 ≡ last;
     
     behavior buch_state_last_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≡ 4)) ∧
         (0 ≡ last ∨ ¬(x ≢ 4 ∧ x ≢ 3));
       ensures 0 ≡ last;
     
     behavior buch_state_step1_in:
       assumes
         (1 ≡ step1 ∧ x ≢ 4) ∨ (1 ≡ last ∧ x ≡ 3) ∨
         (1 ≡ init ∧ x ≡ 3);
       ensures 1 ≡ step1;
     
     behavior buch_state_step1_out:
       assumes
         (0 ≡ step1 ∨ ¬(x ≢ 4)) ∧ (0 ≡ last ∨ ¬(x ≡ 3)) ∧
         (0 ≡ init ∨ ¬(x ≡ 3));
       ensures 0 ≡ step1;
   @/
  void main_post_func(int res)
  {
    int init_tmp;
    int last_tmp;
    int step1_tmp;
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_main;
    init_tmp = init;
    last_tmp = last;
    step1_tmp = step1;
    if (init == 1) {
      if (x == 3) step1_tmp = 1; else goto __aorai_label_18;
    }
    else {
      __aorai_label_18: ;
      if (last == 1) {
        if (x == 3) step1_tmp = 1; else goto __aorai_label_17;
      }
      else {
        __aorai_label_17: ;
        if (step1 == 1) 
          if (x != 4) step1_tmp = 1; else step1_tmp = 0;
        else step1_tmp = 0;
      }
    }
    if (last == 1) {
      if (x != 4) {
        if (x != 3) last_tmp = 1; else goto __aorai_label_16;
      }
      else goto __aorai_label_16;
    }
    else {
      __aorai_label_16: ;
      if (step1 == 1) 
        if (x == 4) last_tmp = 1; else last_tmp = 0;
      else last_tmp = 0;
    }
    if (init == 1) {
      if (x != 3) init_tmp = 1; else goto __aorai_label_15;
    }
    else {
      __aorai_label_15: ;
      if (last == 1) 
        if (x == 4) init_tmp = 1; else init_tmp = 0;
      else init_tmp = 0;
    }
    init = init_tmp;
    last = last_tmp;
    step1 = step1_tmp;
    return;
  }

*/

/*@ requires 1 ≡ init ∧ 0 ≡ last ∧ 0 ≡ step1;
    
    behavior aorai_acceptance:
      ensures 1 ≡ last;
    
    behavior Buchi_property_behavior:
      ensures
        (1 ≡ init ⇒ x ≡ 4 ∨ x ≢ 3) ∧
        (1 ≡ last ⇒ x ≡ 4 ∨ (x ≢ 4 ∧ x ≢ 3)) ∧
        (1 ≡ step1 ⇒ x ≢ 4 ∨ x ≡ 3);
      ensures 1 ≡ init ∨ 0 ≡ init;
      ensures 1 ≡ last ∨ 0 ≡ last;
      ensures 1 ≡ step1 ∨ 0 ≡ step1;
      ensures \true;
      ensures 1 ≡ init ∨ 1 ≡ last ∨ 1 ≡ step1;
 */
int main(void)
{
  /*@ ghost main_pre_func(); */
  f();
  g();
  f();
  g();
  /*@ ghost main_post_func(x); */
  return x;
}


