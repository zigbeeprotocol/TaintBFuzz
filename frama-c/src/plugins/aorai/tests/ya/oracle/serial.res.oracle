[kernel] Parsing serial.c (with preprocessing)
[kernel:annot:missing-spec] serial.c:56: Warning: 
  Neither code nor specification for function Frama_C_show_aorai_state, generating default assigns from the prototype
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  indefinitely ∈ [--..--]
  buffer[0..4] ∈ {0}
  n ∈ {0}
  aorai_x1 ∈ {0}
  aorai_x2 ∈ {0}
  aorai_y1 ∈ {0}
  aorai_y2 ∈ {0}
  aorai_CurOperation ∈ {0}
  aorai_CurOpStatus ∈ {0}
  aorai_CurStates ∈ {19}
  aorai_StatesHistory_1 ∈ {19}
  aorai_StatesHistory_2 ∈ {19}
[eva] using specification for function Frama_C_interval
[eva] serial.c:58: starting to merge loop iterations
[eva] serial.c:63: Trace partitioning superposing up to 100 states
[eva] serial.c:63: Trace partitioning superposing up to 300 states
[eva:alarm] serial.c:33: Warning: 
  assertion 'Aorai,aorai_smoke_test' got status invalid (stopping propagation).
[aorai] serial.c:92: Wait1 <- Wait1 <- Complete
[aorai] serial.c:92: n in {5},x in [0..16383],y in [8192..16383]
[aorai] serial.c:92: Wait1 <- Wait1 <- Complete
[aorai] serial.c:92: n in {5},x in [0..16383],y in [0..8191]
[eva] serial.c:63: Trace partitioning superposing up to 500 states
[eva] serial.c:63: Trace partitioning superposing up to 700 states
[eva] serial.c:63: Trace partitioning superposing up to 900 states
[eva] serial.c:63: Trace partitioning superposing up to 1200 states
[eva] serial.c:63: Trace partitioning superposing up to 1400 states
[eva] serial.c:63: Trace partitioning superposing up to 1500 states
[eva] serial.c:63: Trace partitioning superposing up to 1600 states
[eva] serial.c:63: Trace partitioning superposing up to 1700 states
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function input_data_post_func:
  aorai_x1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_x2 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y2 ∈ [0..2147483647]
  aorai_CurOperation ∈ {2}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {0; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {1; 2; 3; 4; 5; 6}
  aorai_StatesHistory_2 ∈ {8; 9; 10; 11; 12; 13}
[eva:final-states] Values at end of function input_data_pre_func:
  aorai_CurOperation ∈ {2}
  aorai_CurOpStatus ∈ {0}
  aorai_CurStates ∈ {1; 2; 3; 4; 5; 6}
  aorai_StatesHistory_1 ∈ {8; 9; 10; 11; 12; 13}
  aorai_StatesHistory_2 ∈ {14; 15; 16; 17; 18}
[eva:final-states] Values at end of function input_data:
  Frama_C_entropy_source ∈ [--..--]
  aorai_x1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_x2 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y2 ∈ [0..2147483647]
  aorai_CurOperation ∈ {2}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {0; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {1; 2; 3; 4; 5; 6}
  aorai_StatesHistory_2 ∈ {8; 9; 10; 11; 12; 13}
[eva:final-states] Values at end of function input_status_post_func:
  aorai_CurOperation ∈ {1}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {8; 9; 10; 11; 12; 13; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {14; 15; 16; 17; 18}
  aorai_StatesHistory_2 ∈ {0; 19; 20; 21; 22; 23}
[eva:final-states] Values at end of function input_status_pre_func:
  aorai_CurOperation ∈ {1}
  aorai_CurOpStatus ∈ {0}
  aorai_CurStates ∈ {14; 15; 16; 17; 18}
  aorai_StatesHistory_1 ∈ {0; 19; 20; 21; 22; 23}
  aorai_StatesHistory_2 ∈ {1; 2; 3; 4; 5; 6; 14; 15; 16; 17; 18; 19}
[eva:final-states] Values at end of function input_status:
  Frama_C_entropy_source ∈ [--..--]
  aorai_CurOperation ∈ {1}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {8; 9; 10; 11; 12; 13; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {14; 15; 16; 17; 18}
  aorai_StatesHistory_2 ∈ {0; 19; 20; 21; 22; 23}
[eva:final-states] Values at end of function output_post_func:
  aorai_CurOperation ∈ {0}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {19; 24}
  aorai_StatesHistory_1 ∈ {7; 19}
  aorai_StatesHistory_2 ∈ {0}
[eva:final-states] Values at end of function output_pre_func:
  aorai_CurOperation ∈ {0}
  aorai_CurOpStatus ∈ {0}
  aorai_CurStates ∈ {7; 19; 24}
  aorai_StatesHistory_1 ∈ {0}
  aorai_StatesHistory_2 ∈ {5}
[eva:final-states] Values at end of function output:
  aorai_CurOperation ∈ {0}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {19}
  aorai_StatesHistory_1 ∈ {19}
  aorai_StatesHistory_2 ∈ {0}
[eva:final-states] Values at end of function read:
  Frama_C_entropy_source ∈ [--..--]
  s ∈
   {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20;
    21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38;
    39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56;
    57; 58; 59; 60; 61; 62; 63; 64; 65; 66; 67; 68; 69; 70; 71; 72; 73; 74;
    75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85; 86; 87; 88; 89; 90; 91; 92;
    93; 94; 95; 96; 97; 98; 99; 100; 101; 102; 103; 104; 105; 106; 107; 108;
    109; 110; 111; 112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122;
    123; 124; 125; 126; 127; 128; 129; 130; 131; 132; 133; 134; 135; 136;
    137; 138; 139; 140; 141; 142; 143; 144; 145; 146; 147; 148; 149; 150;
    151; 152; 153; 154; 155; 156; 157; 158; 159; 160; 161; 162; 163; 164;
    165; 166; 167; 168; 169; 170; 171; 172; 173; 174; 175; 176; 177; 178;
    179; 180; 181; 182; 183; 184; 185; 186; 187; 188; 189; 190; 191; 192;
    193; 194; 195; 196; 197; 198; 199; 200; 201; 202; 203; 204; 205; 206;
    207; 208; 209; 210; 211; 212; 213; 214; 215; 216; 217; 218; 219; 220;
    221; 222; 223; 224; 225; 226; 227; 228; 229; 230; 231; 232; 233; 234;
    235; 236; 237; 238; 239; 240; 241; 242; 243; 244; 245; 246; 247; 248;
    249; 250; 251; 252; 253; 254; 255}
  status ∈ {0; 2; 4; 6; 8; 10; 12; 14} or UNINITIALIZED
  __retres ∈ [-1..255]
  aorai_x1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_x2 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y2 ∈ [0..2147483647]
  aorai_CurOperation ∈ {1; 2}
  aorai_CurOpStatus ∈ {1}
  aorai_CurStates ∈ {0; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {1; 2; 3; 4; 5; 6; 14; 15; 16; 17; 18}
  aorai_StatesHistory_2 ∈ {0; 8; 9; 10; 11; 12; 13; 19; 20; 21; 22; 23}
[eva:final-states] Values at end of function main:
  Frama_C_entropy_source ∈ [--..--]
  buffer[0] ∈
        {0; 128; 129; 130; 131; 132; 133; 134; 135; 136; 137; 138; 139; 140;
         141; 142; 143; 144; 145; 146; 147; 148; 149; 150; 151; 152; 153;
         154; 155; 156; 157; 158; 159; 160; 161; 162; 163; 164; 165; 166;
         167; 168; 169; 170; 171; 172; 173; 174; 175; 176; 177; 178; 179;
         180; 181; 182; 183; 184; 185; 186; 187; 188; 189; 190; 191; 192;
         193; 194; 195; 196; 197; 198; 199; 200; 201; 202; 203; 204; 205;
         206; 207; 208; 209; 210; 211; 212; 213; 214; 215; 216; 217; 218;
         219; 220; 221; 222; 223; 224; 225; 226; 227; 228; 229; 230; 231;
         232; 233; 234; 235; 236; 237; 238; 239; 240; 241; 242; 243; 244;
         245; 246; 247; 248; 249; 250; 251; 252; 253; 254; 255}
        [1..2] ∈
        {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
         19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35;
         36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52;
         53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66; 67; 68; 69;
         70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85; 86;
         87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98; 99; 100; 101; 102;
         103; 104; 105; 106; 107; 108; 109; 110; 111; 112; 113; 114; 115;
         116; 117; 118; 119; 120; 121; 122; 123; 124; 125; 126; 127}
        [3..4] ∈ [0..2147483647]
  n ∈ {0; 1; 2; 3; 4}
  aorai_x1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_x2 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y1 ∈
          {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18;
           19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34;
           35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50;
           51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66;
           67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82;
           83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98;
           99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
           112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124;
           125; 126; 127}
  aorai_y2 ∈ [0..2147483647]
  aorai_CurOperation ∈ {0; 1; 2}
  aorai_CurOpStatus ∈ {0; 1}
  aorai_CurStates ∈ {0; 19; 20; 21; 22; 23}
  aorai_StatesHistory_1 ∈ {1; 2; 3; 4; 5; 6; 14; 15; 16; 17; 18; 19}
  aorai_StatesHistory_2 ∈ {0; 8; 9; 10; 11; 12; 13; 19; 20; 21; 22; 23}
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  11 functions analyzed (out of 11): 100% coverage.
  In these functions, 273 statements reached (out of 339): 80% coverage.
  ----------------------------------------------------------------------------
  Some errors and warnings have been raised during the analysis:
    by the Eva analyzer:      0 errors    0 warnings
    by the Frama-C kernel:    0 errors    1 warning
  ----------------------------------------------------------------------------
  0 alarms generated by the analysis.
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        4 valid     2 unknown     0 invalid      6 total
    Preconditions     2 valid     0 unknown     0 invalid      2 total
  75% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[kernel] Parsing TMPDIR/aorai_serial_0.i (no preprocessing)
/* Generated by Frama-C */
typedef unsigned long size_t;
enum aorai_States {
    Complete = 0,
    DataReq1 = 1,
    DataReq2 = 2,
    DataReq3 = 3,
    DataReq4 = 4,
    DataReq5 = 5,
    DataReqE = 6,
    Error = 7,
    StatusError = 8,
    StatusOk1 = 9,
    StatusOk2 = 10,
    StatusOk3 = 11,
    StatusOk4 = 12,
    StatusOk5 = 13,
    StatusReq1 = 14,
    StatusReq2 = 15,
    StatusReq3 = 16,
    StatusReq4 = 17,
    StatusReq5 = 18,
    Wait1 = 19,
    Wait2 = 20,
    Wait3 = 21,
    Wait4 = 22,
    Wait5 = 23,
    aorai_reject = 24
};
enum aorai_ListOper {
    op_input_data = 2,
    op_input_status = 1,
    op_output = 0
};
enum aorai_OpStatusList {
    aorai_Terminated = 1,
    aorai_Called = 0
};
/* compiler builtin: 
   void Frama_C_show_aorai_state(...);   */
extern int volatile Frama_C_entropy_source __attribute__((__unused__));

/*@ requires valid_p: \valid(p + (0 .. l - 1));
    ensures initialization: \initialized(\old(p) + (0 .. \old(l) - 1));
    assigns *(p + (0 .. l - 1)), Frama_C_entropy_source;
    assigns *(p + (0 .. l - 1)) \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void Frama_C_make_unknown(char *p, size_t l);

/*@ ensures result_a_or_b: \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_nondet(int a, int b);

/*@ ensures result_a_or_b: \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void *Frama_C_nondet_ptr(void *a, void *b);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval(int min, int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval_split(int min, int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                                    unsigned char max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern char Frama_C_char_interval(char min, char max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned short Frama_C_unsigned_short_interval(unsigned short min,
                                                      unsigned short max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern short Frama_C_short_interval(short min, short max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned int Frama_C_unsigned_int_interval(unsigned int min,
                                                  unsigned int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_int_interval(int min, int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                                    unsigned long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long Frama_C_long_interval(long min, long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long long Frama_C_unsigned_long_long_interval(unsigned long long min,
                                                              unsigned long long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long long Frama_C_long_long_interval(long long min, long long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern size_t Frama_C_size_t_interval(size_t min, size_t max);

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern float Frama_C_float_interval(float min, float max);

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern double Frama_C_double_interval(double min, double max);

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern double Frama_C_real_interval_as_double(double min, double max);

/*@ terminates \false;
    ensures never_terminates: \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void Frama_C_abort(void);

/*@ assigns \result;
    assigns \result \from p; */
extern size_t Frama_C_offset(void const *p);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_cardinal(long long i);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_max(long long i);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_min(long long i);

int volatile indefinitely;
int buffer[5];
int n = 0;
/*@ ghost enum aorai_ListOper aorai_CurOperation; */
/*@ ghost enum aorai_OpStatusList aorai_CurOpStatus; */
/*@ ghost int aorai_CurStates = Wait1; */
/*@ ghost int aorai_StatesHistory_1 = Wait1; */
/*@ ghost int aorai_StatesHistory_2 = Wait1; */
/*@ ghost int aorai_x1 = 0; */
/*@ ghost int aorai_x2 = 0; */
/*@ ghost int aorai_y1 = 0; */
/*@ ghost int aorai_y2 = 0; */
/*@ ghost
  void input_status_pre_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_input_status;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (19 == aorai_CurStates) aorai_CurStates = StatusReq1;
    else 
      if (9 == aorai_CurStates) aorai_CurStates = StatusReq1;
      else 
        if (8 == aorai_CurStates) aorai_CurStates = StatusReq1;
        else 
          if (0 == aorai_CurStates) aorai_CurStates = StatusReq1;
          else 
            if (20 == aorai_CurStates) aorai_CurStates = StatusReq2;
            else 
              if (10 == aorai_CurStates) aorai_CurStates = StatusReq2;
              else 
                if (21 == aorai_CurStates) aorai_CurStates = StatusReq3;
                else 
                  if (11 == aorai_CurStates) aorai_CurStates = StatusReq3;
                  else 
                    if (22 == aorai_CurStates) aorai_CurStates = StatusReq4;
                    else 
                      if (12 == aorai_CurStates) aorai_CurStates = StatusReq4;
                      else 
                        if (23 == aorai_CurStates) aorai_CurStates = StatusReq5;
                        else 
                          if (13 == aorai_CurStates) aorai_CurStates = StatusReq5;
                          else aorai_CurStates = aorai_reject;
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ ghost
  void input_status_post_func(int res)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_input_status;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (18 == aorai_CurStates) {
      if ((res & 15) != 1) {
        if ((res & 1) != 0) aorai_CurStates = StatusError;
        else goto __aorai_label_12;
      }
      else goto __aorai_label_12;
    }
    else {
      __aorai_label_12: ;
      if (17 == aorai_CurStates) {
        if ((res & 15) != 1) {
          if ((res & 1) != 0) aorai_CurStates = StatusError;
          else goto __aorai_label_11;
        }
        else goto __aorai_label_11;
      }
      else {
        __aorai_label_11: ;
        if (16 == aorai_CurStates) {
          if ((res & 15) != 1) {
            if ((res & 1) != 0) aorai_CurStates = StatusError;
            else goto __aorai_label_10;
          }
          else goto __aorai_label_10;
        }
        else {
          __aorai_label_10: ;
          if (15 == aorai_CurStates) {
            if ((res & 15) != 1) {
              if ((res & 1) != 0) aorai_CurStates = StatusError;
              else goto __aorai_label_9;
            }
            else goto __aorai_label_9;
          }
          else {
            __aorai_label_9: ;
            if (14 == aorai_CurStates) {
              if ((res & 15) != 1) {
                if ((res & 1) != 0) aorai_CurStates = StatusError;
                else goto __aorai_label_8;
              }
              else goto __aorai_label_8;
            }
            else {
              __aorai_label_8: ;
              if (14 == aorai_CurStates) {
                if ((res & 15) == 1) aorai_CurStates = StatusOk1;
                else goto __aorai_label_7;
              }
              else {
                __aorai_label_7: ;
                if (15 == aorai_CurStates) {
                  if ((res & 15) == 1) aorai_CurStates = StatusOk2;
                  else goto __aorai_label_6;
                }
                else {
                  __aorai_label_6: ;
                  if (16 == aorai_CurStates) {
                    if ((res & 15) == 1) aorai_CurStates = StatusOk3;
                    else goto __aorai_label_5;
                  }
                  else {
                    __aorai_label_5: ;
                    if (17 == aorai_CurStates) {
                      if ((res & 15) == 1) aorai_CurStates = StatusOk4;
                      else goto __aorai_label_4;
                    }
                    else {
                      __aorai_label_4: ;
                      if (18 == aorai_CurStates) {
                        if ((res & 15) == 1) aorai_CurStates = StatusOk5;
                        else goto __aorai_label_3;
                      }
                      else {
                        __aorai_label_3: ;
                        if (14 == aorai_CurStates) {
                          if ((res & 1) == 0) aorai_CurStates = Wait1;
                          else goto __aorai_label_2;
                        }
                        else {
                          __aorai_label_2: ;
                          if (15 == aorai_CurStates) {
                            if ((res & 1) == 0) aorai_CurStates = Wait2;
                            else goto __aorai_label_1;
                          }
                          else {
                            __aorai_label_1: ;
                            if (16 == aorai_CurStates) {
                              if ((res & 1) == 0) aorai_CurStates = Wait3;
                              else goto __aorai_label_0;
                            }
                            else {
                              __aorai_label_0: ;
                              if (17 == aorai_CurStates) {
                                if ((res & 1) == 0) aorai_CurStates = Wait4;
                                else goto __aorai_label;
                              }
                              else {
                                __aorai_label: ;
                                if (18 == aorai_CurStates) 
                                  if ((res & 1) == 0) aorai_CurStates = Wait5;
                                  else aorai_CurStates = aorai_reject;
                                else aorai_CurStates = aorai_reject;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ ensures 0 ≤ \result < 0x100;
    assigns \result, Frama_C_entropy_source;
    assigns \result \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int input_status(void)
{
  int tmp;
  /*@ ghost input_status_pre_func(); */
  tmp = Frama_C_interval(0x00,0xff);
  /*@ ghost input_status_post_func(tmp); */
  return tmp;
}

/*@ ghost
  void input_data_pre_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_input_data;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (9 == aorai_CurStates) aorai_CurStates = DataReq1;
    else 
      if (10 == aorai_CurStates) aorai_CurStates = DataReq2;
      else 
        if (11 == aorai_CurStates) aorai_CurStates = DataReq3;
        else 
          if (12 == aorai_CurStates) aorai_CurStates = DataReq4;
          else 
            if (13 == aorai_CurStates) aorai_CurStates = DataReq5;
            else 
              if (8 == aorai_CurStates) aorai_CurStates = DataReqE;
              else 
                if (23 == aorai_CurStates) aorai_CurStates = Error;
                else 
                  if (22 == aorai_CurStates) aorai_CurStates = Error;
                  else 
                    if (21 == aorai_CurStates) aorai_CurStates = Error;
                    else 
                      if (20 == aorai_CurStates) aorai_CurStates = Error;
                      else 
                        if (19 == aorai_CurStates) aorai_CurStates = Error;
                        else aorai_CurStates = aorai_reject;
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ ghost
  void input_data_post_func(int res)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_input_data;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (5 == aorai_CurStates) {
      if ((res & 128) == 0) {
        aorai_CurStates = Complete;
        aorai_y2 = res;
      }
      else goto __aorai_label_26;
    }
    else 
      __aorai_label_26:
      if (6 == aorai_CurStates) aorai_CurStates = Wait1;
      else 
        if (5 == aorai_CurStates) {
          if ((res & 192) == 192) aorai_CurStates = Wait1;
          else goto __aorai_label_25;
        }
        else {
          __aorai_label_25: ;
          if (4 == aorai_CurStates) {
            if ((res & 192) == 192) aorai_CurStates = Wait1;
            else goto __aorai_label_24;
          }
          else {
            __aorai_label_24: ;
            if (3 == aorai_CurStates) {
              if ((res & 192) == 192) aorai_CurStates = Wait1;
              else goto __aorai_label_23;
            }
            else {
              __aorai_label_23: ;
              if (2 == aorai_CurStates) {
                if ((res & 192) == 192) aorai_CurStates = Wait1;
                else goto __aorai_label_22;
              }
              else {
                __aorai_label_22: ;
                if (1 == aorai_CurStates) {
                  if ((res & 128) == 0) aorai_CurStates = Wait1;
                  else goto __aorai_label_21;
                }
                else {
                  __aorai_label_21: ;
                  if (1 == aorai_CurStates) {
                    if ((res & 192) == 192) aorai_CurStates = Wait1;
                    else goto __aorai_label_20;
                  }
                  else {
                    __aorai_label_20: ;
                    if (5 == aorai_CurStates) {
                      if ((res & 192) == 128) aorai_CurStates = Wait2;
                      else goto __aorai_label_19;
                    }
                    else {
                      __aorai_label_19: ;
                      if (4 == aorai_CurStates) {
                        if ((res & 192) == 128) aorai_CurStates = Wait2;
                        else goto __aorai_label_18;
                      }
                      else {
                        __aorai_label_18: ;
                        if (3 == aorai_CurStates) {
                          if ((res & 192) == 128) aorai_CurStates = Wait2;
                          else goto __aorai_label_17;
                        }
                        else {
                          __aorai_label_17: ;
                          if (2 == aorai_CurStates) {
                            if ((res & 192) == 128) aorai_CurStates = Wait2;
                            else goto __aorai_label_16;
                          }
                          else {
                            __aorai_label_16: ;
                            if (1 == aorai_CurStates) {
                              if ((res & 192) == 128) aorai_CurStates = Wait2;
                              else goto __aorai_label_15;
                            }
                            else {
                              __aorai_label_15: ;
                              if (2 == aorai_CurStates) {
                                if ((res & 128) == 0) {
                                  aorai_CurStates = Wait3;
                                  aorai_x1 = res;
                                }
                                else goto __aorai_label_14;
                              }
                              else {
                                __aorai_label_14: ;
                                if (3 == aorai_CurStates) {
                                  if ((res & 128) == 0) {
                                    aorai_CurStates = Wait4;
                                    aorai_x2 = res;
                                  }
                                  else goto __aorai_label_13;
                                }
                                else {
                                  __aorai_label_13: ;
                                  if (4 == aorai_CurStates) 
                                    if ((res & 128) == 0) {
                                      aorai_CurStates = Wait5;
                                      aorai_y1 = res;
                                    }
                                    else aorai_CurStates = aorai_reject;
                                  else aorai_CurStates = aorai_reject;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ ensures 0 ≤ \result < 0x100;
    assigns \result, Frama_C_entropy_source;
    assigns \result \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int input_data(void)
{
  int tmp;
  /*@ ghost input_data_pre_func(); */
  tmp = Frama_C_interval(0x00,0xff);
  /*@ ghost input_data_post_func(tmp); */
  return tmp;
}

/*@ ghost
  void output_pre_func(int x, int y)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Called;
    aorai_CurOperation = op_output;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (23 == aorai_CurStates) aorai_CurStates = Error;
    else 
      if (22 == aorai_CurStates) aorai_CurStates = Error;
      else 
        if (21 == aorai_CurStates) aorai_CurStates = Error;
        else 
          if (20 == aorai_CurStates) aorai_CurStates = Error;
          else 
            if (19 == aorai_CurStates) aorai_CurStates = Error;
            else 
              if (13 == aorai_CurStates) aorai_CurStates = Error;
              else 
                if (12 == aorai_CurStates) aorai_CurStates = Error;
                else 
                  if (11 == aorai_CurStates) aorai_CurStates = Error;
                  else 
                    if (10 == aorai_CurStates) aorai_CurStates = Error;
                    else 
                      if (9 == aorai_CurStates) aorai_CurStates = Error;
                      else 
                        if (8 == aorai_CurStates) aorai_CurStates = Error;
                        else 
                          if (0 == aorai_CurStates) {
                            if (y != aorai_y1 + 128 * aorai_y2) aorai_CurStates = Error;
                            else 
                              if (x != aorai_x1 + 128 * aorai_x2) aorai_CurStates = Error;
                              else goto __aorai_label_27;
                          }
                          else {
                            __aorai_label_27: ;
                            if (0 == aorai_CurStates) 
                              if (x == aorai_x1 + 128 * aorai_x2) 
                                if (y == aorai_y1 + 128 * aorai_y2) aorai_CurStates = Wait1;
                                else aorai_CurStates = aorai_reject;
                              else aorai_CurStates = aorai_reject;
                            else aorai_CurStates = aorai_reject;
                          }
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ ghost
  void output_post_func(void)
  {
    /@ slevel full; @/
    aorai_CurOpStatus = aorai_Terminated;
    aorai_CurOperation = op_output;
    aorai_StatesHistory_2 = aorai_StatesHistory_1;
    aorai_StatesHistory_1 = aorai_CurStates;
    if (19 == aorai_CurStates) aorai_CurStates = Wait1;
    else aorai_CurStates = aorai_reject;
    /@ assert Aorai: aorai_smoke_test: aorai_CurStates ≢ aorai_reject; @/
    ;
    return;
  }

*/

/*@ assigns \nothing; */
void output(int x, int y)
{
  /*@ ghost output_pre_func(x,y); */
  /*@ ghost output_post_func(); */
  return;
}

int read(int *status)
{
  int __retres;
  int s = input_status();
  if (s & 0x01) {
    int tmp_0;
    *status = s & 0x0e;
    tmp_0 = input_data();
    __retres = tmp_0;
    goto return_label;
  }
  __retres = -1;
  return_label: ;
  return __retres;
}

void main(void)
{
  /*@ ghost int aorai_Loop_Init_18; */
  while (indefinitely) {
    int status;
    int data = read(& status);
    if (data != -1) {
      int tmp_0;
      if (status != 0) {
        n = 0;
        continue;
      }
      if (data & 0x80) {
        if (n != 0) {
          n = 0;
          continue;
        }
      }
      else {
        /*@ split data & 0x40; */ ;
        if (n == 0) continue;
      }
      tmp_0 = n;
      n ++;
      buffer[tmp_0] = data;
      if (n == 5) {
        if ((buffer[0] & 0x40) == 0) {
          int x = buffer[1] + 0x80 * buffer[2];
          int y = buffer[3] + 0x80 * buffer[4];
          output(x,y);
          Frama_C_show_aorai_state(n,x,y);
        }
        n = 0;
      }
    }
  }
  return;
}


