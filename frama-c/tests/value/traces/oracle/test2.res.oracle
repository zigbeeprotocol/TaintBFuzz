[kernel] Parsing test2.i (no preprocessing)
[eva:experimental] Warning: The traces domain is experimental.
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  
[eva] computing for function loop <- main.
  Called from test2.i:18.
[eva] Recording results for loop
[eva] Done for function loop
[eva] computing for function loop <- main.
  Called from test2.i:18.
[eva] Recording results for loop
[eva] Done for function loop
[eva] Recording results for main
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function loop:
  j ∈ {4; 5}
[eva:final-states] Values at end of function main:
  tmp ∈ {4; 5}
[eva:d-traces] Trace domains:
 start: 0; globals = ; main_formals = c;
 {[ 0 -> initialize formal variable using type
c -> 1
    1 -> EnterScope: tmp -> 2
    2 -> Assign: tmp = 0 -> 3
    3 -> Assume: c true -> 4; Assume: c false -> 6
    4 -> Assign: tmp = 1 -> 5
    5 -> start_call: loop (true) -> 8
    6 -> Assign: tmp = 2 -> 7
    7 -> start_call: loop (true) -> 39
    8 -> EnterScope: j -> 9
    9 -> Assign: j = tmp -> 10
    10 -> EnterScope: i -> 11
    11 -> initialize variable: i -> 12
    12 -> Assign: i = 0 -> 13
    13 -> enter_loop -> 14
    14 -> Assume: i < 3 true -> 15
    15 -> Assign: j = j + 1 -> 16
    16 -> Assign: i = i + 1 -> 17
    17 -> Assume: i < 3 true -> 18
    18 -> Assign: j = j + 1 -> 19
    19 -> Assign: i = i + 1 -> 20
    20 -> Assume: i < 3 true -> 21
    21 -> Assign: j = j + 1 -> 22
    22 -> Assign: i = i + 1 -> 23
    23 -> Assume: i < 3 false -> 24
    24 -> LeaveScope: i -> 25
    25 -> EnterScope: \result<loop> -> 26
    26 -> Assign: \result<loop> = j -> 27
    27 -> LeaveScope: j -> 35
    35 -> finalize_call: loop -> 36
    36 -> Assign: tmp = \result<loop> -> 37
    37 -> LeaveScope: \result<loop> -> 38
    38 -> EnterScope: \result<main> -> 78
    39 -> EnterScope: j -> 40
    40 -> Assign: j = tmp -> 41
    41 -> EnterScope: i -> 43
    43 -> initialize variable: i -> 44
    44 -> Assign: i = 0 -> 45
    45 -> enter_loop -> 46
    46 -> Assume: i < 3 true -> 47
    47 -> Assign: j = j + 1 -> 48
    48 -> Assign: i = i + 1 -> 49
    49 -> Assume: i < 3 true -> 50
    50 -> Assign: j = j + 1 -> 51
    51 -> Assign: i = i + 1 -> 52
    52 -> Assume: i < 3 true -> 53
    53 -> Assign: j = j + 1 -> 54
    54 -> Assign: i = i + 1 -> 55
    55 -> Assume: i < 3 false -> 56
    56 -> LeaveScope: i -> 57
    57 -> EnterScope: \result<loop> -> 58
    58 -> Assign: \result<loop> = j -> 59
    59 -> LeaveScope: j -> 74
    74 -> finalize_call: loop -> 75
    75 -> Assign: tmp = \result<loop> -> 76
    76 -> LeaveScope: \result<loop> -> 77
    77 -> EnterScope: \result<main> -> 80
    78 -> Assign: \result<main> = tmp -> 79
    79 -> join -> 82
    80 -> Assign: \result<main> = tmp -> 81
    81 -> join -> 82 ]} at 82
[from] Computing for function loop
[from] Done for function loop
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function loop:
  \result FROM j
[from] Function main:
  \result FROM c
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function loop:
    j; i
[inout] Inputs for function loop:
    \nothing
[inout] Out (internal) for function main:
    tmp
[inout] Inputs for function main:
    \nothing
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  __traces_domain_return ∈ {4; 5}
/* Generated by Frama-C */
int main(int c)
{
  int __traces_domain_return;
  {
    int tmp;
    tmp = 0;
    if (c) {
      tmp = 1;
      {
        int j;
        j = tmp;
        {
          int i;
          i = 0;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert ¬(i < 3);  */
          {
            int _result_loop_;
            _result_loop_ = j;
            tmp = _result_loop_;
            {
              int _result_main_;
              _result_main_ = tmp;
              __traces_domain_return = tmp;
            }
          }
        }
      }
    }
    else {
      tmp = 2;
      {
        int j;
        j = tmp;
        {
          int i;
          i = 0;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert ¬(i < 3);  */
          {
            int _result_loop_;
            _result_loop_ = j;
            tmp = _result_loop_;
            {
              int _result_main_;
              _result_main_ = tmp;
              __traces_domain_return = tmp;
            }
          }
        }
      }
    }
  }
  return __traces_domain_return;
}


