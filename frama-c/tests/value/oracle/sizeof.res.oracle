[kernel] Parsing sizeof.i (no preprocessing)
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  sz_str ∈ {0}
  sz_typ ∈ {0}
  align_str ∈ {0}
  align_typ ∈ {0}
  s1 ∈ {0}
  i ∈ [--..--]
[eva] computing for function main1 <- main.
  Called from sizeof.i:51.
[eva] sizeof.i:10: assertion got status valid.
[eva] sizeof.i:14: assertion got status valid.
[eva] sizeof.i:17: assertion got status valid.
[eva] Recording results for main1
[eva] Done for function main1
[eva] computing for function main2 <- main.
  Called from sizeof.i:52.
[eva:alarm] sizeof.i:32: Warning: 
  pointer downcast. assert (unsigned int)(&s1) ≤ 2147483647;
[eva] sizeof.i:32: 
  Assigning imprecise value to p.
  The imprecision originates from Arithmetic {sizeof.i:32}
[eva:alarm] sizeof.i:33: Warning: 
  accessing out of bounds index.
  assert (unsigned int)(sizeof(int [10]) - (unsigned int)i) < 10;
[eva:alarm] sizeof.i:33: Warning: 
  out of bounds write.
  assert \valid(&p->t[(unsigned int)(sizeof(int [10]) - (unsigned int)i)]);
[eva:alarm] sizeof.i:34: Warning: 
  accessing out of bounds index.
  assert (unsigned int)(sizeof(int [10]) - (unsigned int)i) < 10;
[eva:alarm] sizeof.i:34: Warning: 
  out of bounds write.
  assert \valid(&p->t[(unsigned int)(sizeof(int [10]) - (unsigned int)i)]);
[eva] Recording results for main2
[eva] Done for function main2
[eva] computing for function sizeof_void <- main.
  Called from sizeof.i:53.
[eva] Recording results for sizeof_void
[eva] Done for function sizeof_void
[eva] computing for function f <- main.
  Called from sizeof.i:54.
[eva] Recording results for f
[eva] Done for function f
[eva] Recording results for main
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function f:
  
[eva:final-states] Values at end of function main1:
  sz_str ∈ {4}
  sz_typ ∈ {1}
  align_str ∈ {1}
  align_typ ∈ {4}
[eva:final-states] Values at end of function main2:
  s1 ∈ [--..--]
  p ∈ {{ &s1 + [-36..36] }}
[eva:final-states] Values at end of function sizeof_void:
  size_void ∈ {1}
  size_ptr ∈ {4}
  size_void_expr ∈ {1}
  align_void ∈ {1}
  align_ptr ∈ {4}
  align_void_expr ∈ {1}
[eva:final-states] Values at end of function main:
  sz_str ∈ {4}
  sz_typ ∈ {1}
  align_str ∈ {1}
  align_typ ∈ {4}
  s1 ∈ [--..--]
[from] Computing for function f
[from] Done for function f
[from] Computing for function main1
[from] Done for function main1
[from] Computing for function main2
[from] Done for function main2
[from] Computing for function sizeof_void
[from] Done for function sizeof_void
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function f:
  NO EFFECTS
[from] Function main1:
  sz_str FROM \nothing
  sz_typ FROM \nothing
  align_str FROM \nothing
  align_typ FROM \nothing
[from] Function main2:
  s1 FROM i (and SELF)
[from] Function sizeof_void:
  NO EFFECTS
[from] Function main:
  sz_str FROM \nothing
  sz_typ FROM \nothing
  align_str FROM \nothing
  align_typ FROM \nothing
  s1 FROM i (and SELF)
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function f:
    \nothing
[inout] Inputs for function f:
    \nothing
[inout] Out (internal) for function main1:
    sz_str; sz_typ; align_str; align_typ
[inout] Inputs for function main1:
    \nothing
[inout] Out (internal) for function main2:
    s1; p
[inout] Inputs for function main2:
    i
[inout] Out (internal) for function sizeof_void:
    size_void; size_ptr; size_void_expr; align_void; align_ptr; align_void_expr
[inout] Inputs for function sizeof_void:
    \nothing
[inout] Out (internal) for function main:
    sz_str; sz_typ; align_str; align_typ; s1
[inout] Inputs for function main:
    i
/* Generated by Frama-C */
struct s {
   int t[10] ;
};
int sz_str;
int sz_typ;
int align_str;
int align_typ;
void main1(void)
{
  sz_str = (int)sizeof("ONE");
  /*@ assert sz_str ≡ sizeof("ONE"); */ ;
  align_str = (int)__alignof__("FOO");
  sz_typ = (int)sizeof(char);
  /*@ assert sz_typ ≡ sizeof(char); */ ;
  align_typ = (int)__alignof__(char *);
  /*@ assert sizeof("BLA") ≢ sizeof("FOOBAR"); */ ;
  return;
}

struct s s1;
int volatile i;
void main2(void)
{
  /*@ assert Eva: pointer_downcast: (unsigned int)(&s1) ≤ 2147483647; */
  struct s *p = (& s1 + (int)(& s1)) - (int)(& s1);
  /*@ assert
      Eva: index_bound:
        (unsigned int)(sizeof(int [10]) - (unsigned int)i) < 10;
  */
  /*@ assert
      Eva: mem_access:
        \valid(&p->t[(unsigned int)(sizeof(int [10]) - (unsigned int)i)]);
  */
  p->t[sizeof(s1.t) - (unsigned int)i] = 1;
  /*@ assert
      Eva: index_bound:
        (unsigned int)(sizeof(int [10]) - (unsigned int)i) < 10;
  */
  /*@ assert
      Eva: mem_access:
        \valid(&p->t[(unsigned int)(sizeof(int [10]) - (unsigned int)i)]);
  */
  p->t[sizeof(s1.t) - (unsigned int)i] = 2;
  return;
}

void sizeof_void(void)
{
  void *p;
  int size_void = (int)sizeof(void);
  int size_ptr = (int)sizeof(p);
  int size_void_expr = (int)sizeof(*p);
  int align_void = (int)__alignof__(void);
  int align_ptr = (int)__alignof__(p);
  int align_void_expr = (int)__alignof__(*p);
  return;
}

void f(int sz)
{
  return;
}

void main(int *p, int *q, int j)
{
  main1();
  main2();
  sizeof_void();
  f((int)(sizeof(*p) * (unsigned int)j));
  return;
}


