[kernel] Parsing at.c (with preprocessing)
[kernel:annot-error] at.c:40: Warning: 
  unbound logic variable y. Ignoring code annotation
[kernel:annot-error] at.c:41: Warning: 
  unbound logic variable y. Ignoring code annotation
[kernel:annot-error] at.c:42: Warning: 
  unbound logic variable z. Ignoring code annotation
[kernel:annot-error] at.c:49: Warning: 
  unbound logic variable i. Ignoring code annotation
/* Generated by Frama-C */
int x;
/*@
axiomatic A {
  predicate E{L}(ℤ v) = \at(x ≡ v,L);
  
  predicate P{L1, L2}(ℤ i) = \at(x,L1) ≡ \at(x,L2) + i;
  
  predicate Q{L1, L2}(ℤ i) = \at(x ≡ \at(x,L2) + i,L1);
  
  axiom idem{L1, L2}: ∀ ℤ i; P{L1, L2}(i) ⇔ Q{L1, L2}(i);
  
  }
 */
/*@ ensures x ≡ (2 + \old(x)) + \old(y);
    ensures \at(E(\at((x - 2) - y,Here)),Pre);
 */
int f(int y)
{
  x += y;
  L1: x ++;
  /*@ ghost L2: ; */
  x ++;
  /*@ assert \at(x,L1) ≡ \at(x,Pre) + y; */ ;
  /*@ assert \at(x,L2) ≡ (1 + \at(x,Pre)) + y; */ ;
  /*@ assert P{Here, Pre}(2 + y); */ ;
  return x;
}

void test(void)
{
  int x_0 = 0;
  L1:
  {
    int x_1 = 1;
    L2: /*@ assert \at(&x_0,L1) ≢ \at(&x_1,L2); */ ;
    x_1 = 2;
  }
  return;
}

void ko(int z)
{
  L:
  {
    int y = 0;
    /*@ assert OK: \at(x,Init) ≡ 0; */ ;
    /*@ assert OK: \at(z,Pre) ≡ 0; */ ;
  }
  while (x > 0) {
    int i = 1;
    x --;
    /*@ assert OK: \at(z,LoopCurrent) ≡ \at(z,Pre); */ ;
  }
  return;
}


