[kernel] Parsing fc_libc.c (with preprocessing)
/* Generated by Frama-C */
typedef unsigned int size_t;
typedef int wchar_t;
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef int ptrdiff_t;
typedef int ssize_t;
typedef int error_t;
struct __fc_fenv_t {
   unsigned short __control_word ;
   unsigned short __unused1 ;
   unsigned short __status_word ;
   unsigned short __unused2 ;
   unsigned short __tags ;
   unsigned short __unused3 ;
   unsigned int __eip ;
   unsigned short __cs_selector ;
   unsigned int __opcode : 11 ;
   unsigned int __unused4 : 5 ;
   unsigned int __data_offset ;
   unsigned short __data_selector ;
   unsigned short __unused5 ;
};
typedef struct __fc_fenv_t fenv_t;
typedef unsigned int gid_t;
typedef unsigned int uid_t;
typedef long off_t;
typedef int pid_t;
typedef unsigned int useconds_t;
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct __fc_glob_t {
   unsigned int gl_pathc ;
   char **gl_pathv ;
   unsigned int gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void *) ;
   void *(*gl_readdir)(void *) ;
   void *(*gl_opendir)(char const *) ;
   int (*gl_lstat)(char const * restrict , void * restrict ) ;
   int (*gl_stat)(char const * restrict , void * restrict ) ;
};
typedef struct __fc_glob_t glob_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned int uintptr_t;
typedef long long intmax_t;
struct __fc_imaxdiv_t {
   intmax_t quot ;
   intmax_t rem ;
};
typedef struct __fc_imaxdiv_t imaxdiv_t;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
union __fc_u_finitef {
   float f ;
   unsigned short w[2] ;
};
union __fc_u_finite {
   double d ;
   unsigned short w[4] ;
};
struct __fc_pthread_attr_t {
   int _fc ;
};
typedef struct __fc_pthread_attr_t pthread_attr_t;
struct __fc_pthread_cond_t {
   int _fc ;
};
typedef struct __fc_pthread_cond_t pthread_cond_t;
struct __fc_pthread_condattr_t {
   int _fc ;
};
typedef struct __fc_pthread_condattr_t pthread_condattr_t;
struct __fc_pthread_mutex_t {
   int _fc ;
};
typedef struct __fc_pthread_mutex_t pthread_mutex_t;
struct __fc_pthread_mutexattr_t {
   int _fc ;
};
typedef struct __fc_pthread_mutexattr_t pthread_mutexattr_t;
struct __fc_pthread_t {
   int _fc ;
};
typedef struct __fc_pthread_t pthread_t;
typedef unsigned long sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
struct __fc_siginfo_t {
   int si_signo ;
   int si_code ;
   union sigval si_value ;
   int si_errno ;
   pid_t si_pid ;
   uid_t si_uid ;
   void *si_addr ;
   int si_status ;
   int si_band ;
};
typedef struct __fc_siginfo_t siginfo_t;
struct sigaction {
   void (*sa_handler)(int ) ;
   void (*sa_sigaction)(int , siginfo_t *, void *) ;
   sigset_t sa_mask ;
   int sa_flags ;
};
typedef unsigned int socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   int msg_iovlen ;
   void *msg_control ;
   socklen_t msg_controllen ;
   int msg_flags ;
};
struct __fc_sockfds_type {
   int x ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct in6_addr {
   uint8_t s6_addr[16] ;
};
enum __fc_ipproto {
    IPPROTO_IP = 0,
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MTP = 92,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct __fc_gethostbyname {
   struct hostent host ;
   unsigned char host_addr[sizeof(struct in_addr)] ;
   char *h_addr_ptrs[2 + 1] ;
   char *host_aliases[2] ;
   char hostbuf[128] ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   uid_t pw_uid ;
   gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
typedef unsigned int ino_t;
typedef long time_t;
typedef unsigned int blkcnt_t;
typedef unsigned int blksize_t;
typedef unsigned int dev_t;
typedef unsigned int mode_t;
typedef unsigned int nlink_t;
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
};
struct __fc_pos_t {
   unsigned long __fc_stdio_position ;
};
typedef struct __fc_pos_t fpos_t;
struct __fc_FILE {
   unsigned int __fc_FILE_id ;
   unsigned int __fc_FILE_data ;
};
typedef struct __fc_FILE FILE;
typedef int clockid_t;
struct timespec {
   long tv_sec ;
   long tv_nsec ;
};
typedef unsigned int clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
enum __fc_memory_order {
    memory_order_relaxed = 0,
    memory_order_consume = 1,
    memory_order_acquire = 2,
    memory_order_release = 3,
    memory_order_acq_rel = 4,
    memory_order_seq_cst = 5
};
typedef enum __fc_memory_order memory_order;
struct __fc_atomic_flag {
   unsigned char __fc_val ;
};
typedef struct __fc_atomic_flag atomic_flag;
typedef unsigned char atomic_uchar;
typedef unsigned short atomic_ushort;
typedef unsigned int atomic_uint;
typedef unsigned long atomic_ulong;
typedef unsigned long long atomic_ullong;
typedef void * const * va_list;
typedef unsigned int id_t;
typedef int suseconds_t;
struct dirent {
   ino_t d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct DIR {
   unsigned int __fc_dir_id ;
   unsigned int __fc_dir_position ;
   struct stat *__fc_dir_inode ;
   struct dirent **__fc_dir_entries ;
};
typedef struct DIR DIR;
struct __fc_fd_set {
   long __fc_fd_set[(unsigned int)1024 / ((unsigned int)8 * sizeof(long))] ;
};
typedef struct __fc_fd_set fd_set;
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct flock {
   short l_type ;
   short l_whence ;
   off_t l_start ;
   off_t l_len ;
   pid_t l_pid ;
};
typedef void * iconv_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef unsigned long nfds_t;
typedef int jmp_buf[5];
struct __fc_sigjmp_buf {
   jmp_buf buf ;
   sigset_t sigs ;
};
typedef struct __fc_sigjmp_buf sigjmp_buf;
struct __fc_code {
   char const *c_name ;
   int c_val ;
};
typedef struct __fc_code CODE;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef unsigned long rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
};
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
};
typedef unsigned int tcflag_t;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_cc[32] ;
};
int volatile Frama_C_entropy_source __attribute__((__unused__));
void Frama_C_make_unknown(char *p, size_t l);

int Frama_C_nondet(int a, int b);

void *Frama_C_nondet_ptr(void *a, void *b);

int Frama_C_interval(int min, int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval_split(int min, int max);

unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                             unsigned char max);

char Frama_C_char_interval(char min, char max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned short Frama_C_unsigned_short_interval(unsigned short min,
                                                      unsigned short max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern short Frama_C_short_interval(short min, short max);

unsigned int Frama_C_unsigned_int_interval(unsigned int min, unsigned int max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_int_interval(int min, int max);

unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                             unsigned long max);

long Frama_C_long_interval(long min, long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long long Frama_C_unsigned_long_long_interval(unsigned long long min,
                                                              unsigned long long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long long Frama_C_long_long_interval(long long min, long long max);

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern size_t Frama_C_size_t_interval(size_t min, size_t max);

float Frama_C_float_interval(float min, float max);

double Frama_C_double_interval(double min, double max);

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern double Frama_C_real_interval_as_double(double min, double max);

 __attribute__((__noreturn__)) void Frama_C_abort(void);

/*@ assigns \result;
    assigns \result \from p; */
extern size_t Frama_C_offset(void const *p);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_cardinal(long long i);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_max(long long i);

/*@ assigns \result;
    assigns \result \from i; */
extern long long Frama_C_abstract_min(long long i);

unsigned int volatile __fc_unsigned_int_entropy;
long volatile __fc_long_entropy;
unsigned long volatile __fc_unsigned_long_entropy;
/*@ assigns Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
void Frama_C_update_entropy(void)
{
  Frama_C_entropy_source = Frama_C_entropy_source;
  return;
}

/*@ requires valid_p: \valid(p + (0 .. l - 1));
    ensures initialization: \initialized(\old(p) + (0 .. \old(l) - 1));
    assigns *(p + (0 .. l - 1)), Frama_C_entropy_source;
    assigns *(p + (0 .. l - 1)) \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
void Frama_C_make_unknown(char *p, size_t l)
{
  Frama_C_update_entropy();
  {
    size_t i = (size_t)0;
    while (i < l) {
      *(p + i) = (char)Frama_C_entropy_source;
      i ++;
    }
  }
  return;
}

/*@ ensures result_a_or_b: \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int Frama_C_nondet(int a, int b)
{
  int tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = a; else tmp = b;
  return tmp;
}

/*@ ensures result_a_or_b: \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
void *Frama_C_nondet_ptr(void *a, void *b)
{
  void *tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = a; else tmp = b;
  return tmp;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int Frama_C_interval(int min, int max)
{
  int r;
  int aux;
  Frama_C_update_entropy();
  aux = Frama_C_entropy_source;
  if (aux >= min) 
    if (aux <= max) r = aux; else r = min;
  else r = min;
  return r;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
char Frama_C_char_interval(char min, char max)
{
  char __retres;
  int tmp;
  tmp = Frama_C_interval((int)min,(int)max);
  __retres = (char)tmp;
  return __retres;
}

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
float Frama_C_float_interval(float min, float max)
{
  float tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = min; else tmp = max;
  return tmp;
}

/*@ requires finite: \is_finite(min) ∧ \is_finite(max);
    requires order: min ≤ max;
    ensures
      result_bounded:
        \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
double Frama_C_double_interval(double min, double max)
{
  double tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = min; else tmp = max;
  return tmp;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                             unsigned char max)
{
  unsigned char __retres;
  int tmp;
  tmp = Frama_C_interval((int)min,(int)max);
  __retres = (unsigned char)tmp;
  return __retres;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
unsigned int Frama_C_unsigned_int_interval(unsigned int min, unsigned int max)
{
  unsigned int r;
  unsigned int aux;
  Frama_C_update_entropy();
  aux = __fc_unsigned_int_entropy;
  if (aux >= min) 
    if (aux <= max) r = aux; else r = min;
  else r = min;
  return r;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
long Frama_C_long_interval(long min, long max)
{
  long r;
  long aux;
  Frama_C_update_entropy();
  aux = __fc_long_entropy;
  if (aux >= min) 
    if (aux <= max) r = aux; else r = min;
  else r = min;
  return r;
}

/*@ requires order: min ≤ max;
    ensures result_bounded: \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                             unsigned long max)
{
  unsigned long r;
  unsigned long aux;
  Frama_C_update_entropy();
  aux = __fc_unsigned_long_entropy;
  if (aux >= min) 
    if (aux <= max) r = aux; else r = min;
  else r = min;
  return r;
}

extern  __attribute__((__noreturn__)) void __builtin_abort(void);

/*@ terminates \false;
    ensures never_terminates: \false;
    assigns \nothing; */
 __attribute__((__noreturn__)) void Frama_C_abort(void);
void Frama_C_abort(void)
{
  __builtin_abort();
  return;
}

int __fc_errno;

/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 4294967295U ⇒ ¬is_allocable(i);
  
  }
 */
/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ memchr_off{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≡ \true ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≡ \true ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ '\000') ∧
      *(s + i) ≡ '\000' ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ '\000') ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ '\000';
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ '\000';
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ '\000' ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ '\000' ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≡ \true ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ (char)c);
  
  }
 */
/*@
axiomatic WMemChr {
  logic 𝔹 wmemchr{L}(wchar_t *s, wchar_t c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  logic ℤ wmemchr_off{L}(wchar_t *s, wchar_t c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom wmemchr_def{L}:
    ∀ wchar_t *s;
    ∀ int c;
    ∀ ℤ n;
      wmemchr(s, c, n) ≡ \true ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(wchar_t *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ wchar_t *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ 0) ∧
      *(s + i) ≡ 0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ wchar_t *s; (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ 0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ 0;
  
  axiom wcslen_at_null{L}:
    ∀ wchar_t *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ 0;
  
  axiom wcslen_not_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ 0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ 0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsChr {
  logic 𝔹 wcschr{L}(wchar_t *wcs, ℤ wc) 
    reads *(wcs + (0 .. wcslen(wcs)));
  
  axiom wcschr_def{L}:
    ∀ wchar_t *wcs;
    ∀ ℤ wc;
      wcschr(wcs, wc) ≡ \true ⇔
      (∃ ℤ i; 0 ≤ i ≤ wcslen(wcs) ∧ *(wcs + i) ≡ (wchar_t)wc);
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_nstring{L}(char *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_string(s);
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_wstring{L}(wchar_t *s) =
  0 ≤ wcslen(s) ∧ \valid_read(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_read_nwstring{L}(wchar_t *s, ℤ n) =
  (\valid_read(s + (0 .. n - 1)) ∧ \initialized(s + (0 .. n - 1))) ∨
  valid_read_wstring(s);
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s ≡ \null ∨ valid_wstring(s);

*/
/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern double atof(char const *nptr);

int atoi(char const *p);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern long atol(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern long long atoll(char const *nptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern double strtod(char const * restrict nptr, char ** restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern float strtof(char const * restrict nptr, char ** restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern long double strtold(char const * restrict nptr,
                           char ** restrict endptr);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern long strtol(char const * restrict nptr, char ** restrict endptr,
                   int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern long long strtoll(char const * restrict nptr, char ** restrict endptr,
                         int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern unsigned long strtoul(char const * restrict nptr,
                             char ** restrict endptr, int base);

/*@ requires valid_nptr: \valid_read(nptr);
    requires separation: \separated(nptr, endptr);
    requires base_range: base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior no_storage:
      assumes null_endptr: endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior store_position:
      assumes nonnull_endptr: endptr ≢ \null;
      requires valid_endptr: \valid(endptr);
      ensures initialization: \initialized(\old(endptr));
      ensures valid_endptr: \valid_read(\old(endptr));
      ensures position_subset: \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors store_position, no_storage;
    disjoint behaviors store_position, no_storage;
 */
extern unsigned long long strtoull(char const * restrict nptr,
                                   char ** restrict endptr, int base);

/*@ ghost extern int __fc_random_counter __attribute__((__unused__)); */

unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures result_range: 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand(unsigned int seed);

/*@ ensures result_range: 0 ≤ \result ≤ __fc_rand_max;
    assigns \result;
    assigns \result \from __fc_random_counter;
 */
extern long random(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srandom(unsigned int seed);

int __fc_random48_init;
unsigned short __fc_random48_counter[3];
unsigned short *__fc_p_random48_counter = __fc_random48_counter;
/*@ ensures random48_initialized: __fc_random48_init ≡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from seed;
    assigns __fc_random48_init \from \nothing;
 */
extern void srand48(long seed);

/*@ requires
      initialization: initialized_seed16v: \initialized(seed16v + (0 .. 2));
    ensures random48_initialized: __fc_random48_init ≡ 1;
    ensures result_counter: \result ≡ __fc_p_random48_counter;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init, \result;
    assigns __fc_random48_counter[0 .. 2]
      \from (indirect: *(seed16v + (0 .. 2)));
    assigns __fc_random48_init \from \nothing;
    assigns \result \from __fc_p_random48_counter;
 */
extern unsigned short *seed48(unsigned short seed16v[3]);

/*@ ensures random48_initialized: __fc_random48_init ≡ 1;
    assigns __fc_random48_counter[0 .. 2], __fc_random48_init;
    assigns __fc_random48_counter[0 .. 2] \from *(param + (0 .. 5));
    assigns __fc_random48_init \from \nothing;
 */
extern void lcong48(unsigned short param[7]);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: \is_finite(\result) ∧ 0.0 ≤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern double drand48(void);

/*@ requires
      initialization: initialized_xsubi: \initialized(xsubi + (0 .. 2));
    ensures result_range: \is_finite(\result) ∧ 0.0 ≤ \result < 1.0;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern double erand48(unsigned short xsubi[3]);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: 0 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern long lrand48(void);

/*@ requires
      initialization: initialized_xsubi: \initialized(xsubi + (0 .. 2));
    ensures result_range: 0 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern long nrand48(unsigned short xsubi[3]);

/*@ requires random48_initialized: __fc_random48_init ≡ 1;
    ensures result_range: -2147483648 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern long mrand48(void);

/*@ requires
      initialization: initialized_xsubi: \initialized(xsubi + (0 .. 2));
    ensures result_range: -2147483648 ≤ \result < 2147483648;
    assigns __fc_random48_counter[0 .. 2], \result;
    assigns __fc_random48_counter[0 .. 2]
      \from __fc_random48_counter[0 .. 2];
    assigns \result \from __fc_random48_counter[0 .. 2];
 */
extern long jrand48(unsigned short xsubi[3]);

void *calloc(size_t nmemb, size_t size);

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern void *malloc(size_t size);

/*@ requires freeable: p ≡ \null ∨ \freeable(p);
    assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes nonnull_p: p ≢ \null;
      ensures freed: \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes null_p: p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
extern void free(void *p);

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior deallocation:
      assumes nonnull_ptr: ptr ≢ \null;
      assumes can_allocate: is_allocable(size);
      ensures freed: \allocable(\old(ptr));
      ensures freeable: \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, deallocation, allocation;
    disjoint behaviors allocation, fail;
    disjoint behaviors deallocation, fail;
 */
extern void *realloc(void *ptr, size_t size);

/*@ requires freeable: ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: nmemb), (indirect: size), __fc_heap_status;
    assigns \result
      \from ptr, (indirect: nmemb), (indirect: size),
            (indirect: __fc_heap_status);
    frees ptr;
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(nmemb * size);
      ensures
        allocation: \fresh{Old, Here}(\result,\old(nmemb) * \old(size));
      allocates \result;
    
    behavior deallocation:
      assumes nonnull_ptr: ptr ≢ \null;
      assumes can_allocate: is_allocable(nmemb * size);
      ensures freed: \allocable(\old(ptr));
      ensures freeable: \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes cannot_allocate: ¬is_allocable(nmemb * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nmemb), (indirect: size),
              (indirect: __fc_heap_status);
      allocates \nothing;
    
    complete behaviors fail, deallocation, allocation;
    disjoint behaviors allocation, fail;
    disjoint behaviors deallocation, fail;
 */
extern void *reallocarray(void *ptr, size_t nmemb, size_t size);

/*@ exits status: \exit_status ≢ 0;
    ensures never_terminates: \false;
    
    assigns \exit_status \from \nothing;
 */
extern  __attribute__((__noreturn__)) void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int at_quick_exit(void (*func)(void));

/*@ exits status: \exit_status ≡ \old(status);
    ensures never_terminates: \false;
    
    assigns \exit_status \from status;
 */
extern  __attribute__((__noreturn__)) void exit(int status);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _Exit(int status);

char *__fc_env[4096];
char *getenv(char const *name);

int putenv(char *string);

int setenv(char const *name, char const *value, int overwrite);

int unsetenv(char const *name);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void quick_exit(int status);

/*@ requires
      null_or_valid_string_command:
        command ≡ \null ∨ valid_read_string(command);
    assigns \result;
    assigns \result
      \from (indirect: command), (indirect: *(command + (0 ..)));
 */
extern int system(char const *command);

/*@ requires valid_function_compar: \valid_function(compar);
    ensures
      null_or_correct_result:
        \result ≡ \null ∨
        \subset(\result,
               (void *)((char *)\old(base) +
                        (0 .. \old(size) * (\old(nmemb) - 1))));
    assigns \result;
    assigns \result
      \from (indirect: key), *((char *)key + (0 .. size - 1)), base,
            *((char *)base + (0 .. size * (nmemb - 1))), (indirect: nmemb),
            (indirect: size), (indirect: *compar);
 */
extern void *bsearch(void const *key, void const *base, size_t nmemb,
                     size_t size, int (*compar)(void const *, void const *));

/*@ requires valid_function_compar: \valid_function(compar);
    assigns *((char *)base + (0 ..));
    assigns *((char *)base + (0 ..))
      \from (indirect: base), *((char *)base + (0 ..)), (indirect: nmemb),
            (indirect: size), (indirect: compar), (indirect: *compar);
 */
extern void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(void const *, void const *));

int abs(int i);

/*@ requires abs_representable: j > -2147483647L - 1L;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result ≡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j ≥ 0;
      ensures same_result: \result ≡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
extern long labs(long j);

/*@ requires abs_representable: j > -9223372036854775807LL - 1LL;
    assigns \result;
    assigns \result \from j;
    
    behavior negative:
      assumes negative: j < 0;
      ensures opposite_result: \result ≡ -\old(j);
    
    behavior nonnegative:
      assumes nonnegative: j ≥ 0;
      ensures same_result: \result ≡ \old(j);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
extern long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern lldiv_t lldiv(long long numer, long long denom);

/*@ ghost extern int __fc_mblen_state; */

/*@ assigns \result, __fc_mblen_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
    assigns __fc_mblen_state
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
 */
extern int mblen(char const *s, size_t n);

/*@ ghost extern int __fc_mbtowc_state; */

/*@ requires separation: \separated(pwc, s);
    ensures consumed_range: \result ≤ \old(n);
    assigns \result, *(pwc + (0 .. \result - 1)), __fc_mbtowc_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n),
            __fc_mbtowc_state;
    assigns *(pwc + (0 .. \result - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
    assigns __fc_mbtowc_state
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
 */
extern int mbtowc(wchar_t * restrict pwc, char const * restrict s, size_t n);

/*@ ghost extern int __fc_wctomb_state; */

/*@ assigns \result, *(s + (0 ..)), __fc_wctomb_state;
    assigns \result \from (indirect: wc), __fc_wctomb_state;
    assigns *(s + (0 ..)) \from wc, __fc_wctomb_state;
    assigns __fc_wctomb_state \from wc, __fc_wctomb_state;
 */
extern int wctomb(char *s, wchar_t wc);

/*@ requires separation: \separated(pwcs, s);
    assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n);
    assigns *(pwcs + (0 .. n - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n);
 */
extern size_t mbstowcs(wchar_t * restrict pwcs, char const * restrict s,
                       size_t n);

/*@ requires separation: \separated(s, pwcs);
    assigns \result, *(s + (0 .. n - 1));
    assigns \result
      \from (indirect: pwcs), (indirect: *(pwcs + (0 .. n - 1))),
            (indirect: n);
    assigns *(s + (0 .. n - 1))
      \from (indirect: pwcs), *(pwcs + (0 .. n - 1)), (indirect: n);
 */
extern size_t wcstombs(char * restrict s, wchar_t const * restrict pwcs,
                       size_t n);

int posix_memalign(void **memptr, size_t alignment, size_t size);

/*@ requires valid_template: valid_string(templat);
    requires template_len: strlen(templat) ≥ 6;
    ensures
      result_error_or_valid_fd: \result ≡ -1 ∨ (0 ≤ \result < 16);
    assigns *(templat + (0 ..)), \result;
    assigns *(templat + (0 ..)) \from \nothing;
    assigns \result \from \nothing;
 */
extern int mkstemp(char *templat);

/*@ requires valid_template: valid_string(templat);
    requires template_len: strlen(templat) ≥ 6 + suffixlen;
    requires non_negative_suffixlen: suffixlen ≥ 0;
    ensures
      result_error_or_valid_fd: \result ≡ -1 ∨ (0 ≤ \result < 16);
    assigns *(templat + (0 ..)), \result;
    assigns *(templat + (0 ..)) \from \nothing;
    assigns \result \from \nothing;
 */
extern int mkstemps(char *templat, int suffixlen);

char *realpath(char const * restrict file_name, char * restrict resolved_name);

char *canonicalize_file_name(char const *path);

/*@
predicate non_escaping{L}(void *s, ℤ n) =
  ∀ ℤ i; 0 ≤ i < n ⇒ ¬\dangling((char *)s + i);
 */
/*@
predicate empty_block{L}(void *s) =
  \block_length((char *)s) ≡ 0 ∧ \offset((char *)s) ≡ 0;
 */
/*@
predicate valid_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid((char *)s + (0 .. n - 1));
 */
/*@
predicate valid_read_or_empty{L}(void *s, size_t n) =
  (empty_block(s) ∨ \valid_read((char *)s)) ∧
  \valid_read((char *)s + (1 .. n - 1));

*/
int memcmp(void const *s1, void const *s2, size_t n);

void *memchr(void const *s, int c, size_t n);

void *memrchr(void const *s, int c, size_t n);

void *memcpy(void * restrict dest, void const * restrict src, size_t n);

void *mempcpy(void * restrict dest, void const * restrict src, size_t n);

void *memmove(void *dest, void const *src, size_t n);

void *memset(void *s, int c, size_t n);

size_t strlen(char const *s);

size_t strnlen(char const *s, size_t maxlen);

int strcmp(char const *s1, char const *s2);

int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
extern int strcoll(char const *s1, char const *s2);

char *strchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    ensures
      result_same_base: \subset(\result, \old(s) + (0 .. strlen(\old(s))));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
 */
extern char *strchrnul(char const *s, int c);

char *strrchr(char const *s, int c);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(reject + (0 ..)));
 */
extern size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures result_bounded: 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_s: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      result_null_or_same_base:
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
extern char *strpbrk(char const *s, char const *accept);

char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
extern char *strcasestr(char const *haystack, char const *needle);

char *__fc_strtok_ptr;
/*@ requires valid_string_delim: valid_read_string(delim);
    assigns *(s + (0 ..)), *(__fc_strtok_ptr + (0 ..)), \result,
            __fc_strtok_ptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: __fc_strtok_ptr),
            (indirect: *(delim + (0 ..)));
    assigns *(__fc_strtok_ptr + (0 ..))
      \from *(__fc_strtok_ptr + (0 ..)), (indirect: s),
            (indirect: __fc_strtok_ptr), (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, __fc_strtok_ptr, (indirect: *(s + (0 ..))),
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    assigns __fc_strtok_ptr
      \from \old(__fc_strtok_ptr), s,
            (indirect: *(__fc_strtok_ptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              ¬(strchr(s, *(delim + i)) ≡ \true)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures ptr_subset: \subset(__fc_strtok_ptr, \old(s) + (0 ..));
      assigns __fc_strtok_ptr, *(s + (0 ..)), \result;
      assigns __fc_strtok_ptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: __fc_strtok_ptr ≢ \null;
      ensures
        result_subset:
          \result ≡ \null ∨
          \subset(\result, \old(__fc_strtok_ptr) + (0 ..));
      ensures
        ptr_subset: \subset(__fc_strtok_ptr, \old(__fc_strtok_ptr) + (0 ..));
      assigns *(__fc_strtok_ptr + (0 ..)), __fc_strtok_ptr, \result;
      assigns *(__fc_strtok_ptr + (0 ..))
        \from *(__fc_strtok_ptr + (0 ..)), (indirect: __fc_strtok_ptr),
              (indirect: *(delim + (0 ..)));
      assigns __fc_strtok_ptr
        \from \old(__fc_strtok_ptr), (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from __fc_strtok_ptr, (indirect: *(__fc_strtok_ptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
extern char *strtok(char * restrict s, char const * restrict delim);

/*@ requires valid_string_delim: valid_read_string(delim);
    requires valid_saveptr: \valid(saveptr);
    assigns *(s + (0 ..)), *(*saveptr + (0 ..)), \result, *saveptr;
    assigns *(s + (0 ..))
      \from *(s + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns *(*saveptr + (0 ..))
      \from *(*saveptr + (0 ..)), (indirect: s), (indirect: *saveptr),
            (indirect: *(delim + (0 ..)));
    assigns \result
      \from s, *saveptr, (indirect: *(s + (0 ..))),
            (indirect: *(*saveptr + (0 ..))), (indirect: *(delim + (0 ..)));
    assigns *saveptr
      \from \old(*saveptr), s, (indirect: *(*saveptr + (0 ..))),
            (indirect: *(delim + (0 ..)));
    
    behavior new_str:
      assumes s_not_null: s ≢ \null;
      requires
        valid_string_s_or_delim_not_found:
          valid_string(s) ∨
          (valid_read_string(s) ∧
           (∀ int i;
              0 ≤ i < strlen(delim) ⇒
              ¬(strchr(s, *(delim + i)) ≡ \true)));
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(s) + (0 ..));
      ensures initialization: \initialized(\old(saveptr));
      ensures saveptr_subset: \subset(*\old(saveptr), \old(s) + (0 ..));
      assigns *saveptr, *(s + (0 ..)), \result;
      assigns *saveptr
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
      assigns *(s + (0 ..))
        \from *(s + (0 ..)), (indirect: s), (indirect: *(delim + (0 ..)));
      assigns \result
        \from s, (indirect: *(s + (0 ..))), (indirect: *(delim + (0 ..)));
    
    behavior resume_str:
      assumes s_null: s ≡ \null;
      requires not_first_call: *saveptr ≢ \null;
      requires initialization: saveptr: \initialized(saveptr);
      ensures
        result_subset:
          \result ≡ \null ∨ \subset(\result, \old(*saveptr) + (0 ..));
      ensures
        saveptr_subset: \subset(*\old(saveptr), \old(*saveptr) + (0 ..));
      assigns *(*saveptr + (0 ..)), *saveptr, \result;
      assigns *(*saveptr + (0 ..))
        \from *(*saveptr + (0 ..)), (indirect: *saveptr),
              (indirect: *(delim + (0 ..)));
      assigns *saveptr
        \from \old(*saveptr), (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
      assigns \result
        \from *saveptr, (indirect: *(*saveptr + (0 ..))),
              (indirect: *(delim + (0 ..)));
    
    complete behaviors resume_str, new_str;
    disjoint behaviors resume_str, new_str;
 */
extern char *strtok_r(char * restrict s, char const * restrict delim,
                      char ** restrict saveptr);

/*@ requires
      valid_string_stringp: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
extern char *strsep(char **stringp, char const *delim);

char __fc_strerror[64];
char * const __fc_p_strerror = __fc_strerror;
char *strerror(int errnum);

char *strcpy(char *dest, char const *src);

char *strncpy(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires
      separation:
        \separated(
          dest + (0 .. n - 1), src + (0 .. \max(n - 1, strlen(src)))
          );
    ensures
      initialization:
        \initialized(\old(dest) + (0 .. \min(strlen(\old(src)), \old(n) - 1)));
    ensures bounded_result: \result ≡ strlen(\old(src));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
size_t strlcpy(char * restrict dest, char const * restrict src, size_t n);

char *stpcpy(char *dest, char const *src);

char *strcat(char *dest, char const *src);

char *strncat(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures
      bounded_result: \result ≡ strlen(\old(dest)) + strlen(\old(src));
    assigns *(dest + (strlen{Old}(dest) .. n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. n))
      \from (indirect: n), *(src + (0 .. strlen{Old}(src)));
    assigns \result
      \from (indirect: src), (indirect: *(src + (0 .. n - 1))), (indirect: n);
 */
extern size_t strlcat(char * restrict dest, char const * restrict src,
                      size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from (indirect: *(src + (0 ..))), (indirect: n);
    assigns \result \from dest;
 */
extern size_t strxfrm(char * restrict dest, char const * restrict src,
                      size_t n);

char *strdup(char const *s);

char *strndup(char const *s, size_t n);

char __fc_strsignal[64];
char * const __fc_p_strsignal = __fc_strsignal;
char *strsignal(int signum);

/*@ requires valid_memory_area: \valid((char *)s + (0 .. n - 1));
    ensures
      s_initialized: initialization:
        \initialized((char *)\old(s) + (0 .. \old(n) - 1));
    ensures
      zero_initialized: \subset(*((char *)\old(s) + (0 .. \old(n) - 1)), {0});
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
extern void bzero(void *s, size_t n);

int strcasecmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    assigns \result;
    assigns \result
      \from (indirect: n), (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1)));
 */
extern int strncasecmp(char const *s1, char const *s2, size_t n);

error_t argz_create(char * const *argv, char **argz, size_t *len);

error_t argz_create_sep(char const *string, int delim, char **argz,
                        size_t *len);

size_t argz_count(char const *argz, size_t len);

void argz_extract(char const *argz, size_t len, char **argv);

void argz_stringify(char *argz, size_t len, int sep);

error_t argz_append(char **argz, size_t *argz_len, char const *buf,
                    size_t buf_len);

error_t argz_add(char **argz, size_t *argz_len, char const *str);

error_t argz_add_sep(char **argz, size_t *argz_len, char const *string,
                     int delim);

void argz_delete(char **argz, size_t *argz_len, char *entry);

error_t argz_insert(char **argz, size_t *argz_len, char *before,
                    char const *entry);

error_t argz_replace(char **argz, size_t *argz_len, char const *str,
                     char const *with, unsigned int *replace_count);

char *argz_next(char const *argz, size_t argz_len, char const *entry);

void argz_stringify(char *argz, size_t len, int sep)
{
  if (len > (size_t)0) 
    while (1) {
      {
        size_t tmp_0;
        char *tmp_1;
        size_t part_len = strnlen((char const *)argz,len);
        argz += part_len;
        len -= part_len;
        tmp_0 = len;
        len --;
        ;
        if (tmp_0 <= (size_t)1) break;
        tmp_1 = argz;
        argz ++;
        *tmp_1 = (char)sep;
      }
    }
  return;
}

static void str_append(char **to, size_t *to_len, char const *buf,
                       size_t const buf_len)
{
  size_t new_len = *to_len + buf_len;
  char *new_to = realloc((void *)*to,new_len + (size_t)1);
  if (new_to) {
    void *tmp_0;
    tmp_0 = mempcpy((void *)(new_to + *to_len),(void const *)buf,buf_len);
    *((char *)tmp_0) = (char)'\000';
    *to = new_to;
    *to_len = new_len;
  }
  else {
    free((void *)*to);
    *to = (char *)0;
  }
  return;
}

error_t argz_replace(char **argz, size_t *argz_len, char const *str,
                     char const *with, unsigned int *replace_count)
{
  error_t er = 0;
  if (str) 
    if (*str) {
      char *arg = (char *)0;
      char *src = *argz;
      size_t src_len = *argz_len;
      char *dst = (char *)0;
      size_t dst_len = (size_t)0;
      int delayed_copy = 1;
      size_t str_len = strlen(str);
      size_t with_len = strlen(with);
      while (1) {
        if (! er) {
          arg = argz_next((char const *)src,src_len,(char const *)arg);
          if (! arg) break;
        }
        else break;
        {
          char *match = strstr((char const *)arg,str);
          if (match) {
            char *from = match + str_len;
            size_t to_len = (size_t)(match - arg);
            char *to = strndup((char const *)arg,to_len);
            while (1) {
              if (to) {
                if (! from) break;
              }
              else break;
              str_append(& to,& to_len,with,with_len);
              if (to) {
                match = strstr((char const *)from,str);
                if (match) {
                  str_append(& to,& to_len,(char const *)from,
                             (size_t)(match - from));
                  from = match + str_len;
                }
                else {
                  size_t tmp_3;
                  tmp_3 = strlen((char const *)from);
                  ;
                  str_append(& to,& to_len,(char const *)from,tmp_3);
                  from = (char *)0;
                }
              }
            }
            if (to) {
              if (delayed_copy) {
                if (arg > src) er = argz_append(& dst,& dst_len,
                                                (char const *)src,
                                                (size_t)(arg - src));
                delayed_copy = 0;
              }
              if (! er) er = argz_add(& dst,& dst_len,(char const *)to);
              free((void *)to);
            }
            else er = 12;
            if (replace_count) (*replace_count) ++;
          }
          else 
            if (! delayed_copy) er = argz_add(& dst,& dst_len,
                                              (char const *)arg);
        }
      }
      if (! er) {
        if (! delayed_copy) {
          free((void *)src);
          *argz = dst;
          *argz_len = dst_len;
        }
      }
      else 
        if (dst_len > (size_t)0) free((void *)dst);
    }
  return er;
}

char *argz_next(char const *argz, size_t argz_len, char const *entry)
{
  char *__retres;
  if (entry) {
    char *tmp_0;
    if (entry < argz + argz_len) {
      char *tmp;
      tmp = strchr(entry,'\000');
      entry = (char const *)(tmp + 1);
    }
    if (entry >= argz + argz_len) tmp_0 = (char *)0;
    else tmp_0 = (char *)entry;
    __retres = tmp_0;
    goto return_label;
  }
  else 
    if (argz_len > (size_t)0) {
      __retres = (char *)argz;
      goto return_label;
    }
    else {
      __retres = (char *)0;
      goto return_label;
    }
  return_label: return __retres;
}

error_t argz_insert(char **argz, size_t *argz_len, char *before,
                    char const *entry)
{
  error_t __retres;
  if (! before) {
    error_t tmp;
    tmp = argz_add(argz,argz_len,entry);
    __retres = tmp;
    goto return_label;
  }
  if (before < *argz) {
    __retres = 22;
    goto return_label;
  }
  else 
    if (before >= *argz + *argz_len) {
      __retres = 22;
      goto return_label;
    }
  if (before > *argz) 
    while (*(before + -1)) before --;
  {
    size_t tmp_0;
    size_t after_before = *argz_len - (size_t)(before - *argz);
    tmp_0 = strlen(entry);
    size_t entry_len = tmp_0 + (size_t)1;
    size_t new_argz_len = *argz_len + entry_len;
    ptrdiff_t before_offset = before - *argz;
    char *new_argz = realloc((void *)*argz,new_argz_len);
    if (new_argz) {
      before = new_argz + before_offset;
      memmove((void *)(before + entry_len),(void const *)before,after_before);
      memmove((void *)before,(void const *)entry,entry_len);
      *argz = new_argz;
      *argz_len = new_argz_len;
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = 12;
      goto return_label;
    }
    return_label: return __retres;
  }
}

void argz_extract(char const *argz, size_t len, char **argv)
{
  while (len > (size_t)0) {
    char **tmp_0;
    size_t part_len = strlen(argz);
    tmp_0 = argv;
    argv ++;
    *tmp_0 = (char *)argz;
    argz += part_len + (size_t)1;
    len -= part_len + (size_t)1;
  }
  *argv = (char *)0;
  return;
}

void argz_delete(char **argz, size_t *argz_len, char *entry)
{
  if (entry) {
    size_t tmp;
    tmp = strlen((char const *)entry);
    size_t entry_len = tmp + (size_t)1;
    *argz_len -= entry_len;
    memmove((void *)entry,(void const *)(entry + entry_len),
            *argz_len - (size_t)(entry - *argz));
    if (*argz_len == (size_t)0) {
      free((void *)*argz);
      *argz = (char *)0;
    }
  }
  return;
}

/*@ assigns \result, *(*(argz + (..)));
    assigns \result \from \nothing;
    assigns *(*(argz + (..))) \from \nothing;
 */
error_t argz_create_sep(char const *string, int delim, char **argz,
                        size_t *len)
{
  error_t __retres;
  size_t tmp;
  tmp = strlen(string);
  size_t nlen = tmp + (size_t)1;
  if (nlen > (size_t)1) {
    char const *rp;
    char *wp;
    *argz = (char *)malloc(nlen);
    if (*argz == (char *)0) {
      __retres = 12;
      goto return_label;
    }
    rp = string;
    wp = *argz;
    while (1) {
      char const *tmp_3;
      if ((int)*rp == delim) 
        if (wp > *argz) 
          if ((int)*(wp + -1) != '\000') {
            char *tmp_1;
            tmp_1 = wp;
            wp ++;
            *tmp_1 = (char)'\000';
          }
          else nlen --;
        else nlen --;
      else {
        char *tmp_2;
        tmp_2 = wp;
        wp ++;
        *tmp_2 = *rp;
      }
      tmp_3 = rp;
      rp ++;
      ;
      if (! ((int)*tmp_3 != '\000')) break;
    }
    if (nlen == (size_t)0) {
      free((void *)*argz);
      *argz = (char *)0;
      *len = (size_t)0;
    }
    *len = nlen;
  }
  else {
    *argz = (char *)0;
    *len = (size_t)0;
  }
  __retres = 0;
  return_label: return __retres;
}

error_t argz_create(char * const *argv, char **argz, size_t *len)
{
  error_t __retres;
  int argc;
  char * const *ap;
  char *p;
  size_t tlen = (size_t)0;
  argc = 0;
  while (*(argv + argc) != (char *)0) {
    size_t tmp;
    tmp = strlen((char const *)*(argv + argc));
    tlen += tmp + (size_t)1;
    argc ++;
  }
  if (tlen == (size_t)0) *argz = (char *)0;
  else {
    *argz = (char *)malloc(tlen);
    if (*argz == (char *)0) {
      __retres = 12;
      goto return_label;
    }
    p = *argz;
    ap = argv;
    while (*ap) {
      p = stpcpy(p,(char const *)*ap);
      ap ++;
      p ++;
    }
  }
  *len = tlen;
  __retres = 0;
  return_label: return __retres;
}

size_t argz_count(char const *argz, size_t len)
{
  size_t count = (size_t)0;
  while (len > (size_t)0) {
    size_t part_len = strlen(argz);
    argz += part_len + (size_t)1;
    len -= part_len + (size_t)1;
    count ++;
  }
  return count;
}

error_t argz_append(char **argz, size_t *argz_len, char const *buf,
                    size_t buf_len)
{
  error_t __retres;
  size_t new_argz_len = *argz_len + buf_len;
  char *new_argz = realloc((void *)*argz,new_argz_len);
  if (new_argz) {
    memcpy((void *)(new_argz + *argz_len),(void const *)buf,buf_len);
    *argz = new_argz;
    *argz_len = new_argz_len;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = 12;
    goto return_label;
  }
  return_label: return __retres;
}

error_t argz_add(char **argz, size_t *argz_len, char const *str)
{
  error_t tmp_0;
  size_t tmp;
  tmp = strlen(str);
  ;
  ;
  ;
  tmp_0 = argz_append(argz,argz_len,str,tmp + (size_t)1);
  return tmp_0;
}

error_t argz_add_sep(char **argz, size_t *argz_len, char const *string,
                     int delim)
{
  error_t __retres;
  size_t tmp;
  tmp = strlen(string);
  size_t nlen = tmp + (size_t)1;
  if (nlen > (size_t)1) {
    char const *rp;
    char *wp;
    *argz = (char *)realloc((void *)*argz,*argz_len + nlen);
    if (*argz == (char *)0) {
      __retres = 12;
      goto return_label;
    }
    wp = *argz + *argz_len;
    rp = string;
    while (1) {
      char const *tmp_3;
      if ((int)*rp == delim) 
        if (wp > *argz) 
          if ((int)*(wp + -1) != '\000') {
            char *tmp_1;
            tmp_1 = wp;
            wp ++;
            *tmp_1 = (char)'\000';
          }
          else nlen --;
        else nlen --;
      else {
        char *tmp_2;
        tmp_2 = wp;
        wp ++;
        *tmp_2 = *rp;
      }
      tmp_3 = rp;
      rp ++;
      ;
      if (! ((int)*tmp_3 != '\000')) break;
    }
    *argz_len += nlen;
  }
  __retres = 0;
  return_label: return __retres;
}

void __FC_assert(int c, char const *file, int line, char const *expr);

/*@ assigns \nothing; */
extern void Frama_C_show_each_warning();

/*@ requires nonnull_c: c ≢ 0;
    terminates c ≢ 0;
    assigns \nothing; */
void __FC_assert(int c, char const *file, int line, char const *expr)
{
  if (! c) {
    Frama_C_show_each_warning("Assertion may fail",file,line,expr);
    Frama_C_abort();
  }
  return;
}

int isalnum(int c);

int isalpha(int c);

int isblank(int c);

int iscntrl(int c);

int isdigit(int c);

int isgraph(int c);

int islower(int c);

int isprint(int c);

int ispunct(int c);

int isspace(int c);

int isupper(int c);

int isxdigit(int c);

int tolower(int c);

int toupper(int c);

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c_ascii: 0 ≤ c ≤ 127;
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c_non_ascii: ¬(0 ≤ c ≤ 127);
      ensures zero_result: \result ≡ 0;
    
    complete behaviors no_match, match;
    disjoint behaviors no_match, match;
 */
extern int isascii(int c);

/*@ requires c_uchar_or_eof_or_EOF: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes
        c_alnum:
          ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z') ∨ ('0' ≤ c ≤ '9');
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c_non_alnum:
          c ≡ -1 ∨ (0 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨
          (91 ≤ c ≤ 96) ∨ (123 ≤ c ≤ 127);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isalnum(int c)
{
  int tmp;
  if (c >= 'A') {
    if (c <= 'Z') tmp = 1; else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if (c >= 'a') {
      if (c <= 'z') tmp = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if (c >= '0') 
        if (c <= '9') tmp = 1; else tmp = 0;
      else tmp = 0;
    }
  }
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_alpha: ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z');
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c_non_alpha:
          c ≡ -1 ∨ (0 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
          (123 ≤ c ≤ 127);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isalpha(int c)
{
  int tmp;
  if (c >= 'A') {
    if (c <= 'Z') tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (c >= 'a') 
      if (c <= 'z') tmp = 1; else tmp = 0;
    else tmp = 0;
  }
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c_tab_or_space: c ≡ ' ' ∨ c ≡ '\t';
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c_non_blank: c ≢ ' ' ∧ c ≢ '\t';
      ensures zero_result: \result ≡ 0;
    
    complete behaviors no_match, match;
    disjoint behaviors no_match, match;
 */
int isblank(int c)
{
  int tmp;
  if (c == ' ') tmp = 1;
  else 
    if (c == '\t') tmp = 1;
    else 
      if (c == ' ') tmp = 1;
      else 
        if (c == '\f') tmp = 1;
        else 
          if (c == '\n') tmp = 1;
          else 
            if (c == '\r') tmp = 1;
            else 
              if (c == '\t') tmp = 1;
              else 
                if (c == '\v') tmp = 1; else tmp = 0;
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_control_char: (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c_non_control_char: c ≡ -1 ∨ (32 ≤ c ≤ 126);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int iscntrl(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c_digit: '0' ≤ c ≤ '9';
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c_non_digit: c < '0' ∨ c > '9';
      ensures zero_result: \result ≡ 0;
    
    complete behaviors no_match, match;
    disjoint behaviors no_match, match;
 */
int isdigit(int c)
{
  int tmp;
  if (c >= '0') 
    if (c <= '9') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_graphical: 33 ≤ c ≤ 126;
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c_non_graphical: c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ c ≡ 127;
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isgraph(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_lower: 'a' ≤ c ≤ 'z';
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c_non_lower: c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c < 127);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int islower(int c)
{
  int tmp;
  if (c >= 'a') 
    if (c <= 'z') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_printable: 32 ≤ c ≤ 126;
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c_non_printable: c ≡ -1 ∨ (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isprint(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes
        c_punct:
          (33 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
          (123 ≤ c ≤ 126);
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c_non_punct:
          c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ (48 ≤ c ≤ 57) ∨
          (65 ≤ c ≤ 90) ∨ (97 ≤ c ≤ 122) ∨ c ≡ 127;
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int ispunct(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_space: (9 ≤ c ≤ 13) ∨ c ≡ ' ';
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c_non_space:
          c ≡ -1 ∨ (0 ≤ c ≤ 8) ∨ (14 ≤ c < ' ') ∨
          (' ' < c ≤ 127);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isspace(int c)
{
  int tmp;
  if (c == ' ') tmp = 1;
  else 
    if (c == '\f') tmp = 1;
    else 
      if (c == '\n') tmp = 1;
      else 
        if (c == '\r') tmp = 1;
        else 
          if (c == '\t') tmp = 1;
          else 
            if (c == '\v') tmp = 1; else tmp = 0;
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes c_upper: 'A' ≤ c ≤ 'Z';
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c_non_upper: c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures zero_result: \result ≡ 0;
    
    disjoint behaviors definitely_not_match, definitely_match;
 */
int isupper(int c)
{
  int tmp;
  if (c >= 'A') 
    if (c <= 'Z') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes
        c_hexa_digit:
          ('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨ ('a' ≤ c ≤ 'f');
      ensures nonzero_result: \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes
        c_non_hexa_digit:
          ¬(('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨
             ('a' ≤ c ≤ 'f'));
      ensures zero_result: \result ≡ 0;
    
    complete behaviors no_match, match;
    disjoint behaviors no_match, match;
 */
int isxdigit(int c)
{
  int tmp;
  if (c >= '0') {
    if (c <= '9') tmp = 1; else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if (c >= 'a') {
      if (c <= 'f') tmp = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if (c >= 'A') 
        if (c <= 'F') tmp = 1; else tmp = 0;
      else tmp = 0;
    }
  }
  return tmp;
}

/*@ requires c_uchar_or_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures result_uchar_of_eof: (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes c_ascii_upper: 'A' ≤ c ≤ 'Z';
      ensures result_ascii_lower: \result ≡ \old(c) + 32;
    
    behavior definitely_not_changed:
      assumes
        c_ascii_but_non_upper:
          c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures result_unchanged: \result ≡ \old(c);
    
    disjoint behaviors definitely_not_changed, definitely_changed;
 */
int tolower(int c)
{
  int __retres;
  if (c >= 'A') 
    if (c <= 'Z') {
      __retres = c + 0x20;
      goto return_label;
    }
  __retres = c;
  return_label: return __retres;
}

/*@ requires c_uchar_of_eof: (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures result_uchar_of_eof: (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes c_ascii_lower: 'a' ≤ c ≤ 'z';
      ensures result_ascii_upper: \result ≡ \old(c) - 32;
    
    behavior definitely_not_changed:
      assumes
        c_ascii_but_non_lower:
          c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c ≤ 127);
      ensures result_unchanged: \result ≡ \old(c);
    
    disjoint behaviors definitely_not_changed, definitely_changed;
 */
int toupper(int c)
{
  int __retres;
  if (c >= 'a') 
    if (c <= 'z') {
      __retres = c - 0x20;
      goto return_label;
    }
  __retres = c;
  return_label: return __retres;
}

int __fc_errno = 0;
int fetestexcept(int excepts);

int feholdexcept(fenv_t *envp);

int fesetenv(fenv_t const *envp);

static int volatile fetestexcept___fc_random_fetestexcept;
int fetestexcept(int excepts)
{
  int __retres;
  __retres = 0x00FF & fetestexcept___fc_random_fetestexcept;
  return __retres;
}

fenv_t volatile __fc_fenv_state;
int feholdexcept(fenv_t *envp)
{
  int __retres;
  *envp = __fc_fenv_state;
  __retres = 0;
  return __retres;
}

int fesetenv(fenv_t const *envp)
{
  int __retres;
  __fc_fenv_state = *envp;
  __retres = 0;
  return __retres;
}

extern int volatile __fc_fds[1024];

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_amode: (amode & ~((4 | 2) | 1)) ≡ 0 ∨ amode ≡ 0;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 ..))), (indirect: amode);
 */
extern int access(char const *path, int amode);

/*@ requires valid_string_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: path), (indirect: *(path + (0 ..)));
 */
extern int chdir(char const *path);

/*@ requires valid_string_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: path), (indirect: *(path + (0 ..)));
 */
extern int chroot(char const *path);

/*@ requires valid_string_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 ..))),
            (indirect: owner), (indirect: group);
 */
extern int chown(char const *path, uid_t owner, gid_t group);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_fds[fd], \result;
    assigns __fc_fds[fd] \from fd, __fc_fds[fd];
    assigns \result \from (indirect: fd), (indirect: __fc_fds[fd]);
 */
extern int close(int fd);

/*@ requires valid_fildes: 0 ≤ fildes < 1024;
    ensures
      result_valid_fildes_or_error:
        \result ≡ -1 ∨ (\old(fildes) ≤ \result < 1024);
    assigns __fc_fds[fildes ..], \result;
    assigns __fc_fds[fildes ..] \from fildes;
    assigns \result \from fildes;
 */
extern int dup(int fildes);

/*@ requires valid_fildes: 0 ≤ fildes < 1024;
    requires valid_fildes2: 0 ≤ fildes2 < 1024;
    ensures
      result_fildes2_or_error: \result ≡ \old(fildes2) ∨ \result ≡ -1;
    assigns __fc_fds[fildes2], \result;
    assigns __fc_fds[fildes2] \from fildes, fildes2, __fc_fds[fildes2];
    assigns \result
      \from fildes, fildes2, __fc_fds[fildes], __fc_fds[fildes2];
 */
extern int dup2(int fildes, int fildes2);

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_string_arg: valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execl(char const *path, char const *arg, void * const *__va_params);

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_string_arg: valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execle(char const *path, char const *arg,
                  void * const *__va_params);

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_string_arg: valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execlp(char const *path, char const *arg,
                  void * const *__va_params);

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_string_argv0: valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execv(char const *path, char * const *argv);

/*@ requires valid_path: valid_read_string(path);
    requires valid_argv0: valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execve(char const *path, char * const *argv, char * const *env);

/*@ requires valid_string_path: valid_read_string(path);
    requires valid_string_argv0: valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execvp(char const *path, char * const *argv);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _exit(int __x0);

/*@ ensures
      result_ok_child_or_error:
        \result ≡ 0 ∨ \result > 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from \nothing;
 */
extern pid_t fork(void);

/*@ requires valid_buf: \valid(buf + (0 .. size - 1));
    ensures result_ok_or_error: \result ≡ \null ∨ \result ≡ \old(buf);
    assigns *(buf + (0 .. size - 1)), \result;
    assigns *(buf + (0 .. size - 1)) \from (indirect: buf), (indirect: size);
    assigns \result \from buf, (indirect: size);
 */
extern char *getcwd(char *buf, size_t size);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern gid_t getegid(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern uid_t geteuid(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern gid_t getgid(void);

extern char volatile __fc_hostname[64];

/*@ requires name_has_room: \valid(name + (0 .. len - 1));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *(name + (0 .. len - 1));
    assigns \result
      \from (indirect: __fc_hostname[0 .. len]), (indirect: len);
    assigns *(name + (0 .. len - 1))
      \from (indirect: __fc_hostname[0 .. len]), (indirect: len);
 */
extern int gethostname(char *name, size_t len);

/*@ requires name_valid_string: valid_read_nstring(name, len);
    requires bounded_len: len ≤ 64;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_hostname[0 .. len], \result;
    assigns __fc_hostname[0 .. len]
      \from *(name + (0 .. len - 1)), (indirect: len);
    assigns \result \from (indirect: __fc_hostname[0 .. len]);
 */
extern int sethostname(char const *name, size_t len);

/*@ assigns \result;
    assigns \result \from (indirect: pid); */
extern pid_t getpgid(pid_t pid);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern pid_t getpgrp(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern pid_t getpid(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern pid_t getppid(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern pid_t getsid(pid_t __x0);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern uid_t getuid(void);

/*@ ensures result_true_or_false: \result ≡ 0 ∨ \result ≡ 1;
    assigns \result;
    assigns \result \from (indirect: fd), (indirect: __fc_fds[fd]);
 */
extern int isatty(int fd);

/*@ requires valid_path: valid_read_string(path1);
    requires valid_path: valid_read_string(path2);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: *(path1 + (0 .. strlen{Old}(path1)))),
            (indirect: *(path2 + (0 .. strlen{Old}(path2))));
 */
extern int link(char const *path1, char const *path2);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    requires valid_whence: whence ≡ 0 ∨ whence ≡ 1 ∨ whence ≡ 2;
    ensures result_error_or_offset: \result ≡ -1 ∨ 0 ≤ \result;
    assigns \result, __fc_fds[fd];
    assigns \result
      \from (indirect: fd), (indirect: __fc_fds[fd]), (indirect: offset),
            (indirect: whence);
    assigns __fc_fds[fd]
      \from (indirect: fd), __fc_fds[fd], (indirect: offset),
            (indirect: whence);
 */
extern off_t lseek(int fd, off_t offset, int whence);

/*@ requires valid_path: valid_read_string(path);
    assigns \result;
    assigns \result \from (indirect: *(path + (0 ..))), (indirect: name);
 */
extern long pathconf(char const *path, int name);

/*@ requires valid_pipefd: \valid(pipefd + (0 .. 1));
    ensures initialization: pipefd: \initialized(\old(pipefd) + (0 .. 1));
    ensures valid_fd0: 0 ≤ *(\old(pipefd) + 0) < 1024;
    ensures valid_fd1: 0 ≤ *(\old(pipefd) + 1) < 1024;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *(pipefd + (0 .. 1)), \result;
    assigns *(pipefd + (0 .. 1)) \from (indirect: __fc_fds[0 ..]);
    assigns \result \from (indirect: __fc_fds[0 ..]);
 */
extern int pipe(int pipefd[2]);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    requires buf_has_room: \valid((char *)buf + (0 .. count - 1));
    assigns __fc_fds[fd], \result, *((char *)buf + (0 .. count - 1));
    assigns __fc_fds[fd] \from __fc_fds[fd];
    assigns \result \from (indirect: __fc_fds[fd]), (indirect: count);
    assigns *((char *)buf + (0 .. count - 1))
      \from (indirect: __fc_fds[fd]), (indirect: count);
    
    behavior full_read:
      assumes
        nondet_small_count:
          Frama_C_entropy_source ≢ 0 ∧ count ≤ 2147483647;
      ensures res_full: \result ≡ \old(count);
      ensures
        res_init: initialization:
          \initialized((char *)\old(buf) + (0 .. \old(count) - 1));
    
    behavior large_read_implementation_defined:
      assumes
        nondet_large_count:
          Frama_C_entropy_source ≢ 0 ∧ count > 2147483647;
      ensures
        res_init: initialization:
          \initialized((char *)\old(buf) + (0 .. \old(count) - 1));
    
    behavior partial_or_error:
      assumes nondet: Frama_C_entropy_source ≡ 0;
      ensures result_error_or_read_length: -1 ≤ \result < \old(count);
      ensures
        initialization: buf:
          \initialized((char *)\old(buf) + (0 .. \result - 1));
    
    complete behaviors partial_or_error,
                       large_read_implementation_defined,
                       full_read;
    disjoint behaviors partial_or_error,
                       large_read_implementation_defined,
                       full_read;
 */
extern ssize_t read(int fd, void *buf, size_t count);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: gid);
 */
extern int setegid(gid_t gid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: uid);
 */
extern int seteuid(uid_t uid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: gid);
 */
extern int setgid(gid_t gid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: pid), (indirect: pgid);
 */
extern int setpgid(pid_t pid, pid_t pgid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: rgid), (indirect: egid);
 */
extern int setregid(gid_t rgid, gid_t egid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: ruid), (indirect: euid);
 */
extern int setreuid(uid_t ruid, uid_t euid);

/*@ ensures result_pgid_or_error: \result ≡ -1 ∨ \result ≥ 0;
    assigns \result;
    assigns \result \from \nothing;
 */
extern pid_t setsid(void);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: uid);
 */
extern int setuid(uid_t uid);

/*@ ensures unslept: 0 ≤ \result ≤ \old(seconds);
    assigns \result;
    assigns \result \from seconds;
 */
extern unsigned int sleep(unsigned int seconds);

/*@ assigns \nothing; */
extern void sync(void);

/*@ assigns \result;
    assigns \result \from (indirect: name); */
extern long sysconf(int name);

char volatile __fc_ttyname[32];
char volatile *__fc_p_ttyname = __fc_ttyname;
/*@ requires valid_fildes: 0 ≤ fildes < 1024;
    ensures
      result_name_or_null: \result ≡ __fc_p_ttyname ∨ \result ≡ \null;
    assigns \result;
    assigns \result \from __fc_p_ttyname, (indirect: fildes);
 */
extern char *ttyname(int fildes);

/*@ requires valid_string_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: *(path + (0 .. strlen{Old}(path))));
 */
extern int unlink(char const *path);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, Frama_C_entropy_source;
    assigns \result
      \from (indirect: usec), (indirect: Frama_C_entropy_source);
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int usleep(useconds_t usec);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    requires buf_has_room: \valid_read((char *)buf + (0 .. count - 1));
    ensures
      result_error_or_written_bytes:
        \result ≡ -1 ∨ (0 ≤ \result ≤ \old(count));
    assigns __fc_fds[fd], \result;
    assigns __fc_fds[fd]
      \from (indirect: fd), (indirect: count), __fc_fds[fd];
    assigns \result
      \from (indirect: fd), (indirect: count), (indirect: __fc_fds[fd]);
 */
extern ssize_t write(int fd, void const *buf, size_t count);

/*@ requires valid_ruid: \valid(ruid);
    requires valid_euid: \valid(suid);
    requires valid_suid: \valid(euid);
    ensures
      initialization: result_ok_or_error:
        (\result ≡ 0 ∧ \initialized(\old(ruid)) ∧
         \initialized(\old(euid)) ∧ \initialized(\old(suid))) ∨
        \result ≡ -1;
    assigns *ruid, *euid, *suid, \result;
    assigns *ruid \from \nothing;
    assigns *euid \from \nothing;
    assigns *suid \from \nothing;
    assigns \result
      \from (indirect: ruid), (indirect: euid), (indirect: suid);
 */
int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: ruid), (indirect: euid), (indirect: suid);
 */
int setresuid(uid_t ruid, uid_t euid, uid_t suid);

/*@ requires valid_rgid: \valid(rgid);
    requires valid_egid: \valid(sgid);
    requires valid_sgid: \valid(egid);
    ensures
      initialization: result_ok_or_error:
        (\result ≡ 0 ∧ \initialized(\old(rgid)) ∧
         \initialized(\old(egid)) ∧ \initialized(\old(sgid))) ∨
        \result ≡ -1;
    assigns *rgid, *egid, *sgid, \result;
    assigns *rgid \from \nothing;
    assigns *egid \from \nothing;
    assigns *sgid \from \nothing;
    assigns \result
      \from (indirect: rgid), (indirect: egid), (indirect: sgid);
 */
int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: rgid), (indirect: egid), (indirect: sgid);
 */
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

extern char *optarg;

int optind;

extern int opterr;

extern int optopt;

/*@ assigns \result, *optarg, optind, opterr, optopt;
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
 */
extern int getopt(int argc, char * const *argv, char const *optstring);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long(int argc, char * const *argv, char const *shortopts,
                       struct option const *longopts, int *longind);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long_only(int argc, char * const *argv,
                            char const *shortopts,
                            struct option const *longopts, int *longind);

int optind = 1;
int glob(char const *pattern, int flags,
         int (*errfunc)(char const *epath, int eerrno), glob_t *pglob);

void globfree(glob_t *pglob);

int glob(char const *pattern, int flags,
         int (*errfunc)(char const *epath, int eerrno), glob_t *pglob)
{
  int __retres;
  int tmp;
  unsigned int tmp_0;
  char **tmp_1;
  int tmp_4;
  tmp = Frama_C_interval(0,10);
  pglob->gl_pathc = (unsigned int)tmp;
  if (flags & (1 << 3)) tmp_0 = pglob->gl_offs; else tmp_0 = (unsigned int)0;
  size_t reserve_offs = tmp_0;
  size_t prev_len = (size_t)0;
  if (flags & (1 << 5)) 
    while (*(pglob->gl_pathv + (reserve_offs + prev_len))) prev_len ++;
  if (flags & (1 << 5)) tmp_1 = pglob->gl_pathv; else tmp_1 = (char **)0;
  char **path = tmp_1;
  if (pglob->gl_pathc == (unsigned int)0) 
    if (flags & (1 << 4)) {
      pglob->gl_pathv = (char **)realloc((void *)path,
                                         ((reserve_offs + prev_len) + (size_t)2) * sizeof(char *));
      if (! pglob->gl_pathv) {
        __retres = 1;
        goto return_label;
      }
      {
        size_t i = (size_t)0;
        while (i < reserve_offs) {
          *(pglob->gl_pathv + i) = (char *)0;
          i ++;
        }
      }
      *(pglob->gl_pathv + (reserve_offs + prev_len)) = (char *)pattern;
      *(pglob->gl_pathv + ((reserve_offs + prev_len) + (size_t)1)) = (char *)0;
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = 3;
      goto return_label;
    }
  pglob->gl_pathv = (char **)realloc((void *)path,
                                     (((reserve_offs + prev_len) + pglob->gl_pathc) + (size_t)1) * sizeof(char *));
  if (! pglob->gl_pathv) {
    __retres = 1;
    goto return_label;
  }
  {
    size_t i_0 = (size_t)0;
    while (i_0 < reserve_offs) {
      *(pglob->gl_pathv + i_0) = (char *)0;
      i_0 ++;
    }
  }
  {
    size_t i_1 = (size_t)0;
    while (i_1 < pglob->gl_pathc) {
      *(pglob->gl_pathv + ((reserve_offs + prev_len) + i_1)) = (char *)"glob result";
      i_1 ++;
    }
  }
  *(pglob->gl_pathv + ((prev_len + reserve_offs) + pglob->gl_pathc)) = (char *)0;
  tmp_4 = Frama_C_nondet(0,1);
  if (tmp_4) {
    __retres = 0;
    goto return_label;
  }
  else {
    if (errfunc) {
      int tmp_3;
      int tmp_2;
      tmp_2 = Frama_C_interval(0,255);
      tmp_3 = (*errfunc)("glob.c error path",tmp_2);
      int res = tmp_3;
      if (res) {
        __retres = 2;
        goto return_label;
      }
      else 
        if (flags & (1 << 0)) {
          __retres = 2;
          goto return_label;
        }
    }
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

void globfree(glob_t *pglob)
{
  if (pglob->gl_pathc > (unsigned int)0) free((void *)pglob->gl_pathv);
  return;
}

intmax_t imaxabs(intmax_t c);

imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

/*@ assigns \result, *(endptr + (..)), __fc_errno;
    assigns \result \from *(nptr + (..)), base;
    assigns *(endptr + (..)) \from *(nptr + (..)), base;
    assigns __fc_errno \from *(nptr + (..)), base;
 */
extern intmax_t strtoimax(char const * restrict nptr,
                          char ** restrict endptr, int base);

/*@ requires abs_representable: c > -9223372036854775807LL - 1LL;
    ensures positive_result: \result ≥ 0.;
    ensures
      equal_magnitude_result: \result ≡ \old(c) ∨ \result ≡ -\old(c);
    ensures logical_abs_result: \result ≡ \abs(\old(c));
    assigns \result;
    assigns \result \from c;
 */
intmax_t imaxabs(intmax_t c)
{
  intmax_t __retres;
  if (c > (intmax_t)0) {
    __retres = c;
    goto return_label;
  }
  else {
    __retres = - c;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires no_div_by_zero: denom ≢ 0;
    requires no_overflow: denom ≢ -1 ∨ (intmax_t)(-numer) ≢ numer;
    ensures correct_div: \result.quot ≡ \old(numer) / \old(denom);
    ensures correct_mod: \result.rem ≡ \old(numer) % \old(denom);
    assigns \result;
    assigns \result \from numer, denom;
 */
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom)
{
  imaxdiv_t r;
  r.quot = numer / denom;
  r.rem = numer % denom;
  return r;
}

extern struct lconv *__fc_locale;

extern char *__fc_locale_names[512];

char *setlocale(int category, char const *locale);

struct lconv *localeconv(void);

struct lconv __C_locale =
  {.decimal_point = (char *)".",
   .thousands_sep = (char *)"",
   .grouping = (char *)"",
   .int_curr_symbol = (char *)"",
   .currency_symbol = (char *)"",
   .mon_decimal_point = (char *)"",
   .mon_thousands_sep = (char *)"",
   .mon_grouping = (char *)"",
   .positive_sign = (char *)"",
   .negative_sign = (char *)"",
   .int_frac_digits = (char)127,
   .frac_digits = (char)127,
   .p_cs_precedes = (char)127,
   .p_sep_by_space = (char)127,
   .n_cs_precedes = (char)127,
   .n_sep_by_space = (char)127,
   .p_sign_posn = (char)127,
   .n_sign_posn = (char)127,
   .int_p_cs_precedes = (char)127,
   .int_p_sep_by_space = (char)127,
   .int_n_cs_precedes = (char)127,
   .int_n_sep_by_space = (char)127,
   .int_p_sign_posn = (char)127,
   .int_n_sign_posn = (char)127};
struct lconv *__frama_c_locale = & __C_locale;
char const *__frama_c_locale_names[512] = {"C"};
/*@ requires
      locale_null_or_valid_string:
        locale ≡ \null ∨ valid_read_string(locale);
    ensures
      result_null_or_locale_name:
        \result ≡ \null ∨
        (\valid(\result) ∧ (∃ ℤ i; \result ≡ __fc_locale_names[i]));
    assigns __fc_locale, \result;
    assigns __fc_locale \from category, *(locale + (..));
    assigns \result \from __fc_locale, category, *(locale + (..));
 */
char *setlocale(int category, char const *locale)
{
  char *__retres;
  if ((int)*locale == 'C') {
    __frama_c_locale = & __C_locale;
    __retres = (char *)__frama_c_locale_names[0];
    goto return_label;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ ensures result_current_locale: \result ≡ __fc_locale;
    assigns \result;
    assigns \result \from __fc_locale;
 */
struct lconv *localeconv(void)
{
  return __frama_c_locale;
}

/*@ assigns \result;
    assigns \result \from x;
    
    behavior nan:
      assumes is_nan: \is_NaN(x);
      ensures fp_nan: \result ≡ 0;
    
    behavior inf:
      assumes is_infinite: ¬\is_NaN(x) ∧ ¬\is_finite(x);
      ensures fp_infinite: \result ≡ 1;
    
    behavior zero:
      assumes is_a_zero: x ≡ 0.0;
      ensures fp_zero: \result ≡ 2;
    
    behavior subnormal:
      assumes is_finite: \is_finite(x);
      assumes
        is_subnormal:
          (x > 0.0 ∧ x < 0x1p-126) ∨ (x < 0.0 ∧ x > -0x1p-126);
      ensures fp_subnormal: \result ≡ 3;
    
    behavior normal:
      assumes is_finite: \is_finite(x);
      assumes not_subnormal: x ≤ -0x1p-126 ∨ x ≥ 0x1p-126;
      ensures fp_normal: \result ≡ 4;
    
    complete behaviors normal, subnormal, zero, inf, nan;
    disjoint behaviors normal, subnormal, zero, inf, nan;
 */
int __fc_fpclassifyf(float x);

/*@ assigns \result;
    assigns \result \from x;
    
    behavior nan:
      assumes is_nan: \is_NaN(x);
      ensures fp_nan: \result ≡ 0;
    
    behavior inf:
      assumes is_infinite: ¬\is_NaN(x) ∧ ¬\is_finite(x);
      ensures fp_infinite: \result ≡ 1;
    
    behavior zero:
      assumes is_a_zero: x ≡ 0.0;
      ensures fp_zero: \result ≡ 2;
    
    behavior subnormal:
      assumes is_finite: \is_finite(x);
      assumes
        is_subnormal:
          (x > 0.0 ∧ x < 0x1p-1022) ∨ (x < 0.0 ∧ x > -0x1p-1022);
      ensures fp_subnormal: \result ≡ 3;
    
    behavior normal:
      assumes is_finite: \is_finite(x);
      assumes not_subnormal: x ≤ -0x1p-1022 ∨ x ≥ 0x1p-1022;
      ensures fp_normal: \result ≡ 4;
    
    complete behaviors normal, subnormal, zero, inf, nan;
    disjoint behaviors normal, subnormal, zero, inf, nan;
 */
int __fc_fpclassify(double x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double acos(double x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float acosf(float x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double acosl(long double x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double asin(double x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float asinf(float x);

/*@ requires in_domain: \is_finite(x) ∧ \abs(x) ≤ 1;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double asinl(long double x);

/*@ requires number_arg: ¬\is_NaN(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1.571 ≤ \result ≤ 1.571;
    assigns \result;
    assigns \result \from x;
 */
extern float atanf(float x);

/*@ requires number_arg: ¬\is_NaN(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1.571 ≤ \result ≤ 1.571;
    assigns \result;
    assigns \result \from x;
 */
extern double atan(double x);

/*@ requires number_arg: ¬\is_NaN(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1.571 ≤ \result ≤ 1.571;
    assigns \result;
    assigns \result \from x;
 */
extern long double atanl(long double x);

/*@ requires number_args: ¬\is_NaN(x) ∧ ¬\is_NaN(y);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x, y;
 */
extern double atan2(double y, double x);

/*@ requires number_args: ¬\is_NaN(x) ∧ ¬\is_NaN(y);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x, y;
 */
extern float atan2f(float y, float x);

/*@ requires number_args: ¬\is_NaN(x) ∧ ¬\is_NaN(y);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x, y;
 */
extern long double atan2l(long double y, long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double cos(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float cosf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double cosl(long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double sin(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float sinf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    ensures result_domain: -1. ≤ \result ≤ 1.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double sinl(long double x);

/*@ requires not_infinity: ¬(infinite_arg: \is_infinite(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns __fc_errno, \result;
    assigns __fc_errno \from x;
    assigns \result \from x;
    
    behavior zero:
      assumes zero_arg: \is_finite(x) ∧ x ≡ 0.;
      ensures zero_res: \is_finite(\result) ∧ \result ≡ \old(x);
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    behavior finite_non_zero:
      assumes finite_arg: \is_finite(x) ∧ x ≢ 0.;
      ensures finite_result: \is_finite(\result);
      ensures
        maybe_error: __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ≡ 34;
    
    complete behaviors finite_non_zero, zero;
    disjoint behaviors finite_non_zero, zero;
 */
extern double tan(double x);

/*@ requires not_infinity: ¬(infinite_arg: \is_infinite(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns __fc_errno, \result;
    assigns __fc_errno \from x;
    assigns \result \from x;
    
    behavior zero:
      assumes zero_arg: \is_finite(x) ∧ x ≡ 0.;
      ensures zero_res: \is_finite(\result) ∧ \result ≡ \old(x);
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    behavior finite_non_zero:
      assumes finite_arg: \is_finite(x) ∧ x ≢ 0.;
      ensures finite_result: \is_finite(\result);
      ensures
        maybe_error: __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ≡ 34;
    
    complete behaviors finite_non_zero, zero;
    disjoint behaviors finite_non_zero, zero;
 */
extern float tanf(float x);

/*@ ensures
      maybe_error:
        __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ≡ 33 ∨
        __fc_errno ≡ 34;
    assigns __fc_errno, \result;
    assigns __fc_errno \from x;
    assigns \result \from x;
 */
extern long double tanl(long double x);

/*@ requires in_domain: \is_finite(x) ∧ x ≥ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double acosh(double x);

/*@ requires in_domain: \is_finite(x) ∧ x ≥ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float acoshf(float x);

/*@ requires in_domain: \is_finite(x) ∧ x ≥ 1;
    ensures positive_result: \is_finite(\result) ∧ \result ≥ 0;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double acoshl(long double x);

/*@ requires
      not_overflow:
        ¬(overflow_arg: \is_finite(x) ∧ x > 0x1.62e42fefa39efp+9);
    requires not_plus_infinity: ¬(plus_infinity_arg: \is_plus_infinity(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns __fc_errno, \result;
    assigns __fc_errno \from x;
    assigns \result \from x;
    
    behavior normal:
      assumes finite_arg: \is_finite(x);
      assumes
        domain_arg: x ≥ -0x1.74910d52d3051p9 ∧ x ≤ 0x1.62e42fefa39efp+9;
      ensures res_finite: \is_finite(\result);
      ensures positive_result: \result > 0.;
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    behavior underflow:
      assumes underflow_arg: \is_finite(x) ∧ x < -0x1.74910d52d3051p9;
      ensures zero_res: \result ≡ 0.;
      ensures errno_set: __fc_errno ≡ 34;
    
    behavior minus_infinity:
      assumes plus_infinity_arg: \is_minus_infinity(x);
      ensures zero_result: \is_finite(\result) ∧ \result ≡ 0.;
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    complete behaviors minus_infinity, underflow, normal;
    disjoint behaviors minus_infinity, underflow, normal;
 */
extern double exp(double x);

/*@ requires
      not_overflow: ¬(overflow_arg: \is_finite(x) ∧ x > 0x1.62e42ep+6);
    requires not_plus_infinity: ¬(plus_infinity_arg: \is_plus_infinity(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns __fc_errno, \result;
    assigns __fc_errno \from x;
    assigns \result \from x;
    
    behavior normal:
      assumes finite_arg: \is_finite(x);
      assumes domain_arg: x ≥ -0x1.9fe368p6 ∧ x ≤ 0x1.62e42ep+6;
      ensures res_finite: \is_finite(\result);
      ensures positive_result: \result > 0.;
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    behavior underflow:
      assumes underflow_arg: \is_finite(x) ∧ x < -0x1.9fe368p6;
      ensures zero_res: \result ≡ 0.;
      ensures errno_set: __fc_errno ≡ 34;
    
    behavior minus_infinity:
      assumes plus_infinity_arg: \is_minus_infinity(x);
      ensures zero_result: \is_finite(\result) ∧ \result ≡ 0.;
      ensures no_error: __fc_errno ≡ \old(__fc_errno);
      assigns \result;
      assigns \result \from x;
    
    complete behaviors minus_infinity, underflow, normal;
    disjoint behaviors minus_infinity, underflow, normal;
 */
extern float expf(float x);

/*@ requires valid_exp: \valid(exp);
    requires
      not_infinite:
        ¬(infinite_arg: \is_plus_infinity(x) ∨ \is_minus_infinity(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns \result, *exp;
    assigns \result \from x;
    assigns *exp \from x;
    
    behavior normal:
      assumes finite_arg: \is_finite(x);
      assumes arg_nonzero: x ≢ 0.0;
      ensures finite_result: \is_finite(\result);
      ensures bounded_result: 0.5 ≤ \result < 1.0;
      ensures initialization: exp: \initialized(\old(exp));
    
    behavior zero:
      assumes zero_arg: \is_finite(x) ∧ x ≡ 0.;
      ensures finite_result: \is_finite(\result);
      ensures zero_result: \result ≡ 0.0;
      ensures initialization: exp: \initialized(\old(exp));
      ensures zero_exp: *\old(exp) ≡ 0;
    
    complete behaviors zero, normal;
    disjoint behaviors zero, normal;
 */
extern double frexp(double x, int *exp);

/*@ requires valid_exp: \valid(exp);
    requires
      not_infinite:
        ¬(infinite_arg: \is_plus_infinity(x) ∨ \is_minus_infinity(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns \result, *exp;
    assigns \result \from x;
    assigns *exp \from x;
    
    behavior normal:
      assumes finite_arg: \is_finite(x);
      assumes arg_nonzero: x ≢ 0.0;
      ensures finite_result: \is_finite(\result);
      ensures bounded_result: 0.5 ≤ \result < 1.0;
      ensures initialization: exp: \initialized(\old(exp));
    
    behavior zero:
      assumes zero_arg: \is_finite(x) ∧ x ≡ 0.;
      ensures finite_result: \is_finite(\result);
      ensures zero_result: \result ≡ \old(x);
      ensures initialization: exp: \initialized(\old(exp));
      ensures zero_exp: *\old(exp) ≡ 0;
    
    complete behaviors zero, normal;
    disjoint behaviors zero, normal;
 */
extern float frexpf(float x, int *exp);

/*@ requires valid_exp: \valid(exp);
    requires
      not_infinite:
        ¬(infinite_arg: \is_plus_infinity(x) ∨ \is_minus_infinity(x));
    requires not_nan: ¬(nan_arg: \is_NaN(x));
    assigns \result, *exp;
    assigns \result \from x;
    assigns *exp \from x;
    
    behavior normal:
      assumes finite_arg: \is_finite(x);
      assumes arg_nonzero: x ≢ 0.0;
      ensures finite_result: \is_finite(\result);
      ensures bounded_result: 0.5 ≤ \result < 1.0;
      ensures initialization: exp: \initialized(\old(exp));
    
    behavior zero:
      assumes zero_arg: \is_finite(x) ∧ x ≡ 0.;
      ensures finite_result: \is_finite(\result);
      ensures zero_result: \result ≡ \old(x);
      ensures initialization: exp: \initialized(\old(exp));
      ensures zero_exp: *\old(exp) ≡ 0;
    
    complete behaviors zero, normal;
    disjoint behaviors zero, normal;
 */
extern long double frexpl(long double x, int *exp);

/*@ requires
      finite_logic_res:
        \is_finite((double)(x * pow((double)2.0d, (double)exp)));
    ensures finite_result: \is_finite(\result);
    ensures
      __fc_errno: __fc_errno ≡ 34 ∨ __fc_errno ≡ \old(__fc_errno);
    assigns __fc_errno, \result;
    assigns __fc_errno \from x, exp;
    assigns \result \from x, exp;
 */
extern double ldexp(double x, int exp);

/*@ requires
      finite_logic_res:
        \is_finite((float)(x *
                           pow((double)((float)2.0f), (double)((float)exp))));
    ensures finite_result: \is_finite(\result);
    ensures
      __fc_errno: __fc_errno ≡ 34 ∨ __fc_errno ≡ \old(__fc_errno);
    assigns __fc_errno, \result;
    assigns __fc_errno \from x, exp;
    assigns \result \from x, exp;
 */
extern float ldexpf(float x, int exp);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double log(double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float logf(float x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double logl(long double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double log10(double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float log10f(float x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double log10l(long double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double log2(double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float log2f(float x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x > 0;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double log2l(long double x);

double fabs(double x);

float fabsf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures res_finite: \is_finite(\result);
    ensures positive_result: \result ≥ 0.;
    ensures
      equal_magnitude_result: \result ≡ \old(x) ∨ \result ≡ -\old(x);
    assigns \result;
    assigns \result \from x;
 */
extern long double fabsl(long double x);

/*@ requires finite_logic_res: \is_finite(pow(x, y));
    ensures finite_result: \is_finite(\result);
    ensures
      __fc_errno: __fc_errno ≡ 34 ∨ __fc_errno ≡ \old(__fc_errno);
    assigns __fc_errno, \result;
    assigns __fc_errno \from x, y;
    assigns \result \from x, y;
 */
extern double pow(double x, double y);

/*@ requires finite_logic_res: \is_finite(pow((double)x, (double)y));
    ensures finite_result: \is_finite(\result);
    ensures
      __fc_errno: __fc_errno ≡ 34 ∨ __fc_errno ≡ \old(__fc_errno);
    assigns __fc_errno, \result;
    assigns __fc_errno \from x, y;
    assigns \result \from x, y;
 */
extern float powf(float x, float y);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x ≥ -0.;
    ensures finite_result: \is_finite(\result);
    ensures positive_result: \result ≥ -0.;
    ensures result_value: \result ≡ sqrt(\old(x));
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern double sqrt(double x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x ≥ -0.;
    ensures finite_result: \is_finite(\result);
    ensures positive_result: \result ≥ -0.;
    ensures result_value: \result ≡ sqrt((double)\old(x));
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern float sqrtf(float x);

/*@ requires finite_arg: \is_finite(x);
    requires arg_positive: x ≥ -0.;
    ensures finite_result: \is_finite(\result);
    ensures positive_result: \result ≥ -0.;
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x;
 */
extern long double sqrtl(long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern double ceil(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern float ceilf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern long double ceill(long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern double floor(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern float floorf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern long double floorl(long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern double round(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern float roundf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern long double roundl(long double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern double trunc(double x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern float truncf(float x);

/*@ requires finite_arg: \is_finite(x);
    ensures finite_result: \is_finite(\result);
    assigns \result;
    assigns \result \from x;
 */
extern long double truncl(long double x);

/*@ requires in_domain: ¬\is_NaN(x) ∧ ¬\is_NaN(y) ∧ y ≢ 0.;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x, y;
 */
extern double fmod(double x, double y);

/*@ requires in_domain: ¬\is_NaN(x) ∧ ¬\is_NaN(y) ∧ y ≢ 0.;
    ensures finite_result: \is_finite(\result);
    ensures no_error: __fc_errno ≡ \old(__fc_errno);
    assigns \result;
    assigns \result \from x, y;
 */
extern float fmodf(float x, float y);

/*@ requires tagp_valid_string: valid_read_string(tagp);
    ensures result_is_nan: \is_NaN(\result);
    assigns \result;
    assigns \result \from (indirect: *(tagp + (0 ..)));
 */
extern double nan(char const *tagp);

/*@ requires tagp_valid_string: valid_read_string(tagp);
    ensures result_is_nan: \is_NaN(\result);
    assigns \result;
    assigns \result \from (indirect: *(tagp + (0 ..)));
 */
extern float nanf(char const *tagp);

/*@ requires tagp_valid_string: valid_read_string(tagp);
    ensures result_is_nan: \is_NaN(\result);
    assigns \result;
    assigns \result \from (indirect: *(tagp + (0 ..)));
 */
extern long double nanl(char const *tagp);

int __finitef(float f);

int __finite(double d);

/*@ logic float __fc_infinity(ℤ x) = \plus_infinity;
 */
/*@ logic float __fc_nan(ℤ x) = \NaN;

*/
/*@ ensures result_is_infinity: \is_plus_infinity(\result);
    assigns \result;
    assigns \result \from \nothing;
 */
extern float __fc_infinity(int x);

/*@ ensures result_is_nan: \is_NaN(\result);
    assigns \result;
    assigns \result \from \nothing;
 */
extern float __fc_nan(int x);

/*@ requires finite_arg: \is_finite(x);
    ensures res_finite: \is_finite(\result);
    ensures positive_result: \result ≥ 0.;
    ensures
      equal_magnitude_result: \result ≡ \old(x) ∨ \result ≡ -\old(x);
    assigns \result;
    assigns \result \from x;
 */
double fabs(double x)
{
  double __retres;
  if (x == 0.0) {
    __retres = 0.0;
    goto return_label;
  }
  if (x > 0.0) {
    __retres = x;
    goto return_label;
  }
  __retres = - x;
  return_label: return __retres;
}

/*@ requires finite_arg: \is_finite(x);
    ensures res_finite: \is_finite(\result);
    ensures positive_result: \result ≥ 0.;
    ensures
      equal_magnitude_result: \result ≡ \old(x) ∨ \result ≡ -\old(x);
    assigns \result;
    assigns \result \from x;
 */
float fabsf(float x)
{
  float __retres;
  if (x == 0.0f) {
    __retres = 0.0f;
    goto return_label;
  }
  else 
    if (x > 0.0f) {
      __retres = x;
      goto return_label;
    }
    else {
      __retres = - x;
      goto return_label;
    }
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from f;
    
    behavior finite:
      assumes isfinite_f: \is_finite(f);
      ensures nonzero_result: \result > 0 ∨ \result < 0;
    
    behavior nonfinite:
      assumes nonfinite_f: ¬\is_finite(f);
      ensures zero_result: \result ≡ 0;
    
    complete behaviors nonfinite, finite;
    disjoint behaviors nonfinite, finite;
 */
int __finitef(float f)
{
  int __retres;
  union __fc_u_finitef u;
  unsigned short usExp;
  u.f = f;
  usExp = (unsigned short)((int)u.w[1] & 0x7F80);
  usExp = (unsigned short)((int)usExp >> 7);
  __retres = ! ((int)usExp == 0xff);
  return __retres;
}

/*@ assigns \result;
    assigns \result \from d;
    
    behavior finite:
      assumes isfinite_d: \is_finite(d);
      ensures nonzero_result: \result > 0 ∨ \result < 0;
    
    behavior nonfinite:
      assumes nonfinite_d: ¬\is_finite(d);
      ensures zero_result: \result ≡ 0;
    
    complete behaviors nonfinite, finite;
    disjoint behaviors nonfinite, finite;
 */
int __finite(double d)
{
  int __retres;
  union __fc_u_finite u;
  unsigned short usExp;
  u.d = d;
  usExp = (unsigned short)((int)u.w[3] & 0x7F80);
  usExp = (unsigned short)((int)usExp >> 7);
  __retres = ! ((int)usExp == 0xff);
  return __retres;
}

/*@ assigns \nothing; */
extern void (*signal(int sig, void (*func)(int )))(int );

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern int raise(int sig);

/*@ requires valid_set: \valid(set);
    ensures initialization: set: \initialized(\old(set));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *set, \result;
    assigns *set \from \nothing;
    assigns \result \from \nothing;
 */
extern int sigemptyset(sigset_t *set);

/*@ requires valid_set: \valid(set);
    ensures initialization: set: \initialized(\old(set));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *set, \result;
    assigns *set \from \nothing;
    assigns \result \from \nothing;
 */
extern int sigfillset(sigset_t *set);

/*@ requires valid_set: \valid(set);
    requires initialization: set: \initialized(set);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *set, \result;
    assigns *set \from (indirect: signum);
    assigns \result \from signum;
 */
extern int sigaddset(sigset_t *set, int signum);

/*@ requires valid_set: \valid(set);
    requires initialization: set: \initialized(set);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *set, \result;
    assigns *set \from (indirect: signum);
    assigns \result \from signum;
 */
extern int sigdelset(sigset_t *set, int signum);

/*@ requires valid_read_set: \valid_read(set);
    requires initialization: set: \initialized(set);
    ensures
      result_found_not_found_or_error:
        \result ≡ 0 ∨ \result ≡ 1 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from *set, signum;
 */
extern int sigismember(sigset_t const *set, int signum);

struct sigaction __fc_sigaction[64 + 1];
struct sigaction *__fc_p_sigaction = __fc_sigaction;
/*@ requires valid_signal: 0 ≤ signum ≤ 64;
    requires valid_oldact_or_null: oldact ≡ \null ∨ \valid(oldact);
    requires valid_read_act_or_null: act ≡ \null ∨ \valid_read(act);
    requires separation: separated_acts: \separated(act, oldact);
    ensures
      act_changed:
        \old(act) ≡ \null ∨
        \subset(*(__fc_p_sigaction + \old(signum)), *\old(act));
    ensures
      oldact_assigned:
        \old(oldact) ≡ \null ∨
        *\old(oldact) ∈ *(__fc_p_sigaction + \old(signum));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *oldact, *(__fc_p_sigaction + signum), \result;
    assigns *oldact \from __fc_p_sigaction;
    assigns *(__fc_p_sigaction + signum) \from *act;
    assigns \result
      \from (indirect: signum), (indirect: act), (indirect: *act),
            (indirect: oldact), (indirect: *oldact);
 */
extern int sigaction(int signum, struct sigaction const * restrict act,
                     struct sigaction * restrict oldact);

/*@ requires valid_set_or_null: set ≡ \null ∨ \valid_read(set);
    requires valid_how: set ≢ \null ⇒ how ∈ {0, 2, 1};
    requires valid_oldset_or_null: oldset ≡ \null ∨ \valid(oldset);
    requires
      separation: (set ≡ oldset ≡ \null) ∨ \separated(set, oldset);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    ensures
      initialization: oldset_initialized:
        \old(oldset) ≢ \null ∧ \result ≡ 0 ⇒
        \initialized(\old(oldset));
    assigns \result, *oldset;
    assigns \result
      \from (indirect: how), (indirect: set), (indirect: oldset);
    assigns *oldset \from (indirect: how), (indirect: oldset);
 */
extern int sigprocmask(int how, sigset_t const * restrict set,
                       sigset_t * restrict oldset);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: pid), (indirect: sig);
 */
extern int kill(pid_t pid, int sig);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: pgrp), (indirect: sig);
 */
extern int killpg(pid_t pgrp, int sig);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    requires
      initialization: initialized_inputs:
        ∀ ℤ i;
          0 ≤ i < iovcnt ⇒
          \initialized(&(iov + i)->iov_base) ∧
          \initialized(&(iov + i)->iov_len);
    requires
      valid_iov:
        ∀ ℤ i;
          0 ≤ i < iovcnt ⇒
          \valid((char *)(&(iov + i)->iov_base) +
                 (0 .. (iov + i)->iov_len - 1));
    requires bounded_iovcnt: 0 ≤ iovcnt ≤ 1024;
    ensures
      result_error_or_read_bytes:
        \result ≡ -1 ∨
        (0 ≤ \result ≤
         \sum(0, \old(iovcnt) - 1, \lambda ℤ k; (\old(iov) + k)->iov_len));
    assigns {*((char *)(iov + i)->iov_base + j) |
             ℤ i, ℤ j; 0 ≤ i < iovcnt ∧ 0 ≤ j < (iov + i)->iov_len},
            \result;
    assigns
    {*((char *)(iov + i)->iov_base + j) |
     ℤ i, ℤ j; 0 ≤ i < iovcnt ∧ 0 ≤ j < (iov + i)->iov_len}
      \from (indirect: fd), (indirect: iovcnt), (indirect: __fc_fds[fd]);
    assigns \result
      \from (indirect: fd), (indirect: __fc_fds[fd]),
            (indirect: *(iov + (0 ..))), (indirect: iovcnt);
 */
extern ssize_t readv(int fd, struct iovec const *iov, int iovcnt);

/*@ requires valid_fd: 0 ≤ fd < 1024;
    requires
      initialization: initialized_inputs:
        ∀ ℤ i;
          0 ≤ i < iovcnt ⇒
          \initialized(&(iov + i)->iov_base) ∧
          \initialized(&(iov + i)->iov_len);
    requires valid_read_iov: \valid_read(iov + (0 .. iovcnt - 1));
    requires
      valid_read_iov_bases:
        ∀ ℤ i;
          0 ≤ i < iovcnt ⇒
          \valid_read((char *)(iov + i)->iov_base +
                      (0 .. (iov + i)->iov_len - 1));
    requires bounded_iovcnt: 0 ≤ iovcnt ≤ 1024;
    requires
      bounded_lengths:
        \sum(0, iovcnt - 1, \lambda ℤ k; (iov + k)->iov_len) ≤ 2147483647;
    ensures
      result_error_or_written_bytes:
        \result ≡ -1 ∨
        (0 ≤ \result ≤
         \sum(0, \old(iovcnt) - 1, \lambda ℤ k; (\old(iov) + k)->iov_len));
    assigns \result, __fc_fds[fd];
    assigns \result
      \from (indirect: fd), (indirect: __fc_fds[fd]),
            (indirect: *(iov + (0 ..))), (indirect: iovcnt);
    assigns __fc_fds[fd]
      \from (indirect: *(iov + (0 ..))), (indirect: iovcnt);
 */
extern ssize_t writev(int fd, struct iovec const *iov, int iovcnt);

/*@ ghost struct __fc_sockfds_type __fc_sockfds[1024]; */
/*@ ghost extern int __fc_socket_counter; */

/*@ ghost int volatile __fc_open_sock_fds; */
/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    ensures
      result_error_or_valid_new_sockfd:
        \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result, *((char *)addr + (0 .. *addrlen - 1)),
            __fc_sockfds[sockfd];
    assigns \result \from *addr, *addrlen, __fc_sockfds[sockfd];
    assigns *((char *)addr + (0 .. *addrlen - 1))
      \from *addr, *addrlen, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from *addr, *addrlen, __fc_sockfds[sockfd];
    
    behavior addr_null:
      assumes addr_is_null: addr ≡ \null;
      requires addrlen_should_be_null: addrlen ≡ \null;
      assigns \result, __fc_sockfds[sockfd];
      assigns \result \from __fc_sockfds[sockfd];
      assigns __fc_sockfds[sockfd] \from __fc_sockfds[sockfd];
    
    behavior addr_not_null:
      assumes addr_is_not_null: addr ≢ \null;
      requires valid_addrlen: \valid(addrlen);
      requires addr_has_room: \valid((char *)addr + (0 .. *addrlen - 1));
      ensures
        initialization: addr:
          \initialized((char *)\old(addr) + (0 .. *\old(addrlen) - 1));
    
    disjoint behaviors addr_not_null, addr_null;
 */
extern int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

/*@ requires valid_sockfd: sockfd: 0 ≤ sockfd < 1024;
    requires valid_read_addr: \valid_read((char *)addr + (0 .. addrlen - 1));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_sockfds[sockfd], \result;
    assigns __fc_sockfds[sockfd]
      \from sockfd, *addr, addrlen, __fc_sockfds[sockfd];
    assigns \result
      \from (indirect: sockfd), (indirect: *addr), (indirect: addrlen),
            (indirect: __fc_sockfds[sockfd]);
 */
extern int bind(int sockfd, struct sockaddr const *addr, socklen_t addrlen);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires valid_read_addr: \valid_read((char *)addr + (0 .. addrlen - 1));
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_sockfds[sockfd], \result;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], (indirect: sockfd), (indirect: addr),
            (indirect: *addr), (indirect: addrlen);
    assigns \result
      \from (indirect: __fc_sockfds[sockfd]), (indirect: sockfd),
            (indirect: addr), (indirect: *addr), (indirect: addrlen);
 */
extern int connect(int sockfd, struct sockaddr const *addr, socklen_t addrlen);

/*@ requires valid_sockfd: 0 ≤ socket < 1024;
    requires valid_address_len: \valid(address_len);
    requires initialization: address_len: \initialized(address_len);
    requires
      valid_address: \valid((char *)address + (0 .. *address_len - 1));
    ensures new_address_len: *\old(address_len) ≤ \old(*address_len);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *address_len, \result,
            *((char *)address + (0 .. *address_len - 1));
    assigns *address_len \from (indirect: socket), __fc_sockfds[socket];
    assigns \result
      \from (indirect: __fc_sockfds[socket]), (indirect: socket);
    assigns *((char *)address + (0 .. *address_len - 1))
      \from (indirect: __fc_sockfds[socket]), (indirect: socket);
 */
extern int getsockname(int socket, struct sockaddr * restrict address,
                       socklen_t * restrict address_len);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires valid_optlen: \valid(optlen);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *((char *)optval + (0 ..)), \result, *optlen;
    assigns *((char *)optval + (0 ..))
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            (indirect: *optlen), (indirect: optval),
            (indirect: __fc_sockfds[sockfd]);
    assigns \result
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            (indirect: *optlen), (indirect: optval),
            (indirect: __fc_sockfds[sockfd]);
    assigns *optlen
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            *optlen, (indirect: optval), (indirect: __fc_sockfds[sockfd]);
    
    behavior so_error:
      assumes optname_is_error: level ≡ 1 ∧ optname ≡ 4;
      requires valid_optlen: \valid(optlen);
      requires optlen_value: *optlen ≡ sizeof(int);
      requires valid_optval: \valid((int *)optval);
      assigns *((int *)optval), \result;
      assigns *((int *)optval)
        \from (indirect: sockfd), (indirect: optlen),
              (indirect: __fc_sockfds[sockfd]);
      assigns \result
        \from (indirect: sockfd), (indirect: optlen),
              (indirect: __fc_sockfds[sockfd]);
    
    behavior other_options:
      assumes optname_not_error: ¬(level ≡ 1 ∧ optname ≡ 4);
      requires
        optval_null_or_valid:
          optval ≡ \null ∨ \valid((char *)optval + (0 ..));
      assigns *((char *)optval + (0 ..)), \result, *optlen;
      assigns *((char *)optval + (0 ..))
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              (indirect: *optlen), (indirect: optval),
              (indirect: __fc_sockfds[sockfd]);
      assigns \result
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              (indirect: *optlen), (indirect: optval),
              (indirect: __fc_sockfds[sockfd]);
      assigns *optlen
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              *optlen, (indirect: optval), (indirect: __fc_sockfds[sockfd]);
    
    complete behaviors other_options, so_error;
    disjoint behaviors other_options, so_error;
 */
extern int getsockopt(int sockfd, int level, int optname, void *optval,
                      socklen_t *optlen);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result \from sockfd, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from sockfd, backlog, __fc_sockfds[sockfd];
 */
extern int listen(int sockfd, int backlog);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires valid_buffer_length: \valid((char *)buf + (0 .. len - 1));
    ensures
      result_error_or_received_length:
        \result ≡ -1 ∨ (0 ≤ \result ≤ \old(len));
    ensures
      initialization: \initialized((char *)\old(buf) + (0 .. \result - 1));
    assigns *((char *)buf + (0 .. len - 1)), __fc_sockfds[sockfd], \result;
    assigns *((char *)buf + (0 .. len - 1))
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd]
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns \result \from sockfd, len, flags, __fc_sockfds[sockfd];
 */
extern ssize_t recv(int sockfd, void *buf, size_t len, int flags);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires valid_buffer_length: \valid((char *)buf + (0 .. len - 1));
    requires
      valid_addrbuf_or_null: initialization:
        (\valid(addrbuf_len) ∧ \initialized(addrbuf_len) ∧
         \valid((char *)addrbuf + (0 .. *addrbuf_len - 1))) ∨
        (addrbuf ≡ \null ∧ addrbuf_len ≡ \null);
    ensures
      result_error_or_received_length:
        \result ≡ -1 ∨ (0 ≤ \result ≤ \old(len));
    ensures
      initialization: buf:
        \initialized((char *)\old(buf) + (0 .. \result - 1));
    ensures
      initialization: addrbuf:
        \old(addrbuf) ≢ \null ⇒
        \initialized((char *)\old(addrbuf) + (0 .. \old(*addrbuf_len) - 1));
    assigns *((char *)buf + (0 .. len - 1)), __fc_sockfds[sockfd], \result,
            *addrbuf_len, *((char *)addrbuf + (0 .. \old(*addrbuf_len) - 1));
    assigns *((char *)buf + (0 .. len - 1))
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd]
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns \result \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns *addrbuf_len
      \from (indirect: sockfd), (indirect: len), (indirect: flags),
            __fc_sockfds[sockfd];
    assigns *((char *)addrbuf + (0 .. \old(*addrbuf_len) - 1))
      \from (indirect: sockfd), (indirect: len), (indirect: flags),
            __fc_sockfds[sockfd];
 */
extern ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *addrbuf, socklen_t *addrbuf_len);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires
      msg_control_has_room:
        \valid((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1));
    requires
      msg_iov_has_room: \valid(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1));
    requires
      msg_name_null_or_has_room:
        hdr->msg_name ≡ \null ∨
        \valid((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1));
    ensures
      result_error_or_received_length:
        \result ≡ -1 ∨ (0 ≤ \result ≤ \old(hdr)->msg_iovlen);
    assigns *((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1)),
            hdr->msg_namelen,
            *((char *)(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1))->iov_base +
              (0 ..)),
            *((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1)),
            \result, hdr->msg_controllen, hdr->msg_flags,
            __fc_sockfds[sockfd];
    assigns *((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1))
      \from __fc_sockfds[sockfd];
    assigns hdr->msg_namelen \from __fc_sockfds[sockfd];
    assigns
    *((char *)(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1))->iov_base + (0 ..))
      \from __fc_sockfds[sockfd];
    assigns *((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1))
      \from __fc_sockfds[sockfd];
    assigns \result \from __fc_sockfds[sockfd];
    assigns hdr->msg_controllen \from __fc_sockfds[sockfd];
    assigns hdr->msg_flags \from __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from __fc_sockfds[sockfd];
 */
extern ssize_t recvmsg(int sockfd, struct msghdr *hdr, int flags);

/*@ requires available_sockfd: 0 ≤ sockfd < 1024;
    requires buf_len_ok: \valid_read((char *)buf + (0 .. len - 1));
    ensures
      error_or_chars_sent: \result ≡ -1 ∨ (0 ≤ \result ≤ \old(len));
    assigns __fc_errno, __fc_sockfds[sockfd], \result;
    assigns __fc_errno
      \from (indirect: sockfd), (indirect: __fc_sockfds[sockfd]),
            (indirect: *((char *)buf + (0 .. len))), flags;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], *((char *)buf + (0 .. len)), flags;
    assigns \result
      \from (indirect: sockfd), (indirect: __fc_sockfds[sockfd]),
            (indirect: *((char *)buf + (0 .. len))), (indirect: flags);
 */
extern ssize_t send(int sockfd, void const *buf, size_t len, int flags);

/*@ requires available_sockfd: 0 ≤ sockfd < 1024;
    requires valid_message: \valid_read(message);
    requires
      valid_msg_iov:
        \valid_read(message->msg_iov + (0 .. message->msg_iovlen - 1));
    ensures error_or_chars_sent: \result ≡ -1 ∨ 0 ≤ \result;
    assigns __fc_sockfds[sockfd], \result;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], (indirect: *message),
            (indirect: *(message->msg_iov + (0 .. message->msg_iovlen - 1))),
            (indirect: flags);
    assigns \result
      \from (indirect: sockfd), (indirect: __fc_sockfds[sockfd]),
            (indirect: *message),
            (indirect: *(message->msg_iov + (0 .. message->msg_iovlen - 1)));
 */
extern ssize_t sendmsg(int sockfd, struct msghdr const *message, int flags);

/*@ requires available_sockfd: 0 ≤ sockfd < 1024;
    requires buf_len_ok: \valid_read((char *)buf + (0 .. len - 1));
    ensures
      error_or_chars_sent: \result ≡ -1 ∨ (0 ≤ \result ≤ \old(len));
    assigns __fc_errno, __fc_sockfds[sockfd], \result;
    assigns __fc_errno
      \from (indirect: sockfd), (indirect: __fc_sockfds[sockfd]),
            (indirect: *((char *)buf + (0 .. len))), flags;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], *((char *)buf + (0 .. len)), flags;
    assigns \result
      \from (indirect: sockfd), (indirect: __fc_sockfds[sockfd]),
            (indirect: *((char *)buf + (0 .. len))), (indirect: flags);
 */
extern ssize_t sendto(int sockfd, void const *buf, size_t len, int flags,
                      struct sockaddr const *address, socklen_t address_len);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    requires
      optval_null_or_has_room:
        optval ≡ \null ∨ \valid_read((char *)optval + (0 .. optlen - 1));
    ensures result_error_or_ok: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result
      \from __fc_sockfds[sockfd], level, optname,
            *((char *)optval + (0 .. optlen - 1)), optlen;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], level, optname,
            *((char *)optval + (0 .. optlen - 1)), optlen;
 */
extern int setsockopt(int sockfd, int level, int optname, void const *optval,
                      socklen_t optlen);

/*@ requires valid_sockfd: 0 ≤ sockfd < 1024;
    ensures result_error_or_ok: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result \from how, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from how, __fc_sockfds[sockfd];
 */
extern int shutdown(int sockfd, int how);

/*@ ensures
      result_error_or_valid_new_sockfd:
        (0 ≤ \result < 1024) ∨ \result ≡ -1;
    assigns \result, __fc_socket_counter;
    assigns \result
      \from (indirect: domain), (indirect: type), (indirect: protocol),
            (indirect: __fc_socket_counter);
    assigns __fc_socket_counter
      \from (indirect: domain), (indirect: type), (indirect: protocol),
            __fc_socket_counter;
 */
extern int socket(int domain, int type, int protocol);

/*@ requires valid_socket_sector: \valid(sv + (0 .. 1));
    ensures result_error_or_ok: \result ≡ 0 ∨ \result ≡ -1;
    ensures initialization: sv: \initialized(\old(sv) + (0 .. 1));
    ensures valid_new_sockfd: sv0: 0 ≤ *(\old(sv) + 0) < 1024;
    ensures valid_new_sockfd: sv1: 0 ≤ *(\old(sv) + 1) < 1024;
    assigns \result, __fc_socket_counter, *(sv + (0 .. 1));
    assigns \result \from __fc_socket_counter;
    assigns __fc_socket_counter \from __fc_socket_counter;
    assigns *(sv + (0 .. 1)) \from __fc_socket_counter;
 */
extern int socketpair(int domain, int type, int protocol, int sv[2]);

struct in6_addr const in6addr_any;

struct in6_addr const in6addr_loopback;

/*@ assigns \result;
    assigns \result \from arg; */
extern uint32_t htonl(uint32_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint16_t htons(uint16_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint32_t ntohl(uint32_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint16_t ntohs(uint16_t arg);

/*@ requires valid_arg: valid_read_string(arg);
    assigns \result;
    assigns \result \from (indirect: *(arg + (0 ..)));
 */
extern in_addr_t inet_addr(char const *arg);

char volatile __fc_inet_ntoa_array[16];
char *__fc_inet_ntoa = (char *)(__fc_inet_ntoa_array);
/*@ ensures result_static_string: \result ≡ __fc_inet_ntoa;
    ensures result_null_terminated: *(\result + 15) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result, *(__fc_inet_ntoa + (0 ..));
    assigns \result \from (indirect: arg), __fc_inet_ntoa;
    assigns *(__fc_inet_ntoa + (0 ..)) \from (indirect: arg);
 */
extern char *inet_ntoa(struct in_addr arg);

/*@ assigns \result, *(dst + (0 .. size - 1));
    assigns \result \from dst, af, *((char *)src + (0 ..));
    assigns *(dst + (0 .. size - 1)) \from af, *((char *)src + (0 ..));
 */
extern char const *inet_ntop(int af, void const *src, char *dst,
                             socklen_t size);

/*@ assigns \result, *((char *)dst + (0 ..));
    assigns \result \from af, *(src + (..));
    assigns *((char *)dst + (0 ..)) \from af, *(src + (0 ..));
 */
extern int inet_pton(int af, char const *src, void *dst);

int h_errno;
/*@ requires addrinfo_valid: \valid(addrinfo);
    ensures allocation: \allocable(\old(addrinfo));
    assigns \nothing;
    frees addrinfo;
 */
extern void freeaddrinfo(struct addrinfo *addrinfo);

char const *__fc_gai_strerror = "<error message reported by gai_strerror>";
/*@ ensures result_string: \result ≡ __fc_gai_strerror;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from (indirect: errcode), __fc_gai_strerror;
 */
extern char const *gai_strerror(int errcode);

int getaddrinfo(char const * restrict nodename,
                char const * restrict servname,
                struct addrinfo const * restrict hints,
                struct addrinfo ** restrict res);

struct hostent *gethostbyname(char const *name);

static unsigned int volatile getaddrinfo_net_state;
/*@ requires
      nodename_string: nodename ≡ \null ∨ valid_read_string(nodename);
    requires
      servname_string: servname ≡ \null ∨ valid_read_string(servname);
    requires hints_option: hints ≡ \null ∨ \valid_read(hints);
    requires valid_res: \valid(res);
    assigns *res, \result, __fc_errno;
    assigns *res
      \from (indirect: nodename), (indirect: servname), (indirect: hints);
    assigns \result
      \from (indirect: nodename), (indirect: servname), (indirect: hints);
    assigns __fc_errno
      \from (indirect: nodename), (indirect: servname), (indirect: hints);
    allocates *\old(res);
    
    behavior empty_request:
      assumes empty: nodename ≡ \null ∧ servname ≡ \null;
      ensures no_name: \result ≡ -2;
      assigns \result;
      assigns \result \from (indirect: nodename), (indirect: servname);
    
    behavior normal_request:
      assumes has_name: nodename ≢ \null ∨ servname ≢ \null;
      ensures
        initialization: allocation: success_or_error:
          (\result ≡ 0 ∧
           \fresh{Old, Here}(*\old(res),sizeof(*\old(res))) ∧
           \initialized(*\old(res))) ∨
          \result ≡ -3 ∨ \result ≡ -1 ∨ \result ≡ -4 ∨
          \result ≡ -6 ∨ \result ≡ -10 ∨ \result ≡ -8 ∨
          \result ≡ -7 ∨ \result ≡ -11;
    
    complete behaviors normal_request, empty_request;
    disjoint behaviors normal_request, empty_request;
 */
int getaddrinfo(char const * restrict nodename,
                char const * restrict servname,
                struct addrinfo const * restrict hints,
                struct addrinfo ** restrict res)
{
  int __retres;
  if (nodename == (char const *)0) 
    if (servname == (char const *)0) {
      __retres = -2;
      goto return_label;
    }
  switch (getaddrinfo_net_state) {
    case (unsigned int)0: __retres = -1;
    goto return_label;
    case (unsigned int)1: __retres = -3;
    goto return_label;
    case (unsigned int)2: __retres = -4;
    goto return_label;
    case (unsigned int)3: __retres = -6;
    goto return_label;
    case (unsigned int)5: __retres = -8;
    goto return_label;
    case (unsigned int)6: __retres = -7;
    goto return_label;
    case (unsigned int)7:
    {
      __fc_errno = 5;
      __retres = -11;
      goto return_label;
    }
    default:
    {
      struct addrinfo *tmp_0;
      struct sockaddr *tmp_2;
      int tmp_3;
      struct addrinfo *ai = malloc(sizeof(*tmp_0));
      if (! ai) {
        __retres = -10;
        goto return_label;
      }
      struct sockaddr *sa = malloc(sizeof(*tmp_2));
      if (! sa) {
        __retres = -10;
        goto return_label;
      }
      tmp_3 = Frama_C_interval(0,43);
      sa->sa_family = (sa_family_t)tmp_3;
      /*@ slevel 15; */
      {
        int i = 0;
        while (i < 14) {
          {
            int tmp_4;
            tmp_4 = Frama_C_interval(-128,127);
            sa->sa_data[i] = (char)tmp_4;
          }
          i ++;
        }
      }
      /*@ slevel default; */
      ai->ai_flags = 0;
      ai->ai_family = (int)sa->sa_family;
      ai->ai_socktype = Frama_C_interval(0,5);
      ai->ai_protocol = Frama_C_interval(0,IPPROTO_MAX);
      ai->ai_addrlen = sizeof(*sa);
      ai->ai_addr = sa;
      ai->ai_canonname = (char *)malloc((size_t)6);
      if (! ai->ai_canonname) {
        __retres = -10;
        goto return_label;
      }
      strcpy(ai->ai_canonname,"dummy");
      ai->ai_next = (struct addrinfo *)0;
      *res = ai;
      __retres = 0;
      goto return_label;
    }
  }
  return_label: return __retres;
}

struct __fc_gethostbyname __fc_ghbn;
static int res_search(char const *dname, int rec_class, int type,
                      char *answer, int anslen)
{
  int tmp;
  {
    int i = 0;
    while (i < anslen - 1) {
      *(answer + i) = Frama_C_char_interval((char)(-128),(char)127);
      i ++;
    }
  }
  *(answer + (anslen - 1)) = (char)0;
  tmp = Frama_C_interval(-1,anslen);
  return tmp;
}

struct hostent *gethostbyname(char const *name)
{
  struct hostent *__retres;
  char buf[128];
  char const *cp;
  int n;
  int tmp;
  __fc_ghbn.host.h_addrtype = 2;
  __fc_ghbn.host.h_length = (int)sizeof(struct in_addr);
  if ((int)*name >= '0') 
    if ((int)*name <= '9') {
      cp = name;
      while (1) {
        if (! *cp) {
          struct in_addr addr;
          cp --;
          ;
          if ((int)*cp == '.') break;
          addr.s_addr = inet_addr(name);
          if (addr.s_addr == 0xffffffff) {
            __retres = (struct hostent *)0;
            goto return_label;
          }
          memcpy((void *)(__fc_ghbn.host_addr),(void const *)(& addr),
                 (size_t)__fc_ghbn.host.h_length);
          strncpy(__fc_ghbn.hostbuf,name,(size_t)(128 - 1));
          __fc_ghbn.hostbuf[128 - 1] = (char)'\000';
          __fc_ghbn.host.h_name = __fc_ghbn.hostbuf;
          __fc_ghbn.host.h_aliases = __fc_ghbn.host_aliases;
          __fc_ghbn.host_aliases[0] = (char *)0;
          __fc_ghbn.h_addr_ptrs[0] = (char *)(__fc_ghbn.host_addr);
          __fc_ghbn.h_addr_ptrs[1] = (char *)0;
          __fc_ghbn.host.h_addr_list = __fc_ghbn.h_addr_ptrs;
          __retres = & __fc_ghbn.host;
          goto return_label;
        }
        if ((int)*cp < '0') break;
        else 
          if ((int)*cp > '9') break;
          else 
            if ((int)*cp != '.') break;
        cp ++;
      }
    }
  n = res_search(name,1,1,buf,(int)sizeof(buf));
  if (n < 0) {
    __retres = (struct hostent *)0;
    goto return_label;
  }
  tmp = Frama_C_nondet(0,1);
  if (tmp) {
    __retres = (struct hostent *)0;
    goto return_label;
  }
  else {
    struct in_addr addr_0;
    addr_0.s_addr = inet_addr(name);
    memcpy((void *)(__fc_ghbn.host_addr),(void const *)(& addr_0),
           (size_t)__fc_ghbn.host.h_length);
    strncpy(__fc_ghbn.hostbuf,name,(size_t)(128 - 1));
    __fc_ghbn.hostbuf[128 - 1] = (char)'\000';
    __fc_ghbn.host.h_name = __fc_ghbn.hostbuf;
    __fc_ghbn.host.h_aliases = __fc_ghbn.host_aliases;
    __fc_ghbn.host_aliases[0] = (char *)0;
    __fc_ghbn.h_addr_ptrs[0] = (char *)(__fc_ghbn.host_addr);
    __fc_ghbn.h_addr_ptrs[1] = (char *)0;
    __fc_ghbn.host.h_addr_list = __fc_ghbn.h_addr_ptrs;
    __retres = & __fc_ghbn.host;
    goto return_label;
  }
  return_label: return __retres;
}

struct in6_addr const in6addr_any = {.s6_addr = {(uint8_t)0}};
struct in6_addr const in6addr_loopback =
  {.s6_addr = {(uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)0,
               (uint8_t)1}};
char __fc_getpw_pw_name[64];
char __fc_getpw_pw_passwd[64];
char __fc_getpw_pw_gecos[64];
char __fc_getpw_pw_dir[64];
char __fc_getpw_pw_shell[64];
struct passwd __fc_pwd =
  {.pw_name = __fc_getpw_pw_name,
   .pw_passwd = __fc_getpw_pw_passwd,
   .pw_uid = 0U,
   .pw_gid = 0U,
   .pw_gecos = __fc_getpw_pw_gecos,
   .pw_dir = __fc_getpw_pw_dir,
   .pw_shell = __fc_getpw_pw_shell};
struct passwd *__fc_p_pwd = & __fc_pwd;
/*@ requires valid_name: valid_read_string(name);
    ensures
      result_null_or_internal_struct:
        \result ≡ \null ∨ \result ≡ __fc_p_pwd;
    assigns \result, __fc_pwd;
    assigns \result \from __fc_p_pwd, (indirect: *(name + (0 ..)));
    assigns __fc_pwd \from (indirect: *(name + (0 ..)));
 */
extern struct passwd *getpwnam(char const *name);

/*@ ensures
      result_null_or_internal_struct:
        \result ≡ \null ∨ \result ≡ __fc_p_pwd;
    assigns \result, __fc_pwd;
    assigns \result \from __fc_p_pwd, (indirect: uid);
    assigns __fc_pwd \from (indirect: uid);
 */
extern struct passwd *getpwuid(uid_t uid);

int getpwnam_r(char const *name, struct passwd *pwd, char *buf,
               size_t buflen, struct passwd **result);

int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf, size_t buflen,
               struct passwd **result);

static int __fc_getpw_init;
static int __fc_getpw_r(struct passwd *pwd, char *buf, size_t buflen,
                        struct passwd **result)
{
  int __retres;
  int tmp_2;
  if (! __fc_getpw_init) {
    __fc_getpw_init = 1;
    Frama_C_make_unknown(__fc_getpw_pw_name,(size_t)63);
    __fc_getpw_pw_name[63] = (char)0;
    Frama_C_make_unknown(__fc_getpw_pw_passwd,(size_t)63);
    __fc_getpw_pw_passwd[63] = (char)0;
    Frama_C_make_unknown(__fc_getpw_pw_gecos,(size_t)63);
    __fc_getpw_pw_gecos[63] = (char)0;
    Frama_C_make_unknown(__fc_getpw_pw_dir,(size_t)63);
    __fc_getpw_pw_dir[63] = (char)0;
    Frama_C_make_unknown(__fc_getpw_pw_shell,(size_t)63);
    __fc_getpw_pw_shell[63] = (char)0;
  }
  tmp_2 = Frama_C_interval(0,1);
  if (tmp_2) {
    int tmp;
    int tmp_0;
    int tmp_1;
    *result = (struct passwd *)0;
    tmp = Frama_C_interval(0,1);
    if (tmp) {
      __retres = 5;
      goto return_label;
    }
    tmp_0 = Frama_C_interval(0,1);
    if (tmp_0) {
      __retres = 24;
      goto return_label;
    }
    tmp_1 = Frama_C_interval(0,1);
    if (tmp_1) {
      __retres = 23;
      goto return_label;
    }
    __retres = 0;
    goto return_label;
  }
  else {
    size_t len;
    size_t remaining = buflen;
    len = strlen((char const *)__fc_pwd.pw_name);
    if (remaining <= len) {
      *result = (struct passwd *)0;
      __retres = 34;
      goto return_label;
    }
    strcpy(buf,(char const *)__fc_pwd.pw_name);
    *(buf + len) = (char)0;
    pwd->pw_name = buf;
    buf += len + (size_t)1;
    remaining -= len;
    len = strlen((char const *)__fc_pwd.pw_passwd);
    if (remaining <= len) {
      *result = (struct passwd *)0;
      __retres = 34;
      goto return_label;
    }
    strcpy(buf,(char const *)__fc_pwd.pw_passwd);
    *(buf + len) = (char)0;
    pwd->pw_passwd = buf;
    buf += len + (size_t)1;
    remaining -= len;
    len = strlen((char const *)__fc_pwd.pw_gecos);
    if (remaining <= len) {
      *result = (struct passwd *)0;
      __retres = 34;
      goto return_label;
    }
    strcpy(buf,(char const *)__fc_pwd.pw_gecos);
    *(buf + len) = (char)0;
    pwd->pw_gecos = buf;
    buf += len + (size_t)1;
    remaining -= len;
    len = strlen((char const *)__fc_pwd.pw_dir);
    if (remaining <= len) {
      *result = (struct passwd *)0;
      __retres = 34;
      goto return_label;
    }
    strcpy(buf,(char const *)__fc_pwd.pw_dir);
    *(buf + len) = (char)0;
    pwd->pw_dir = buf;
    buf += len + (size_t)1;
    remaining -= len;
    len = strlen((char const *)__fc_pwd.pw_shell);
    if (remaining <= len) {
      *result = (struct passwd *)0;
      __retres = 34;
      goto return_label;
    }
    strcpy(buf,(char const *)__fc_pwd.pw_shell);
    *(buf + len) = (char)0;
    pwd->pw_shell = buf;
    buf += len + (size_t)1;
    remaining -= len;
    pwd->pw_uid = Frama_C_unsigned_int_interval((unsigned int)0,4294967295U);
    pwd->pw_gid = Frama_C_unsigned_int_interval((unsigned int)0,4294967295U);
    *result = pwd;
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_name: valid_read_string(name);
    requires valid_buf: \valid(buf + (0 .. buflen - 1));
    requires valid_pwd: \valid(pwd);
    requires valid_result: \valid(result);
    ensures
      result_null_or_assigned:
        *\old(result) ≡ \null ∨ *\old(result) ≡ \old(pwd);
    ensures
      result_ok_or_error: \result ≡ 0 ∨ \result ∈ {5, 24, 23, 34};
    assigns \result, __fc_pwd, *pwd, *result, *(buf + (0 .. buflen - 1));
    assigns \result
      \from (indirect: __fc_p_pwd), (indirect: *(name + (0 ..)));
    assigns __fc_pwd \from (indirect: *(name + (0 ..)));
    assigns *pwd \from __fc_p_pwd;
    assigns *result \from __fc_p_pwd;
    assigns *(buf + (0 .. buflen - 1)) \from (indirect: *__fc_p_pwd);
 */
int getpwnam_r(char const *name, struct passwd *pwd, char *buf,
               size_t buflen, struct passwd **result)
{
  int tmp;
  /*@ assert valid_read_string(name); */ ;
  tmp = __fc_getpw_r(pwd,buf,buflen,result);
  return tmp;
}

/*@ requires valid_buf: \valid(buf + (0 .. buflen - 1));
    requires valid_pwd: \valid(pwd);
    requires valid_result: \valid(result);
    ensures
      result_null_or_assigned:
        *\old(result) ≡ \null ∨ *\old(result) ≡ \old(pwd);
    ensures
      result_ok_or_error: \result ≡ 0 ∨ \result ∈ {5, 24, 23, 34};
    assigns \result, __fc_pwd, *pwd, *result, *(buf + (0 .. buflen - 1));
    assigns \result \from (indirect: __fc_p_pwd);
    assigns __fc_pwd \from (indirect: uid);
    assigns *pwd \from __fc_p_pwd;
    assigns *result \from __fc_p_pwd;
    assigns *(buf + (0 .. buflen - 1)) \from (indirect: *__fc_p_pwd);
 */
int getpwuid_r(uid_t uid, struct passwd *pwd, char *buf, size_t buflen,
               struct passwd **result)
{
  int tmp;
  tmp = __fc_getpw_r(pwd,buf,buflen,result);
  return tmp;
}

/*@ ghost unsigned int volatile __fc_time; */
/*@ assigns \result;
    assigns \result \from __fc_time; */
extern clock_t clock(void);

/*@ assigns \result;
    assigns \result \from time1, time0; */
extern double difftime(time_t time1, time_t time0);

/*@ requires valid_timeptr: \valid(timeptr);
    assigns *timeptr, \result;
    assigns *timeptr \from *timeptr;
    assigns \result \from (indirect: *timeptr);
 */
extern time_t mktime(struct tm *timeptr);

/*@ assigns *timer, \result;
    assigns *timer \from __fc_time;
    assigns \result \from __fc_time;
    
    behavior null:
      assumes timer_null: timer ≡ \null;
      assigns \result;
      assigns \result \from __fc_time;
    
    behavior not_null:
      assumes timer_non_null: timer ≢ \null;
      requires valid_timer: \valid(timer);
      ensures initialization: timer: \initialized(\old(timer));
      assigns *timer, \result;
      assigns *timer \from __fc_time;
      assigns \result \from __fc_time;
    
    complete behaviors not_null, null;
    disjoint behaviors not_null, null;
 */
extern time_t time(time_t *timer);

char __fc_ctime[26];
char * const __fc_p_ctime = __fc_ctime;
/*@ requires valid_timeptr: \valid_read(timeptr);
    requires initialization: init_timeptr: \initialized(timeptr);
    ensures result_points_to_ctime: \result ≡ __fc_p_ctime;
    ensures result_valid_string: valid_read_string(__fc_p_ctime);
    assigns __fc_ctime[0 .. 25], \result;
    assigns __fc_ctime[0 .. 25]
      \from (indirect: *timeptr), (indirect: __fc_time);
    assigns \result
      \from (indirect: *timeptr), (indirect: __fc_time), __fc_p_ctime;
 */
extern char *asctime(struct tm const *timeptr);

/*@ requires valid_timer: \valid_read(timer);
    requires initialization: init_timer: \initialized(timer);
    ensures result_points_to_ctime: \result ≡ __fc_p_ctime;
    ensures result_valid_string: valid_read_string(__fc_p_ctime);
    assigns __fc_ctime[0 .. 25], \result;
    assigns __fc_ctime[0 .. 25]
      \from (indirect: *timer), (indirect: __fc_time);
    assigns \result
      \from (indirect: *timer), (indirect: __fc_time), __fc_p_ctime;
 */
extern char *ctime(time_t const *timer);

struct tm __fc_time_tm;
struct tm * const __fc_p_time_tm = & __fc_time_tm;
/*@ requires valid_timer: \valid_read(timer);
    ensures
      result_null_or_internal_tm:
        \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __fc_p_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *gmtime(time_t const *timer);

/*@ requires valid_timer: \valid_read(timer);
    ensures
      result_null_or_internal_tm:
        \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    ensures
      maybe_error: __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ≡ 75;
    assigns \result, __fc_time_tm;
    assigns \result \from __fc_p_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *localtime(time_t const *timer);

/*@ requires dst_has_room: \valid(s + (0 .. max - 1));
    requires valid_format: valid_read_string(format);
    requires valid_tm: \valid_read(tm);
    ensures result_bounded: \result ≤ \old(max);
    assigns *(s + (0 .. max - 1)), \result;
    assigns *(s + (0 .. max - 1))
      \from (indirect: max), (indirect: *(format + (0 ..))), (indirect: *tm);
    assigns \result
      \from (indirect: max), (indirect: *(format + (0 ..))), (indirect: *tm);
 */
extern size_t strftime(char * restrict s, size_t max,
                       char const * restrict format,
                       struct tm const * restrict tm);

/*@ requires tp: \valid(tp);
    assigns \result, *tp, __fc_time;
    assigns \result \from __fc_time;
    assigns *tp \from __fc_time;
    assigns __fc_time \from __fc_time;
    
    behavior realtime_clock:
      assumes realtime: clk_id ≡ 666;
      ensures success: \result ≡ 0;
      ensures initialization: \initialized(\old(tp));
    
    behavior monotonic_clock:
      assumes monotonic: clk_id ≡ 1;
      ensures success: \result ≡ 0;
      ensures initialization: \initialized(\old(tp));
    
    behavior bad_clock_id:
      assumes bad_id: clk_id ≢ 666 ∧ clk_id ≢ 1;
      ensures error: \result ≡ 22;
      assigns \result;
      assigns \result \from clk_id;
    
    complete behaviors bad_clock_id, monotonic_clock, realtime_clock;
    disjoint behaviors bad_clock_id, monotonic_clock, realtime_clock;
 */
extern int clock_gettime(clockid_t clk_id, struct timespec *tp);

/*@
axiomatic nanosleep_predicates {
  predicate abs_clock_in_range{L}(clockid_t id, struct timespec *tm) 
    reads __fc_time;
  
  predicate valid_clock_id{L}(clockid_t id) 
    reads __fc_time;
  
  }

*/
/*@ ghost int volatile __fc_interrupted; */
/*@ requires valid_request: \valid_read(rqtp);
    requires
      initialization: initialized_request:
        \initialized(&rqtp->tv_sec) ∧ \initialized(&rqtp->tv_nsec);
    requires valid_nanosecs: 0 ≤ rqtp->tv_nsec < 1000000000;
    requires valid_remaining_or_null: rmtp ≡ \null ∨ \valid(rmtp);
    assigns \result;
    assigns \result
      \from (indirect: __fc_time), (indirect: __fc_interrupted),
            (indirect: clock_id), (indirect: flags), (indirect: rqtp),
            (indirect: *rqtp);
    
    behavior absolute:
      assumes absolute_time: (flags & 1) ≢ 0;
      assumes
        no_einval:
          abs_clock_in_range(clock_id, rqtp) ∧ valid_clock_id(clock_id);
      ensures
        result_ok_or_error:
          \result ≡ 0 ∨ \result ≡ 4 ∨ \result ≡ 22 ∨
          \result ≡ 95;
      assigns \result;
      assigns \result
        \from (indirect: __fc_time), (indirect: __fc_interrupted),
              (indirect: clock_id), (indirect: rqtp), (indirect: *rqtp);
    
    behavior relative_interrupted:
      assumes relative_time: (flags & 1) ≡ 0;
      assumes interrupted: __fc_interrupted ≢ 0;
      assumes no_einval: valid_clock_id(clock_id);
      ensures result_interrupted: \result ≡ 4;
      ensures
        initialization: interrupted_remaining:
          \old(rmtp) ≢ \null ⇒
          \initialized(&\old(rmtp)->tv_sec) ∧
          \initialized(&\old(rmtp)->tv_nsec);
      ensures
        interrupted_remaining_decreases:
          \old(rmtp) ≢ \null ⇒
          \old(rqtp)->tv_sec * 1000000000 + \old(rqtp)->tv_nsec ≥
          \old(rmtp)->tv_sec * 1000000000 + \old(rmtp)->tv_nsec;
      ensures
        remaining_valid:
          \old(rmtp) ≢ \null ⇒ 0 ≤ \old(rmtp)->tv_nsec < 1000000000;
      assigns \result, *rmtp;
      assigns \result
        \from (indirect: __fc_time), (indirect: clock_id), (indirect: rqtp),
              (indirect: *rqtp);
      assigns *rmtp
        \from __fc_time, (indirect: clock_id), (indirect: rqtp),
              (indirect: *rqtp), (indirect: rmtp);
    
    behavior relative_no_error:
      assumes relative_time: (flags & 1) ≡ 0;
      assumes not_interrupted: __fc_interrupted ≡ 0;
      assumes no_einval: valid_clock_id(clock_id);
      ensures result_ok: \result ≡ 0;
      assigns \result;
      assigns \result
        \from (indirect: __fc_time), (indirect: clock_id), (indirect: rqtp),
              (indirect: *rqtp);
    
    behavior relative_invalid_clock_id:
      assumes relative_time: (flags & 1) ≡ 0;
      assumes not_interrupted: __fc_interrupted ≡ 0;
      assumes einval: ¬valid_clock_id(clock_id);
      ensures result_einval: \result ≡ 22;
      assigns \result;
      assigns \result
        \from (indirect: __fc_time), (indirect: clock_id), (indirect: rqtp),
              (indirect: *rqtp);
    
    complete behaviors relative_invalid_clock_id,
                       relative_no_error,
                       relative_interrupted,
                       absolute;
    disjoint behaviors relative_invalid_clock_id,
                       relative_no_error,
                       relative_interrupted,
                       absolute;
 */
extern int clock_nanosleep(clockid_t clock_id, int flags,
                           struct timespec const *rqtp, struct timespec *rmtp);

/*@ requires valid_timer: \valid_read(timer);
    requires valid_result: \valid(result);
    ensures
      result_null_or_result: \result ≡ \old(result) ∨ \result ≡ \null;
    assigns \result, *result;
    assigns \result \from (indirect: *timer), result;
    assigns *result \from (indirect: *timer);
 */
extern struct tm *gmtime_r(time_t const * restrict timer,
                           struct tm * restrict result);

/*@ requires valid_timer: \valid_read(timep);
    requires valid_result: \valid(result);
    ensures
      result_null_or_initialized: initialization:
        (\result ≡ \old(result) ∧ \initialized(\old(result))) ∨
        \result ≡ \null;
    ensures
      maybe_error: __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ≡ 75;
    assigns \result, *result, __fc_errno;
    assigns \result \from (indirect: *timep), result;
    assigns *result \from (indirect: *timep);
    assigns __fc_errno \from (indirect: *timep);
 */
extern struct tm *localtime_r(time_t const * restrict timep,
                              struct tm * restrict result);

/*@ requires valid_request: \valid_read(rqtp);
    requires
      initialization: initialized_request:
        \initialized(&rqtp->tv_sec) ∧ \initialized(&rqtp->tv_nsec);
    requires valid_nanosecs: 0 ≤ rqtp->tv_nsec < 1000000000;
    requires valid_remaining_or_null: rmtp ≡ \null ∨ \valid(rmtp);
    ensures result_elapsed_or_interrupted: \result ≡ 0 ∨ \result ≡ -1;
    ensures
      initialization: interrupted_remaining:
        \old(rmtp) ≢ \null ∧ \result ≡ -1 ⇒
        \initialized(&\old(rmtp)->tv_sec) ∧
        \initialized(&\old(rmtp)->tv_nsec);
    ensures
      interrupted_remaining_decreases:
        \old(rmtp) ≢ \null ∧ \result ≡ -1 ⇒
        \old(rqtp)->tv_sec * 1000000000 + \old(rqtp)->tv_nsec ≥
        \old(rmtp)->tv_sec * 1000000000 + \old(rmtp)->tv_nsec;
    ensures
      interrupted_remaining_valid:
        \old(rmtp) ≢ \null ∧ \result ≡ -1 ⇒
        0 ≤ \old(rmtp)->tv_nsec < 1000000000;
    assigns \result, *rmtp;
    assigns \result
      \from (indirect: __fc_time), (indirect: rqtp), (indirect: *rqtp);
    assigns *rmtp
      \from (indirect: __fc_time), (indirect: rqtp), (indirect: *rqtp),
            (indirect: rmtp);
 */
extern int nanosleep(struct timespec const *rqtp, struct timespec *rmtp);

extern char *tzname[2];

/*@ assigns *(tzname[0 .. 1] + (0 ..));
    assigns *(tzname[0 .. 1] + (0 ..)) \from \nothing;
 */
extern void tzset(void);

/*@ requires
      valid:
        valid_read_or_empty((void *)s, (size_t)(sizeof(wchar_t) * n)) ∨
        \valid_read((unsigned char *)s + (0 .. wmemchr_off(s, c, n)));
    requires
      initialization:
        \initialized(s + (0 .. n - 1)) ∨
        \initialized(s + (0 .. wmemchr_off(s, c, n)));
    requires
      danglingness:
        non_escaping((void *)s, (size_t)(sizeof(wchar_t) * n)) ∨
        non_escaping((void *)s,
                    (size_t)(sizeof(wchar_t) * (wmemchr_off(s, c, n) + 1)));
    ensures
      result_null_or_inside_s:
        \result ≡ \null ∨ \subset(\result, \old(s) + (0 .. \old(n) - 1));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. n - 1))), (indirect: c), (indirect: n);
 */
extern wchar_t *wmemchr(wchar_t const *s, wchar_t c, size_t n);

/*@ requires
      valid_s1:
        valid_read_or_empty((void *)s1, (size_t)(sizeof(wchar_t) * n));
    requires
      valid_s2:
        valid_read_or_empty((void *)s2, (size_t)(sizeof(wchar_t) * n));
    requires initialization: s1: \initialized(s1 + (0 .. n - 1));
    requires initialization: s2: \initialized(s2 + (0 .. n - 1));
    requires
      danglingness: s1:
        non_escaping((void *)s1, (size_t)(sizeof(wchar_t) * n));
    requires
      danglingness: s2:
        non_escaping((void *)s2, (size_t)(sizeof(wchar_t) * n));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wmemcmp(wchar_t const *s1, wchar_t const *s2, size_t n);

wchar_t *wmemcpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires valid_src: \valid_read(src + (0 .. n - 1));
    requires valid_dest: \valid(dest + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemmove(wchar_t *dest, wchar_t const *src, size_t n);

wchar_t *wmemset(wchar_t *dest, wchar_t val, size_t len);

wchar_t *wcscat(wchar_t *dest, wchar_t const *src);

/*@ requires valid_wstring_src: valid_read_wstring(wcs);
    ensures
      result_null_or_inside_wcs:
        \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: *(wcs + (0 ..))), (indirect: wc);
 */
extern wchar_t *wcschr(wchar_t const *wcs, wchar_t wc);

/*@ requires valid_wstring_s1: valid_read_wstring(s1);
    requires valid_wstring_s2: valid_read_wstring(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
extern int wcscmp(wchar_t const *s1, wchar_t const *s2);

wchar_t *wcscpy(wchar_t *dest, wchar_t const *src);

/*@ requires valid_wstring_wcs: valid_read_wstring(wcs);
    requires valid_wstring_accept: valid_read_wstring(accept);
    assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcscspn(wchar_t const *wcs, wchar_t const *accept);

/*@ requires valid_nwstring_src: valid_read_nwstring(src, n);
    requires valid_wstring_dest: valid_wstring(dest);
    requires
      room_for_concatenation:
        \valid(dest + (wcslen(dest) .. wcslen(dest) + \min(wcslen(src), n)));
    requires
      separation:
        \separated(
          dest + (0 .. wcslen(dest) + wcslen(src)), src + (0 .. wcslen(src))
          );
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 ..))), (indirect: *(src + (0 .. n - 1))),
            (indirect: n);
 */
extern size_t wcslcat(wchar_t * restrict dest, wchar_t const * restrict src,
                      size_t n);

/*@ requires valid_wstring_src: valid_read_wstring(src);
    requires room_nwstring: \valid(dest + (0 .. n));
    requires
      separation: dest: src:
        \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 .. n - 1))), (indirect: dest),
            (indirect: *(src + (0 .. n - 1))), (indirect: src), (indirect: n);
 */
extern size_t wcslcpy(wchar_t *dest, wchar_t const *src, size_t n);

size_t wcslen(wchar_t const *str);

wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires valid_wstring_s1: valid_read_wstring(s1);
    requires valid_wstring_s2: valid_read_wstring(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wcsncmp(wchar_t const *s1, wchar_t const *s2, size_t n);

wchar_t *wcsncpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires valid_wstring_wcs: valid_read_wstring(wcs);
    requires valid_wstring_accept: valid_read_wstring(accept);
    ensures
      result_null_or_inside_wcs:
        \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result
      \from wcs, (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern wchar_t *wcspbrk(wchar_t const *wcs, wchar_t const *accept);

/*@ requires valid_wstring_wcs: valid_read_wstring(wcs);
    ensures
      result_null_or_inside_wcs:
        \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result
      \from wcs, (indirect: *(wcs + (0 .. wcslen{Old}(wcs)))), (indirect: wc);
 */
extern wchar_t *wcsrchr(wchar_t const *wcs, wchar_t wc);

/*@ requires valid_wstring_wcs: valid_read_wstring(wcs);
    requires valid_wstring_accept: valid_read_wstring(accept);
    assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 .. wcslen{Old}(wcs)))),
            (indirect: *(accept + (0 .. wcslen{Old}(accept))));
 */
extern size_t wcsspn(wchar_t const *wcs, wchar_t const *accept);

/*@ requires valid_wstring_haystack: valid_read_wstring(haystack);
    requires valid_wstring_needle: valid_read_wstring(needle);
    ensures
      result_null_or_inside_haystack:
        \result ≡ \null ∨ \subset(\result, \old(haystack) + (0 ..));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
extern wchar_t *wcsstr(wchar_t const *haystack, wchar_t const *needle);

/*@ requires room_nwstring: \valid(ws + (0 .. n - 1));
    requires valid_stream: \valid(stream);
    ensures result_null_or_same: \result ≡ \null ∨ \result ≡ \old(ws);
    ensures
      terminated_string_on_success:
        \result ≢ \null ⇒ valid_wstring(\old(ws));
    assigns *(ws + (0 .. n - 1)), \result;
    assigns *(ws + (0 .. n - 1)) \from (indirect: n), (indirect: *stream);
    assigns \result \from ws, (indirect: n), (indirect: *stream);
 */
extern wchar_t *fgetws(wchar_t * restrict ws, int n, FILE * restrict stream);

/*@ axiomatic wformat_length {
      logic ℤ wformat_length{L}(wchar_t *format) ;
      
      }

*/
/*@ requires valid_wstring_ws1: valid_read_wstring(ws1);
    requires valid_wstring_ws2: valid_read_wstring(ws2);
    assigns \result;
    assigns \result
      \from (indirect: *(ws1 + (0 ..))), (indirect: *(ws2 + (0 ..)));
 */
extern int wcscasecmp(wchar_t const *ws1, wchar_t const *ws2);

void atomic_thread_fence(memory_order order);

void atomic_signal_fence(memory_order order);

_Bool __fc_atomic_is_lock_free(void *obj);

void __fc_atomic_store_marker(void *object, unsigned long long desired);

void __fc_atomic_store_explicit_marker(void *object,
                                       unsigned long long desired,
                                       memory_order order);

unsigned long long __fc_atomic_load(void *obj, size_t obj_size);

unsigned long long __fc_atomic_load_explicit(void *object,
                                             memory_order order,
                                             size_t obj_size);

unsigned long long __fc_atomic_exchange(void *obj,
                                        unsigned long long desired,
                                        size_t obj_size);

unsigned long long __fc_atomic_exchange_explicit(void *object,
                                                 unsigned long long desired,
                                                 memory_order order,
                                                 size_t obj_size);

_Bool __fc_atomic_compare_exchange_strong(void *object, void *expected,
                                          unsigned long long desired,
                                          size_t obj_size);

_Bool __fc_atomic_compare_exchange_strong_explicit(void *object,
                                                   void *expected,
                                                   unsigned long long desired,
                                                   memory_order success,
                                                   memory_order failure,
                                                   size_t obj_size);

_Bool __fc_atomic_compare_exchange_weak(void *object, void *expected,
                                        unsigned long long desired,
                                        size_t obj_size);

_Bool __fc_atomic_compare_exchange_weak_explicit(void *object,
                                                 void *expected,
                                                 unsigned long long desired,
                                                 memory_order success,
                                                 memory_order failure,
                                                 size_t obj_size);

unsigned long long __fc_atomic_fetch_add(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size);

unsigned long long __fc_atomic_fetch_add_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size);

unsigned long long __fc_atomic_fetch_sub(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size);

unsigned long long __fc_atomic_fetch_sub_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size);

unsigned long long __fc_atomic_fetch_or(void *obj,
                                        unsigned long long operand,
                                        size_t obj_size);

unsigned long long __fc_atomic_fetch_or_explicit(void *obj,
                                                 unsigned long long operand,
                                                 memory_order order,
                                                 size_t obj_size);

unsigned long long __fc_atomic_fetch_xor(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size);

unsigned long long __fc_atomic_fetch_xor_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size);

unsigned long long __fc_atomic_fetch_and(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size);

unsigned long long __fc_atomic_fetch_and_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size);

_Bool atomic_flag_test_and_set(atomic_flag volatile *object);

_Bool atomic_flag_test_and_set_explicit(atomic_flag volatile *object,
                                        memory_order order);

void atomic_flag_clear(atomic_flag volatile *object);

void atomic_flag_clear_explicit(atomic_flag volatile *object,
                                memory_order order);

void __fc_atomic_init_marker(void *obj, unsigned long long value)
{
  return;
}

void atomic_thread_fence(memory_order order)
{
  return;
}

void atomic_signal_fence(memory_order order)
{
  return;
}

_Bool __fc_atomic_is_lock_free(void *obj)
{
  _Bool __retres;
  int tmp;
  tmp = Frama_C_nondet(0,1);
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

void __fc_atomic_store_marker(void *object, unsigned long long desired)
{
  return;
}

void __fc_atomic_store_explicit_marker(void *object,
                                       unsigned long long desired,
                                       memory_order order)
{
  return;
}

unsigned long long __fc_atomic_load(void *obj, size_t obj_size)
{
  unsigned long long __retres;
  if (obj_size == sizeof(char)) {
    __retres = (unsigned long long)*((atomic_uchar volatile *)obj);
    goto return_label;
  }
  else 
    if (obj_size == sizeof(short)) {
      __retres = (unsigned long long)*((atomic_ushort volatile *)obj);
      goto return_label;
    }
    else 
      if (obj_size == sizeof(int)) {
        __retres = (unsigned long long)*((atomic_uint volatile *)obj);
        goto return_label;
      }
      else 
        if (obj_size == sizeof(long)) {
          __retres = (unsigned long long)*((atomic_ulong volatile *)obj);
          goto return_label;
        }
        else 
          if (obj_size == sizeof(long long)) {
            __retres = *((atomic_ullong volatile *)obj);
            goto return_label;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",50,"0");
  __retres = (unsigned long long)0;
  return_label: return __retres;
}

unsigned long long __fc_atomic_load_explicit(void *object,
                                             memory_order order,
                                             size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_load(object,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_exchange(void *obj,
                                        unsigned long long desired,
                                        size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)desired;
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)desired;
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)desired;
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)desired;
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) = desired;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",79,"0");
  return r;
}

unsigned long long __fc_atomic_exchange_explicit(void *object,
                                                 unsigned long long desired,
                                                 memory_order order,
                                                 size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_exchange(object,desired,obj_size);
  return tmp;
}

_Bool __fc_atomic_compare_exchange_strong(void *object, void *expected,
                                          unsigned long long desired,
                                          size_t obj_size)
{
  _Bool __retres;
  int r = memcmp((void const *)object,(void const *)expected,obj_size);
  if (r == 0) memcpy(object,(void const *)(& desired),obj_size);
  else memcpy(expected,(void const *)object,obj_size);
  __retres = (_Bool)(r == 0);
  return __retres;
}

_Bool __fc_atomic_compare_exchange_strong_explicit(void *object,
                                                   void *expected,
                                                   unsigned long long desired,
                                                   memory_order success,
                                                   memory_order failure,
                                                   size_t obj_size)
{
  _Bool tmp;
  tmp = __fc_atomic_compare_exchange_strong(object,expected,desired,obj_size);
  return tmp;
}

_Bool __fc_atomic_compare_exchange_weak(void *object, void *expected,
                                        unsigned long long desired,
                                        size_t obj_size)
{
  _Bool tmp;
  tmp = __fc_atomic_compare_exchange_strong(object,expected,desired,obj_size);
  return tmp;
}

_Bool __fc_atomic_compare_exchange_weak_explicit(void *object,
                                                 void *expected,
                                                 unsigned long long desired,
                                                 memory_order success,
                                                 memory_order failure,
                                                 size_t obj_size)
{
  _Bool tmp;
  tmp = __fc_atomic_compare_exchange_strong(object,expected,desired,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_fetch_add(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)((unsigned long long)*((atomic_uchar volatile *)obj) + operand);
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)((unsigned long long)*((atomic_ushort volatile *)obj) + operand);
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)((unsigned long long)*((atomic_uint volatile *)obj) + operand);
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)((unsigned long long)*((atomic_ulong volatile *)obj) + operand);
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) += operand;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",139,"0");
  return r;
}

unsigned long long __fc_atomic_fetch_add_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_fetch_add(obj,operand,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_fetch_sub(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)((unsigned long long)*((atomic_uchar volatile *)obj) - operand);
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)((unsigned long long)*((atomic_ushort volatile *)obj) - operand);
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)((unsigned long long)*((atomic_uint volatile *)obj) - operand);
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)((unsigned long long)*((atomic_ulong volatile *)obj) - operand);
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) -= operand;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",163,"0");
  return r;
}

unsigned long long __fc_atomic_fetch_sub_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_fetch_sub(obj,operand,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_fetch_or(void *obj,
                                        unsigned long long operand,
                                        size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)((unsigned long long)*((atomic_uchar volatile *)obj) | operand);
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)((unsigned long long)*((atomic_ushort volatile *)obj) | operand);
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)((unsigned long long)*((atomic_uint volatile *)obj) | operand);
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)((unsigned long long)*((atomic_ulong volatile *)obj) | operand);
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) |= operand;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",187,"0");
  return r;
}

unsigned long long __fc_atomic_fetch_or_explicit(void *obj,
                                                 unsigned long long operand,
                                                 memory_order order,
                                                 size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_fetch_or(obj,operand,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_fetch_xor(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)((unsigned long long)*((atomic_uchar volatile *)obj) ^ operand);
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)((unsigned long long)*((atomic_ushort volatile *)obj) ^ operand);
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)((unsigned long long)*((atomic_uint volatile *)obj) ^ operand);
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)((unsigned long long)*((atomic_ulong volatile *)obj) ^ operand);
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) ^= operand;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",217,"0");
  return r;
}

unsigned long long __fc_atomic_fetch_xor_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_fetch_xor(obj,operand,obj_size);
  return tmp;
}

unsigned long long __fc_atomic_fetch_and(void *obj,
                                         unsigned long long operand,
                                         size_t obj_size)
{
  unsigned long long r = (unsigned long long)0;
  if (obj_size == sizeof(char)) {
    r = (unsigned long long)*((atomic_uchar volatile *)obj);
    *((atomic_uchar volatile *)obj) = (atomic_uchar)((unsigned long long)*((atomic_uchar volatile *)obj) & operand);
  }
  else 
    if (obj_size == sizeof(short)) {
      r = (unsigned long long)*((atomic_ushort volatile *)obj);
      *((atomic_ushort volatile *)obj) = (atomic_ushort)((unsigned long long)*((atomic_ushort volatile *)obj) & operand);
    }
    else 
      if (obj_size == sizeof(int)) {
        r = (unsigned long long)*((atomic_uint volatile *)obj);
        *((atomic_uint volatile *)obj) = (atomic_uint)((unsigned long long)*((atomic_uint volatile *)obj) & operand);
      }
      else 
        if (obj_size == sizeof(long)) {
          r = (unsigned long long)*((atomic_ulong volatile *)obj);
          *((atomic_ulong volatile *)obj) = (atomic_ulong)((unsigned long long)*((atomic_ulong volatile *)obj) & operand);
        }
        else 
          if (obj_size == sizeof(long long)) {
            r = *((atomic_ullong volatile *)obj);
            *((atomic_ullong volatile *)obj) &= operand;
          }
          else __FC_assert(0 != 0,"FRAMAC_SHARE/libc/stdatomic.c",247,"0");
  return r;
}

unsigned long long __fc_atomic_fetch_and_explicit(void *obj,
                                                  unsigned long long operand,
                                                  memory_order order,
                                                  size_t obj_size)
{
  unsigned long long tmp;
  tmp = __fc_atomic_fetch_and(obj,operand,obj_size);
  return tmp;
}

_Bool atomic_flag_test_and_set(atomic_flag volatile *object)
{
  _Bool r = (_Bool)(object->__fc_val != 0);
  object->__fc_val = (unsigned char)1;
  return r;
}

_Bool atomic_flag_test_and_set_explicit(atomic_flag volatile *object,
                                        memory_order order)
{
  _Bool r = (_Bool)(object->__fc_val != 0);
  object->__fc_val = (unsigned char)1;
  return r;
}

void atomic_flag_clear(atomic_flag volatile *object)
{
  object->__fc_val = (unsigned char)0;
  return;
}

void atomic_flag_clear_explicit(atomic_flag volatile *object,
                                memory_order order)
{
  object->__fc_val = (unsigned char)0;
  return;
}

FILE *__fc_stderr;

FILE *__fc_stdin;

FILE *__fc_stdout;

/*@ requires valid_filename: valid_read_string(filename);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: *(filename + (0 .. strlen{Old}(filename))));
 */
extern int remove(char const *filename);

/*@ requires valid_old_name: valid_read_string(old_name);
    requires valid_new_name: valid_read_string(new_name);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: *(old_name + (0 .. strlen{Old}(old_name)))),
            (indirect: *(new_name + (0 .. strlen{Old}(new_name))));
 */
extern int rename(char const *old_name, char const *new_name);

FILE __fc_fopen[16];
FILE * const __fc_p_fopen = __fc_fopen;
/*@ ensures
      result_null_or_valid_fd:
        \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 16 - 1]);
    assigns \result;
    assigns \result \from __fc_p_fopen;
 */
extern FILE *tmpfile(void);

char __fc_tmpnam[2048];
char * const __fc_p_tmpnam = __fc_tmpnam;
/*@ requires valid_s_or_null: s ≡ \null ∨ \valid(s + (0 .. 2048));
    ensures
      result_string_or_null:
        \result ≡ \null ∨ \result ≡ \old(s) ∨
        \result ≡ __fc_p_tmpnam;
    assigns *(__fc_p_tmpnam + (0 .. 2048)), *(s + (0 .. 2048)), \result;
    assigns *(__fc_p_tmpnam + (0 .. 2048))
      \from *(__fc_p_tmpnam + (0 .. 2048)), (indirect: s);
    assigns *(s + (0 .. 2048))
      \from (indirect: s), *(__fc_p_tmpnam + (0 .. 2048));
    assigns \result \from s, __fc_p_tmpnam;
 */
extern char *tmpnam(char *s);

/*@ requires valid_stream: \valid(stream);
    ensures result_zero_or_EOF: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: stream), (indirect: *stream);
 */
extern int fclose(FILE *stream);

/*@ requires null_or_valid_stream: stream ≡ \null ∨ \valid_read(stream);
    ensures result_zero_or_EOF: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *stream, __fc_fopen[0 .. 16 - 1];
    assigns \result
      \from (indirect: *stream), (indirect: __fc_fopen[0 .. 16 - 1]);
    assigns *stream
      \from (indirect: stream), *stream, __fc_fopen[0 .. 16 - 1];
    assigns __fc_fopen[0 .. 16 - 1]
      \from (indirect: stream), *stream, __fc_fopen[0 .. 16 - 1];
    
    behavior flush_all:
      assumes all_streams: stream ≡ \null;
      assigns __fc_fopen[0 .. 16 - 1], \result;
      assigns __fc_fopen[0 .. 16 - 1] \from __fc_fopen[0 .. 16 - 1];
      assigns \result \from (indirect: __fc_fopen[0 .. 16 - 1]);
    
    behavior flush_stream:
      assumes single_stream: stream ≢ \null;
      assigns *stream, \result;
      assigns *stream \from *stream;
      assigns \result \from (indirect: *stream);
    
    complete behaviors flush_stream, flush_all;
    disjoint behaviors flush_stream, flush_all;
 */
extern int fflush(FILE *stream);

/*@ requires valid_filename: valid_read_string(filename);
    requires valid_mode: valid_read_string(mode);
    ensures
      result_null_or_valid_fd:
        \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 16 - 1]);
    assigns \result;
    assigns \result
      \from (indirect: *(filename + (0 .. strlen{Old}(filename)))),
            (indirect: *(mode + (0 .. strlen{Old}(mode)))), __fc_p_fopen;
 */
extern FILE *fopen(char const * restrict filename, char const * restrict mode);

/*@ requires valid_mode: valid_read_string(mode);
    ensures
      result_null_or_valid_fd:
        \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 16 - 1]);
    assigns \result, __fc_fopen[fd];
    assigns \result
      \from (indirect: fd), (indirect: *(mode + (0 .. strlen{Old}(mode)))),
            (indirect: __fc_fopen[fd]), __fc_p_fopen;
    assigns __fc_fopen[fd]
      \from (indirect: fd), (indirect: *(mode + (0 .. strlen{Old}(mode)))),
            (indirect: __fc_fopen[fd]), __fc_p_fopen;
 */
extern FILE *fdopen(int fd, char const *mode);

/*@ requires valid_filename: valid_read_string(filename);
    requires valid_mode: valid_read_string(mode);
    requires valid_stream: \valid(stream);
    ensures
      result_null_or_valid_fd:
        \result ≡ \null ∨ \result ∈ &__fc_fopen[0 .. 16 - 1];
    ensures stream_opened: *\old(stream) ∈ __fc_fopen[0 .. 16 - 1];
    assigns \result, *stream;
    assigns \result
      \from (indirect: *(filename + (..))), (indirect: *(mode + (..))),
            __fc_p_fopen, (indirect: stream);
    assigns *stream
      \from (indirect: *(filename + (..))), (indirect: *(mode + (..))),
            __fc_p_fopen, (indirect: stream);
 */
extern FILE *freopen(char const * restrict filename,
                     char const * restrict mode, FILE * restrict stream);

/*@ assigns *stream;
    assigns *stream \from buf; */
extern void setbuf(FILE * restrict stream, char * restrict buf);

/*@ assigns *stream;
    assigns *stream \from buf, mode, size; */
extern int setvbuf(FILE * restrict stream, char * restrict buf, int mode,
                   size_t size);

/*@ axiomatic format_length {
      logic ℤ format_length{L}(char *format) ;
      
      }

*/
/*@ assigns *stream;
    assigns *stream \from *(format + (..)), arg; */
extern int vfprintf(FILE * restrict stream, char const * restrict format,
                    va_list arg);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), *stream; */
extern int vfscanf(FILE * restrict stream, char const * restrict format,
                   va_list arg);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from arg; */
extern int vprintf(char const * restrict format, va_list arg);

/*@ assigns *__fc_stdin;
    assigns *__fc_stdin \from *(format + (..)); */
extern int vscanf(char const * restrict format, va_list arg);

/*@ assigns *(s + (0 .. n - 1));
    assigns *(s + (0 .. n - 1)) \from *(format + (..)), arg;
 */
extern int vsnprintf(char * restrict s, size_t n,
                     char const * restrict format, va_list arg);

/*@ assigns *(s + (0 ..));
    assigns *(s + (0 ..)) \from *(format + (..)), arg;
 */
extern int vsprintf(char * restrict s, char const * restrict format,
                    va_list arg);

/*@ requires valid_stream: \valid(stream);
    ensures result_uchar_or_eof: (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns *stream, \result;
    assigns *stream \from *stream;
    assigns \result \from (indirect: *stream);
 */
extern int fgetc(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    requires room_s: \valid(s + (0 .. size - 1));
    ensures result_null_or_same: \result ≡ \null ∨ \result ≡ \old(s);
    ensures
      initialization: at_least_one:
        \result ≢ \null ⇒ \initialized(\old(s) + 0);
    ensures
      terminated_string_on_success:
        \result ≢ \null ⇒ valid_string(\old(s));
    assigns *(s + (0 .. size - 1)), \result;
    assigns *(s + (0 .. size - 1))
      \from (indirect: size), (indirect: *stream);
    assigns \result \from s, (indirect: size), (indirect: *stream);
 */
extern char *fgets(char * restrict s, int size, FILE * restrict stream);

/*@ requires valid_stream: \valid(stream);
    assigns *stream, \result;
    assigns *stream \from c, *stream;
    assigns \result \from (indirect: *stream);
 */
extern int fputc(int c, FILE *stream);

/*@ requires valid_string_s: valid_read_string(s);
    assigns *stream, \result;
    assigns *stream \from *(s + (0 .. strlen{Old}(s))), *stream;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: *stream);
 */
extern int fputs(char const * restrict s, FILE * restrict stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc(FILE *stream);

/*@ assigns \result, *__fc_stdin;
    assigns \result \from *__fc_stdin;
    assigns *__fc_stdin \from *__fc_stdin;
 */
extern int getchar(void);

/*@ axiomatic GetsLength {
      logic size_t gets_length{L}
        reads *__fc_stdin;
      
      }

*/
/*@ requires room_s: \valid(s + (0 .. gets_length));
    ensures result_null_or_same: \result ≡ \old(s) ∨ \result ≡ \null;
    assigns *(s + (0 .. gets_length{Old})), \result, *__fc_stdin;
    assigns *(s + (0 .. gets_length{Old})) \from *__fc_stdin;
    assigns \result \from s, *__fc_stdin;
    assigns *__fc_stdin \from *__fc_stdin;
 */
extern char *gets(char *s);

/*@ requires valid_stream: \valid(stream);
    assigns *stream, \result;
    assigns *stream \from c, *stream;
    assigns \result \from (indirect: *stream);
 */
extern int putc(int c, FILE *stream);

/*@ assigns *__fc_stdout, \result;
    assigns *__fc_stdout \from c, *__fc_stdout;
    assigns \result \from (indirect: *__fc_stdout);
 */
extern int putchar(int c);

/*@ requires valid_string_s: valid_read_string(s);
    assigns *__fc_stdout, \result;
    assigns *__fc_stdout \from *(s + (0 .. strlen{Old}(s))), *__fc_stdout;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))),
            (indirect: *__fc_stdout);
 */
extern int puts(char const *s);

/*@ requires valid_stream: \valid(stream);
    ensures result_ok_or_error: \result ≡ \old(c) ∨ \result ≡ -1;
    assigns *stream, \result;
    assigns *stream \from (indirect: c);
    assigns \result \from (indirect: c), (indirect: *stream);
 */
extern int ungetc(int c, FILE *stream);

/*@ requires valid_ptr_block: \valid((char *)ptr + (0 .. nmemb * size - 1));
    requires valid_stream: \valid(stream);
    ensures size_read: \result ≤ \old(nmemb);
    ensures
      initialization:
        \initialized((char *)\old(ptr) + (0 .. \result * \old(size) - 1));
    assigns *((char *)ptr + (0 .. nmemb * size - 1)), *stream, \result;
    assigns *((char *)ptr + (0 .. nmemb * size - 1))
      \from (indirect: size), (indirect: nmemb), (indirect: *stream);
    assigns *stream
      \from (indirect: size), (indirect: nmemb), (indirect: *stream);
    assigns \result \from size, (indirect: *stream);
 */
extern size_t fread(void * restrict ptr, size_t size, size_t nmemb,
                    FILE * restrict stream);

/*@ requires
      valid_ptr_block: \valid_read((char *)ptr + (0 .. nmemb * size - 1));
    requires valid_stream: \valid(stream);
    ensures size_written: \result ≤ \old(nmemb);
    assigns *stream, \result;
    assigns *stream
      \from (indirect: *((char *)ptr + (0 .. nmemb * size - 1)));
    assigns \result
      \from (indirect: *((char *)ptr + (0 .. nmemb * size - 1)));
 */
extern size_t fwrite(void const * restrict ptr, size_t size, size_t nmemb,
                     FILE * restrict stream);

/*@ requires valid_stream: \valid(stream);
    requires valid_pos: \valid(pos);
    ensures initialization: pos: \initialized(\old(pos));
    assigns \result, *pos;
    assigns \result \from (indirect: *stream);
    assigns *pos \from (indirect: *stream);
 */
extern int fgetpos(FILE * restrict stream, fpos_t * restrict pos);

/*@ requires valid_stream: \valid(stream);
    requires whence_enum: whence ≡ 0 ∨ whence ≡ 1 ∨ whence ≡ 2;
    ensures
      errno_set: __fc_errno ∈ {11, 9, 27, 4, 22, 5, 28, 75, 32, 29, 6};
    assigns *stream, \result, __fc_errno;
    assigns *stream \from *stream, (indirect: offset), (indirect: whence);
    assigns \result
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
    assigns __fc_errno
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
 */
extern int fseek(FILE *stream, long offset, int whence);

/*@ requires valid_stream: \valid(stream);
    requires whence_enum: whence ≡ 0 ∨ whence ≡ 1 ∨ whence ≡ 2;
    ensures
      errno_set: __fc_errno ∈ {11, 9, 27, 4, 22, 5, 28, 75, 32, 29, 6};
    assigns *stream, \result, __fc_errno;
    assigns *stream \from *stream, (indirect: offset), (indirect: whence);
    assigns \result
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
    assigns __fc_errno
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
 */
extern int fseeko(FILE *stream, off_t offset, int whence);

/*@ requires valid_stream: \valid(stream);
    requires valid_pos: \valid_read(pos);
    requires initialization: pos: \initialized(pos);
    ensures errno_set: __fc_errno ∈ {11, 9, 27, 4, 5, 28, 32, 29, 6};
    assigns *stream, \result, __fc_errno;
    assigns *stream \from *pos;
    assigns \result \from (indirect: *stream), (indirect: *pos);
    assigns __fc_errno
      \from __fc_errno, (indirect: *stream), (indirect: *pos);
 */
extern int fsetpos(FILE *stream, fpos_t const *pos);

/*@ requires valid_stream: \valid(stream);
    ensures
      success_or_error:
        \result ≡ -1 ∨
        (\result ≥ 0 ∧ __fc_errno ≡ \old(__fc_errno));
    ensures errno_set: __fc_errno ∈ {9, 75, 29};
    assigns \result, __fc_errno;
    assigns \result \from (indirect: *stream);
    assigns __fc_errno \from (indirect: *stream);
 */
extern long ftell(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    ensures
      success_or_error:
        \result ≡ -1 ∨
        (\result ≥ 0 ∧ __fc_errno ≡ \old(__fc_errno));
    ensures errno_set: __fc_errno ∈ {9, 75, 29};
    assigns \result, __fc_errno;
    assigns \result \from (indirect: *stream);
    assigns __fc_errno \from (indirect: *stream);
 */
extern off_t ftello(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns *stream;
    assigns *stream \from \nothing;
 */
extern void rewind(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns *stream;
    assigns *stream \from \nothing;
 */
extern void clearerr(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int feof(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int fileno(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns *stream;
    assigns *stream \from \nothing;
 */
extern void flockfile(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns *stream;
    assigns *stream \from \nothing;
 */
extern void funlockfile(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result, *stream;
    assigns \result \from \nothing;
    assigns *stream \from \nothing;
 */
extern int ftrylockfile(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int ferror(FILE *stream);

/*@ requires valid_string_s: valid_read_string(s);
    assigns __fc_stdout;
    assigns __fc_stdout \from __fc_errno, *(s + (0 .. strlen{Old}(s)));
 */
extern void perror(char const *s);

/*@ requires valid_stream: \valid(stream);
    assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar_unlocked(void);

/*@ requires valid_stream: \valid(stream);
    assigns *stream, \result;
    assigns *stream \from c;
    assigns \result \from (indirect: *stream);
 */
extern int putc_unlocked(int c, FILE *stream);

/*@ assigns *__fc_stdout, \result;
    assigns *__fc_stdout \from c;
    assigns \result \from (indirect: *__fc_stdout);
 */
extern int putchar_unlocked(int c);

/*@ requires valid_stream: \valid(stream);
    assigns *stream;
    assigns *stream \from \nothing;
 */
extern void clearerr_unlocked(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int feof_unlocked(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int ferror_unlocked(FILE *stream);

/*@ requires valid_stream: \valid(stream);
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int fileno_unlocked(FILE *stream);

/*@ axiomatic pipe_streams {
      predicate is_open_pipe{L}(FILE *stream) ;
      
      }

*/
/*@ requires valid_command: valid_read_string(command);
    requires valid_type: valid_read_string(type);
    ensures
      result_error_or_valid_open_pipe:
        \result ≡ \null ∨
        (\subset(\result, &__fc_fopen[0 .. 16 - 1]) ∧ is_open_pipe(\result));
    assigns \result, __fc_fopen[0 ..];
    assigns \result
      \from (indirect: *command), (indirect: *type), __fc_p_fopen;
    assigns __fc_fopen[0 ..]
      \from (indirect: *command), (indirect: *type), __fc_fopen[0 ..];
 */
extern FILE *popen(char const *command, char const *type);

/*@ requires valid_stream: \valid(stream);
    requires open_pipe: is_open_pipe(stream);
    ensures closed_stream: ¬is_open_pipe(\old(stream));
    assigns \result;
    assigns \result \from (indirect: *stream);
 */
extern int pclose(FILE *stream);

ssize_t getline(char **lineptr, size_t *n, FILE *stream);

FILE *fmemopen(void * restrict buf, size_t size, char const * restrict mode);

int asprintf(char **strp, char const *fmt, void * const *__va_params);

FILE __fc_initial_stdout =
  {.__fc_FILE_id = (unsigned int)1, .__fc_FILE_data = 0U};
FILE *__fc_stdout = & __fc_initial_stdout;
FILE __fc_initial_stderr =
  {.__fc_FILE_id = (unsigned int)2, .__fc_FILE_data = 0U};
FILE *__fc_stderr = & __fc_initial_stderr;
FILE __fc_initial_stdin =
  {.__fc_FILE_id = (unsigned int)0, .__fc_FILE_data = 0U};
FILE *__fc_stdin = & __fc_initial_stdin;
/*@ requires valid_mode: valid_read_string(mode); */
static _Bool is_valid_mode(char const *mode)
{
  _Bool __retres;
  if (! ((int)*(mode + 0) != 'r')) 
    if (! ((int)*(mode + 0) != 'w')) 
      if (! ((int)*(mode + 0) != 'a')) {
        __retres = (_Bool)0;
        goto return_label;
      }
  if (! *(mode + 1)) {
    __retres = (_Bool)1;
    goto return_label;
  }
  if (! ((int)*(mode + 1) != 'b')) 
    if (! ((int)*(mode + 1) != '+')) {
      __retres = (_Bool)0;
      goto return_label;
    }
  if (! *(mode + 2)) {
    __retres = (_Bool)1;
    goto return_label;
  }
  if ((int)*(mode + 2) == (int)*(mode + 1)) {
    __retres = (_Bool)0;
    goto return_label;
  }
  else 
    if (! ((int)*(mode + 2) != 'b')) 
      if (! ((int)*(mode + 2) != '+')) {
        __retres = (_Bool)0;
        goto return_label;
      }
  __retres = (_Bool)(! *(mode + 3));
  return_label: return __retres;
}

ssize_t getline(char **lineptr, size_t *n, FILE *stream)
{
  ssize_t __retres;
  int tmp;
  if (! lineptr) goto _LOR;
  else 
    if (! n) goto _LOR;
    else 
      if (! stream) {
        _LOR: {
                __fc_errno = 22;
                __retres = -1;
                goto return_label;
              }
      }
  tmp = ferror(stream);
  if (tmp) goto _LOR_0;
  else {
    int tmp_0;
    tmp_0 = feof(stream);
    if (tmp_0) {
      _LOR_0: {
                __retres = -1;
                goto return_label;
              }
    }
  }
  if (! *lineptr) goto _LOR_1;
  else 
    if (*n == (size_t)0) {
      _LOR_1:
      {
        *lineptr = (char *)malloc((size_t)2);
        if (! lineptr) {
          __fc_errno = 12;
          __retres = -1;
          goto return_label;
        }
        *n = (size_t)2;
      }
    }
  size_t cur = (size_t)0;
  while (1) {
    int tmp_3;
    tmp_3 = ferror(stream);
    if (tmp_3) break;
    else {
      int tmp_4;
      tmp_4 = feof(stream);
      if (tmp_4) break;
    }
    {
      while (cur < *n - (size_t)1) {
        int tmp_1;
        tmp_1 = fgetc(stream);
        char c = (char)tmp_1;
        if ((int)c == -1) 
          if (cur == (size_t)0) {
            __retres = -1;
            goto return_label;
          }
        if ((int)c != -1) {
          size_t tmp_2;
          tmp_2 = cur;
          cur ++;
          *(*lineptr + tmp_2) = c;
        }
        if ((int)c == '\n') goto _LOR_2;
        else 
          if ((int)c == -1) {
            _LOR_2:
            {
              *(*lineptr + cur) = (char)'\000';
              __retres = (ssize_t)cur;
              goto return_label;
            }
          }
      }
      if (*n == (size_t)2147483647) {
        __fc_errno = 75;
        __retres = -1;
        goto return_label;
      }
      size_t new_size = *n + (size_t)1;
      *lineptr = (char *)realloc((void *)*lineptr,new_size);
      if (! *lineptr) {
        __fc_errno = 12;
        __retres = -1;
        goto return_label;
      }
      *n = new_size;
    }
  }
  __retres = -1;
  return_label: return __retres;
}

/*@ requires valid_strp: \valid(strp);
    requires valid_fmt: valid_read_string(fmt);
    ensures result_error_or_written_byes: \result ≡ -1 ∨ \result ≥ 0;
    assigns __fc_heap_status, \result, *strp;
    assigns __fc_heap_status
      \from (indirect: *(fmt + (0 ..))), __fc_heap_status;
    assigns \result
      \from (indirect: *(fmt + (0 ..))), (indirect: __fc_heap_status);
    assigns *strp \from *(fmt + (0 ..)), (indirect: __fc_heap_status);
    allocates *\old(strp);
 */
int asprintf(char **strp, char const *fmt, void * const *__va_params)
{
  int __retres;
  va_list args;
  int tmp;
  args = __va_params;
  tmp = Frama_C_interval(1,256);
  size_t len = (size_t)tmp;
  *strp = (char *)malloc(len);
  if (! *strp) {
    __retres = -1;
    goto return_label;
  }
  Frama_C_make_unknown(*strp,len - 1U);
  *(*strp + (len - 1U)) = (char)0;
  __retres = (int)len;
  return_label: return __retres;
}

/*@ requires
      valid_or_null_buff:
        buf ≡ \null ∨ \valid((char *)buf + (0 .. size - 1));
    requires valid_mode: valid_read_string(mode);
    ensures
      result_error_or_valid:
        \result ≡ \null ∨ \result ∈ &__fc_fopen[0 .. 16 - 1];
    ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ∈ {22, 24, 12};
    assigns __fc_errno, \result;
    assigns __fc_errno
      \from (indirect: buf), (indirect: size),
            (indirect: *(mode + (0 .. strlen{Old}(mode))));
    assigns \result
      \from __fc_p_fopen, (indirect: buf), (indirect: size),
            (indirect: *(mode + (0 .. strlen{Old}(mode))));
    allocates \old(buf);
 */
FILE *fmemopen(void * restrict buf, size_t size, char const * restrict mode)
{
  FILE *__retres;
  _Bool tmp;
  int tmp_1;
  int tmp_2;
  tmp = is_valid_mode(mode);
  if (! tmp) {
    __fc_errno = 22;
    __retres = (FILE *)0;
    goto return_label;
  }
  if (! buf) {
    if (size == (size_t)0) {
      int tmp_0;
      tmp_0 = Frama_C_interval(0,1);
      if (tmp_0) {
        __fc_errno = 22;
        __retres = (FILE *)0;
        goto return_label;
      }
    }
    if ((int)*(mode + 1) != '+') 
      if (*(mode + 1)) 
        if ((int)*(mode + 2) != '+') {
          __fc_errno = 22;
          __retres = (FILE *)0;
          goto return_label;
        }
    buf = malloc(size);
    if (! buf) {
      __fc_errno = 12;
      __retres = (FILE *)0;
      goto return_label;
    }
  }
  tmp_1 = Frama_C_interval(0,1);
  if (tmp_1) {
    __fc_errno = 24;
    __retres = (FILE *)0;
    goto return_label;
  }
  tmp_2 = Frama_C_interval(0,16 - 1);
  __retres = & __fc_fopen[tmp_2];
  return_label: return __retres;
}

/*@ requires abs_representable: i > -2147483647 - 1;
    assigns \result;
    assigns \result \from i;
    
    behavior negative:
      assumes negative: i < 0;
      ensures opposite_result: \result ≡ -\old(i);
    
    behavior nonnegative:
      assumes nonnegative: i ≥ 0;
      ensures same_result: \result ≡ \old(i);
    
    complete behaviors nonnegative, negative;
    disjoint behaviors nonnegative, negative;
 */
int abs(int i)
{
  int __retres;
  if (i < 0) {
    __retres = - i;
    goto return_label;
  }
  __retres = i;
  return_label: return __retres;
}

/*@ requires valid_nptr: \valid_read(p);
    assigns \result;
    assigns \result \from (indirect: p), (indirect: *(p + (0 ..)));
 */
int atoi(char const *p)
{
  int __retres;
  int n;
  int c;
  int tmp_1;
  int tmp_3;
  int neg = 0;
  unsigned char *up = (unsigned char *)p;
  c = (int)*up;
  tmp_1 = isdigit(c);
  if (! tmp_1) {
    int tmp_0;
    while (1) {
      int tmp;
      tmp = isspace(c);
      if (! tmp) break;
      up ++;
      c = (int)*up;
    }
    switch (c) {
      case '-': neg ++;
      case '+': { /* sequence */
                  up ++;
                  c = (int)*up;
                }
    }
    tmp_0 = isdigit(c);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  n = '0' - c;
  while (1) {
    int tmp_2;
    up ++;
    c = (int)*up;
    tmp_2 = isdigit(c);
    if (! tmp_2) break;
    n *= 10;
    n += '0' - c;
  }
  if (neg) tmp_3 = n; else tmp_3 = - n;
  __retres = tmp_3;
  return_label: return __retres;
}

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: nmemb), (indirect: size), __fc_heap_status;
    assigns \result
      \from (indirect: nmemb), (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(nmemb * size);
      ensures
        allocation: \fresh{Old, Here}(\result,\old(nmemb) * \old(size));
      ensures
        initialization:
          \initialized((char *)\result + (0 .. \old(nmemb) * \old(size) - 1));
      ensures
        zero_initialization:
          \subset(*((char *)\result + (0 .. \old(nmemb) * \old(size) - 1)),
                 {0});
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(nmemb * size);
      ensures null_result: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *calloc(size_t nmemb, size_t size)
{
  void *__retres;
  size_t l = nmemb * size;
  if (size != (size_t)0) 
    if (l / size != nmemb) {
      __retres = (void *)0;
      goto return_label;
    }
  char *p = malloc(l);
  if (p) memset((void *)p,0,l);
  __retres = (void *)p;
  return_label: return __retres;
}

static char __fc_env_strings[64];
static char __fc_initenv_init;
static void __fc_initenv(void)
{
  if (! __fc_initenv_init) {
    Frama_C_make_unknown(__fc_env_strings,(size_t)(64 - 1));
    {
      int i = 0;
      while (i < 4096) {
        {
          int tmp;
          tmp = Frama_C_interval(0,64 - 1);
          __fc_env[i] = & __fc_env_strings[tmp];
        }
        i ++;
      }
    }
    __fc_initenv_init = (char)1;
  }
  return;
}

/*@ requires valid_name: valid_read_string(name);
    ensures null_or_valid_result: \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from __fc_env[0 ..], (indirect: name), *(name + (0 ..));
 */
char *getenv(char const *name)
{
  char *__retres;
  int tmp_0;
  /*@ assert ¬(strchr(name, '=') ≡ \true); */ ;
  __fc_initenv();
  tmp_0 = Frama_C_nondet(0,1);
  if (tmp_0) {
    int tmp;
    tmp = Frama_C_interval(0,4096 - 1);
    ;
    __retres = __fc_env[tmp];
    goto return_label;
  }
  else {
    __retres = (char *)0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_string: valid_read_string(string);
    assigns __fc_env[0 ..], \result;
    assigns __fc_env[0 ..] \from __fc_env[0 ..], string;
    assigns \result \from (indirect: __fc_env[0 ..]), (indirect: string);
 */
int putenv(char *string)
{
  int __retres;
  int tmp_3;
  char *separator __attribute__((__unused__)) =
    strchr((char const *)string,'=');
  /*@ assert string_contains_separator: separator ≢ \null; */ ;
  /*@ assert name_is_not_empty: separator ≢ string; */ ;
  __fc_initenv();
  tmp_3 = Frama_C_nondet(0,1);
  if (tmp_3) {
    int tmp_1;
    int tmp_2;
    tmp_1 = Frama_C_nondet(0,1);
    if (tmp_1) {
      int tmp_0;
      tmp_0 = Frama_C_interval(-2147483647 - 1,2147483647);
      __retres = tmp_0;
      goto return_label;
    }
    tmp_2 = Frama_C_interval(0,4096 - 1);
    __fc_env[tmp_2] = string;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_name: valid_read_string(name);
    requires valid_value: valid_read_string(value);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..))),
            (indirect: value), (indirect: *(value + (0 ..))),
            (indirect: overwrite);
 */
int setenv(char const *name, char const *value, int overwrite)
{
  int __retres;
  char *tmp;
  int tmp_4;
  tmp = strchr(name,'=');
  if (tmp) {
    __retres = -1;
    goto return_label;
  }
  size_t namelen = strlen(name);
  if (namelen == (size_t)0) {
    __retres = -1;
    goto return_label;
  }
  __fc_initenv();
  tmp_4 = Frama_C_nondet(0,1);
  if (tmp_4) {
    __retres = -1;
    goto return_label;
  }
  else {
    int tmp_1;
    int tmp_2;
    int tmp_3;
    tmp_1 = Frama_C_nondet(0,1);
    if (tmp_1) Frama_C_make_unknown(__fc_env_strings,(size_t)(64 - 1));
    tmp_2 = Frama_C_interval(0,4096 - 1);
    tmp_3 = Frama_C_interval(0,64 - 1);
    __fc_env[tmp_2] = & __fc_env_strings[tmp_3];
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_name: valid_read_string(name);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_env[0 ..];
    assigns \result
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
    assigns __fc_env[0 ..]
      \from __fc_env[0 ..], (indirect: name), (indirect: *(name + (0 ..)));
 */
int unsetenv(char const *name)
{
  int __retres;
  char *tmp;
  int tmp_2;
  tmp = strchr(name,'=');
  if (tmp) {
    __retres = -1;
    goto return_label;
  }
  size_t namelen = strlen(name);
  if (namelen == (size_t)0) {
    __retres = -1;
    goto return_label;
  }
  __fc_initenv();
  tmp_2 = Frama_C_nondet(0,1);
  if (tmp_2) {
    int tmp_1;
    tmp_1 = Frama_C_interval(0,4096 - 1);
    __fc_env[tmp_1] = (char *)0;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_memptr: \valid(memptr);
    requires
      alignment_is_a_suitable_power_of_two:
        alignment ≥ sizeof(void *) ∧
        ((size_t)alignment & ((size_t)alignment - 1)) ≡ 0;
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: alignment), size, __fc_heap_status;
    assigns \result
      \from (indirect: alignment), (indirect: size),
            (indirect: __fc_heap_status);
    allocates *\old(memptr);
    
    behavior allocation:
      assumes can_allocate: is_allocable(size);
      ensures allocation: \fresh{Old, Here}(*\old(memptr),\old(size));
      ensures result_zero: \result ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: alignment), size, __fc_heap_status;
      assigns \result
        \from (indirect: alignment), (indirect: size),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(size);
      ensures result_non_zero: \result < 0 ∨ \result > 0;
      assigns \result;
      assigns \result \from (indirect: alignment);
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
int posix_memalign(void **memptr, size_t alignment, size_t size)
{
  int __retres;
  /*@
  assert
  alignment_is_a_suitable_power_of_two:
    alignment ≥ sizeof(void *) ∧
    ((size_t)alignment & ((size_t)alignment - 1)) ≡ 0;
   */
  ;
  *memptr = malloc(size);
  if (! *memptr) {
    __retres = 12;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

char *realpath(char const * restrict file_name, char * restrict resolved_name)
{
  char *__retres;
  int tmp;
  if (! file_name) {
    __fc_errno = 22;
    __retres = (char *)0;
    goto return_label;
  }
  tmp = Frama_C_interval(0,6);
  switch (tmp) {
    case 0: __fc_errno = 13;
    __retres = (char *)0;
    goto return_label;
    case 1: __fc_errno = 5;
    __retres = (char *)0;
    goto return_label;
    case 2: __fc_errno = 40;
    __retres = (char *)0;
    goto return_label;
    case 3: __fc_errno = 36;
    __retres = (char *)0;
    goto return_label;
    case 4: __fc_errno = 2;
    __retres = (char *)0;
    goto return_label;
    case 5: __fc_errno = 20;
    __retres = (char *)0;
    goto return_label;
    default: break;
  }
  int realpath_len = Frama_C_interval(1,256);
  if (! resolved_name) {
    resolved_name = (char *)malloc((size_t)256);
    if (! resolved_name) {
      __fc_errno = 12;
      __retres = (char *)0;
      goto return_label;
    }
  }
  Frama_C_make_unknown(resolved_name,(size_t)realpath_len);
  *(resolved_name + (realpath_len - 1)) = (char)'\000';
  __retres = resolved_name;
  return_label: return __retres;
}

char *canonicalize_file_name(char const *path)
{
  char *tmp;
  tmp = realpath(path,(char *)0);
  return tmp;
}

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    requires
      separation:
        \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memcpy(void * restrict dest, void const * restrict src, size_t n)
{
  {
    size_t i = (size_t)0;
    /*@ loop invariant no_eva: 0 ≤ i ≤ n;
        loop invariant
          no_eva:
            ∀ ℤ k;
              0 ≤ k < i ⇒ *((char *)dest + k) ≡ *((char *)src + k);
        loop assigns i, *((char *)dest + (0 .. n - 1));
        loop variant n - i;
    */
    while (i < n) {
      *((char *)dest + i) = *((char *)src + i);
      i ++;
    }
  }
  return dest;
}

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    requires
      separation:
        \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_next_byte: \result ≡ \old(dest) + \old(n);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest, n;
 */
void *mempcpy(void * restrict dest, void const * restrict src, size_t n)
{
  void *__retres;
  size_t i;
  i = (size_t)0;
  /*@ loop invariant no_eva: 0 ≤ i ≤ n;
      loop invariant
        no_eva:
          ∀ ℤ k;
            0 ≤ k < i ⇒ *((char *)dest + k) ≡ *((char *)src + k);
      loop assigns i, *((char *)dest + (0 .. n - 1));
      loop variant n - i;
  */
  while (i < n) {
    *((char *)dest + i) = *((char *)src + i);
    i ++;
  }
  __retres = (void *)((char *)dest + i);
  return __retres;
}

/*@ assigns \result;
    assigns \result \from (indirect: p), (indirect: q), (indirect: n);
    
    behavior separated:
      assumes
        separation: no_overlap:
          \separated(p + (0 .. n - 1), q + (0 .. n - 1));
      ensures result_no_overlap: \result ≡ 0;
    
    behavior not_separated_lt:
      assumes
        separation: overlap: ¬\separated(p + (0 .. n - 1), q + (0 .. n - 1));
      assumes p_before_q: p ≤ q < p + n;
      ensures result_p_before_q: \result ≡ -1;
    
    behavior not_separated_gt:
      assumes
        separation: overlap: ¬\separated(p + (0 .. n - 1), q + (0 .. n - 1));
      assumes p_after_q: q < p ≤ q + n;
      ensures result_p_after_q: \result ≡ 1;
    
    complete behaviors not_separated_gt, not_separated_lt, separated;
    disjoint behaviors not_separated_gt, not_separated_lt, separated;
 */
static int memoverlap(char const *p, char const *q, size_t n)
{
  int __retres;
  uintptr_t p1 = (uintptr_t)p;
  uintptr_t p2 = (uintptr_t)(p + n);
  uintptr_t q1 = (uintptr_t)q;
  uintptr_t q2 = (uintptr_t)(q + n);
  if (p1 <= q1) {
    if (p2 > q1) {
      __retres = -1;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (q1 <= p1) 
      if (q2 > p1) {
        __retres = 1;
        goto return_label;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    else {
      __retres = 0;
      goto return_label;
    }
  }
  return_label: return __retres;
}

/*@ requires valid_dest: valid_or_empty(dest, n);
    requires valid_src: valid_read_or_empty(src, n);
    ensures
      copied_contents:
        memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡
        0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memmove(void *dest, void const *src, size_t n)
{
  void *__retres;
  int tmp;
  if (n == (size_t)0) {
    __retres = dest;
    goto return_label;
  }
  char *s = (char *)src;
  char *d = (char *)dest;
  tmp = memoverlap((char const *)dest,(char const *)src,n);
  if (tmp <= 0) {
    size_t i = (size_t)0;
    /*@ loop invariant no_eva: 0 ≤ i ≤ n;
        loop invariant
          no_eva:
            ∀ ℤ k;
              0 ≤ k < i ⇒
              *((char *)dest + k) ≡ \at(*((char *)src + k),LoopEntry);
        loop invariant
          no_eva:
            ∀ ℤ k;
              i ≤ k < n ⇒
              *((char *)src + k) ≡ \at(*((char *)src + k),LoopEntry);
        loop assigns i, *((char *)dest + (0 .. n - 1));
        loop variant n - i;
    */
    while (i < n) {
      *(d + i) = *(s + i);
      i ++;
    }
  }
  else {
    {
      size_t i_0 = n - (size_t)1;
      /*@ loop invariant no_eva: 0 ≤ i_0 < n;
          loop invariant
            no_eva:
              ∀ ℤ k;
                i_0 < k < n ⇒
                *((char *)dest + k) ≡ \at(*((char *)src + k),LoopEntry);
          loop invariant
            no_eva:
              ∀ ℤ k;
                0 ≤ k ≤ i_0 ⇒
                *((char *)src + k) ≡ \at(*((char *)src + k),LoopEntry);
          loop assigns i_0, *((char *)dest + (0 .. n - 1));
          loop variant i_0;
      */
      while (i_0 > (size_t)0) {
        *(d + i_0) = *(s + i_0);
        i_0 --;
      }
    }
    *(d + 0) = *(s + 0);
  }
  __retres = dest;
  return_label: return __retres;
}

/*@ requires valid_string_s: valid_read_string(s);
    ensures acsl_c_equiv: \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from (indirect: *(s + (0 ..)));
 */
size_t strlen(char const *s)
{
  size_t i;
  i = (size_t)0;
  while ((int)*(s + i) != 0) i ++;
  return i;
}

/*@ requires valid_string_s: valid_read_nstring(s, maxlen);
    ensures
      result_bounded:
        \result ≡ strlen(\old(s)) ∨ \result ≡ \old(maxlen);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. maxlen - 1))), (indirect: maxlen);
 */
size_t strnlen(char const *s, size_t maxlen)
{
  size_t i;
  i = (size_t)0;
  while (1) {
    if (i < maxlen) {
      if (! ((int)*(s + i) != 0)) break;
    }
    else break;
    i ++;
  }
  return i;
}

/*@ requires valid_s: valid_or_empty(s, n);
    ensures
      acsl_c_equiv: memset((char *)\old(s), \old(c), \old(n)) ≡ \true;
    ensures result_ptr: \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
void *memset(void *s, int c, size_t n)
{
  unsigned char *p = (unsigned char *)s;
  {
    size_t i = (size_t)0;
    while (i < n) {
      *(p + i) = (unsigned char)c;
      i ++;
    }
  }
  return s;
}

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures acsl_c_equiv: \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcmp(char const *s1, char const *s2)
{
  int __retres;
  size_t i;
  i = (size_t)0;
  while ((int)*(s1 + i) == (int)*(s2 + i)) {
    if ((int)*(s1 + i) == 0) {
      __retres = 0;
      goto return_label;
    }
    i ++;
  }
  __retres = (int)*((unsigned char *)s1 + i) - (int)*((unsigned char *)s2 + i);
  return_label: return __retres;
}

/*@ requires valid_string_s1: valid_read_nstring(s1, n);
    requires valid_string_s2: valid_read_nstring(s2, n);
    ensures acsl_c_equiv: \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
int strncmp(char const *s1, char const *s2, size_t n)
{
  int __retres;
  {
    size_t i = (size_t)0;
    while (i < n) {
      if ((int)*(s1 + i) != (int)*(s2 + i)) {
        __retres = (int)*((unsigned char *)s1 + i) - (int)*((unsigned char *)s2 + i);
        goto return_label;
      }
      if ((int)*(s1 + i) == 0) {
        __retres = 0;
        goto return_label;
      }
      i ++;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_s1: valid_read_or_empty(s1, n);
    requires valid_s2: valid_read_or_empty(s2, n);
    requires initialization: s1: \initialized((char *)s1 + (0 .. n - 1));
    requires initialization: s2: \initialized((char *)s2 + (0 .. n - 1));
    requires danglingness: s1: non_escaping(s1, n);
    requires danglingness: s2: non_escaping(s2, n);
    ensures
      logic_spec:
        \result ≡
        memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from (indirect: *((char *)s1 + (0 .. n - 1))),
            (indirect: *((char *)s2 + (0 .. n - 1)));
 */
int memcmp(void const *s1, void const *s2, size_t n)
{
  int __retres;
  unsigned char const *p1;
  unsigned char const *p2;
  p1 = (unsigned char const *)s1;
  p2 = (unsigned char const *)s2;
  {
    size_t i = (size_t)0;
    while (i < n) {
      if ((int)*(p1 + i) != (int)*(p2 + i)) {
        __retres = (int)*(p1 + i) - (int)*(p2 + i);
        goto return_label;
      }
      i ++;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int char_equal_ignore_case(char c1, char c2)
{
  int __retres;
  if ((int)c1 >= 'A') 
    if ((int)c1 <= 'Z') c1 = (char)((int)c1 - ('A' - 'a'));
  if ((int)c2 >= 'A') 
    if ((int)c2 <= 'Z') c2 = (char)((int)c2 - ('A' - 'a'));
  if ((int)c1 == (int)c2) {
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = (int)((unsigned char)c2) - (int)((unsigned char)c1);
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
int strcasecmp(char const *s1, char const *s2)
{
  int __retres;
  size_t i;
  i = (size_t)0;
  while (1) {
    if ((int)*(s1 + i) != 0) {
      if (! ((int)*(s2 + i) != 0)) break;
    }
    else break;
    {
      int res = char_equal_ignore_case(*(s1 + i),*(s2 + i));
      if (res != 0) {
        __retres = res;
        goto return_label;
      }
    }
    i ++;
  }
  if ((int)*(s1 + i) == 0) {
    if ((int)*(s2 + i) == 0) {
      __retres = 0;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)*(s1 + i) == 0) {
      __retres = -1;
      goto return_label;
    }
    else {
      __retres = 1;
      goto return_label;
    }
  }
  return_label: return __retres;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dest: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures
      sum_of_lengths: strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures
      initialization: dest:
        \initialized(\old(dest) + (0 .. \old(strlen(dest) + strlen(src))));
    ensures
      dest_null_terminated:
        *(\old(dest) + \old(strlen(dest) + strlen(src))) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcat(char *dest, char const *src)
{
  size_t i;
  size_t n = strlen((char const *)dest);
  i = (size_t)0;
  while ((int)*(src + i) != 0) {
    *(dest + (n + i)) = *(src + i);
    i ++;
  }
  *(dest + (n + i)) = (char)0;
  return dest;
}

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires valid_string_dest: valid_string(dest);
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes
        valid_string_src_fits: valid_read_string(src) ∧ strlen(src) ≤ n;
      requires
        room_string: \valid((dest + strlen(dest)) + (0 .. strlen(src)));
      ensures
        sum_of_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes
        valid_string_src_too_large:
          ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      requires room_string: \valid((dest + strlen(dest)) + (0 .. n));
      ensures
        sum_of_bounded_lengths:
          strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
char *strncat(char *dest, char const *src, size_t n)
{
  size_t i;
  size_t dest_len = strlen((char const *)dest);
  i = (size_t)0;
  while (i < n) {
    if ((int)*(src + i) == 0) break;
    *(dest + (dest_len + i)) = *(src + i);
    i ++;
  }
  *(dest + (dest_len + i)) = (char)0;
  return dest;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcpy(char *dest, char const *src)
{
  size_t i;
  i = (size_t)0;
  while ((int)*(src + i) != 0) {
    *(dest + i) = *(src + i);
    i ++;
  }
  *(dest + i) = (char)0;
  return dest;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    requires
      separation:
        \separated(dest + (0 .. strlen(src)), src + (0 .. strlen(src)));
    ensures equal_contents: strcmp(\old(dest), \old(src)) ≡ 0;
    ensures points_to_end: \result ≡ \old(dest) + strlen(\old(dest));
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *stpcpy(char *dest, char const *src)
{
  char *__retres;
  size_t i;
  i = (size_t)0;
  while ((int)*(src + i) != 0) {
    *(dest + i) = *(src + i);
    i ++;
  }
  *(dest + i) = (char)0;
  __retres = dest + i;
  return __retres;
}

/*@ requires valid_nstring_src: valid_read_nstring(src, n);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    requires separation: \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    ensures initialization: \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes src_fits: strlen(src) < n;
      ensures equal_after_copy: strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes src_too_long: n ≤ strlen(src);
      ensures
        equal_prefix:
          memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
char *strncpy(char *dest, char const *src, size_t n)
{
  size_t i;
  i = (size_t)0;
  while (i < n) {
    *(dest + i) = *(src + i);
    if ((int)*(src + i) == 0) break;
    i ++;
  }
  while (i < n) {
    *(dest + i) = (char)0;
    i ++;
  }
  return dest;
}

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: c);
    
    behavior found:
      assumes char_found: strchr(s, c) ≡ \true;
      ensures result_char: *\result ≡ (char)\old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures
        result_in_length: \old(s) ≤ \result ≤ \old(s) + strlen(\old(s));
      ensures result_valid_string: valid_read_string(\result);
      ensures
        result_first_occur:
          ∀ char *p; \old(s) ≤ p < \result ⇒ *p ≢ (char)\old(c);
    
    behavior not_found:
      assumes char_not_found: ¬(strchr(s, c) ≡ \true);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strchr(char const *s, int c)
{
  char *__retres;
  size_t i;
  char const ch = (char)c;
  i = (size_t)0;
  while ((int)*(s + i) != (int)ch) {
    if ((int)*(s + i) == 0) {
      __retres = (char *)0;
      goto return_label;
    }
    i ++;
  }
  __retres = (char *)(s + i);
  return_label: return __retres;
}

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes char_found: strchr(s, c) ≡ \true;
      ensures result_char: (int)*\result ≡ \old(c);
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_valid_string: valid_read_string(\result);
    
    behavior not_found:
      assumes char_not_found: ¬(strchr(s, c) ≡ \true);
      ensures result_null: \result ≡ \null;
    
    behavior default:
      ensures
        result_null_or_same_base:
          \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strrchr(char const *s, int c)
{
  char *__retres;
  char const ch = (char)c;
  {
    size_t tmp;
    tmp = strlen(s);
    size_t i = tmp + (size_t)1;
    while (i > (size_t)0) {
      if ((int)*(s + (i - (size_t)1)) == (int)ch) {
        __retres = (char *)(s + (i - (size_t)1));
        goto return_label;
      }
      i --;
    }
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ requires
      valid:
        valid_read_or_empty(s, n) ∨
        \valid_read((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      initialization:
        \initialized((unsigned char *)s + (0 .. n - 1)) ∨
        \initialized((unsigned char *)s + (0 .. memchr_off((char *)s, c, n)));
    requires
      danglingness:
        non_escaping(s, n) ∨
        non_escaping(s, (size_t)(memchr_off((char *)s, c, n) + 1));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes char_found: memchr((char *)s, c, n) ≡ \true;
      ensures result_same_base: \base_addr(\result) ≡ \base_addr(\old(s));
      ensures result_char: (int)*((char *)\result) ≡ \old(c);
      ensures
        result_in_str:
          ∀ ℤ i;
            0 ≤ i < \old(n) ⇒
            *((unsigned char *)\old(s) + i) ≡ \old(c) ⇒
            (unsigned char *)\result ≤ (unsigned char *)\old(s) + i;
    
    behavior not_found:
      assumes char_not_found: ¬(memchr((char *)s, c, n) ≡ \true);
      ensures result_null: \result ≡ \null;
 */
void *memchr(void const *s, int c, size_t n)
{
  void *__retres;
  unsigned char const ch = (unsigned char)c;
  unsigned char const *ss = (unsigned char const *)s;
  {
    size_t i = (size_t)0;
    while (i < n) {
      if ((int)*(ss + i) == (int)ch) {
        __retres = (void *)(ss + i);
        goto return_label;
      }
      i ++;
    }
  }
  __retres = (void *)0;
  return_label: return __retres;
}

void *memrchr(void const *s, int c, size_t n)
{
  void *__retres;
  unsigned char const ch = (unsigned char)c;
  unsigned char const *ss = (unsigned char const *)s;
  {
    size_t i = n;
    while (i > (size_t)0) {
      if ((int)*(ss + (i - (size_t)1)) == (int)ch) {
        __retres = (void *)(ss + (i - (size_t)1));
        goto return_label;
      }
      i --;
    }
  }
  __retres = (void *)0;
  return_label: return __retres;
}

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      result_null_or_in_haystack:
        \result ≡ \null ∨
        (\subset(\result, \old(haystack) + (0 ..)) ∧
         \valid_read(\result) ∧
         memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strstr(char const *haystack, char const *needle)
{
  char *__retres;
  if ((int)*(needle + 0) == 0) {
    __retres = (char *)haystack;
    goto return_label;
  }
  {
    size_t i = (size_t)0;
    while ((int)*(haystack + i) != 0) {
      {
        size_t j;
        j = (size_t)0;
        while ((int)*(haystack + (i + j)) != 0) {
          if ((int)*(haystack + (i + j)) != (int)*(needle + j)) break;
          j ++;
        }
        if ((int)*(needle + j) == 0) {
          __retres = (char *)(haystack + i);
          goto return_label;
        }
      }
      i ++;
    }
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static int strerror___fc_strerror_init;
/*@ ensures result_internal_str: \result ≡ __fc_p_strerror;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strerror, (indirect: errnum);
 */
char *strerror(int errnum)
{
  char *__retres;
  if (! strerror___fc_strerror_init) {
    Frama_C_make_unknown(__fc_strerror,(size_t)63);
    __fc_strerror[63] = (char)0;
    strerror___fc_strerror_init = 1;
  }
  __retres = __fc_strerror;
  return __retres;
}

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(strlen(s));
      ensures allocation: \fresh{Old, Here}(\result,strlen(\old(s)));
      ensures
        result_valid_string_and_same_contents:
          valid_string(\result) ∧ strcmp(\result, \old(s)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from (indirect: s), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(strlen(s));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strdup(char const *s)
{
  char *__retres;
  size_t tmp;
  tmp = strlen(s);
  size_t l = tmp + (size_t)1;
  char *p = malloc(l);
  if (! p) {
    __fc_errno = 12;
    __retres = (char *)0;
    goto return_label;
  }
  memcpy((void *)p,(void const *)s,l);
  __retres = p;
  return_label: return __retres;
}

/*@ requires valid_string_s: valid_read_string(s);
    assigns \result;
    assigns \result
      \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
            (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes can_allocate: is_allocable(\min(strlen(s), n + 1));
      ensures
        allocation:
          \fresh{Old, Here}(\result,\min(strlen(\old(s)), \old(n) + 1));
      ensures
        result_valid_string_bounded_and_same_prefix:
          \valid(\result + (0 .. \min(strlen(\old(s)), \old(n)))) ∧
          valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
          strncmp(\result, \old(s), \old(n)) ≡ 0;
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status
        \from (indirect: s), (indirect: n), __fc_heap_status;
      assigns \result
        \from (indirect: *(s + (0 .. strlen{Old}(s)))), (indirect: n),
              (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes cannot_allocate: ¬is_allocable(\min(strlen(s), n + 1));
      ensures result_null: \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
 */
char *strndup(char const *s, size_t n)
{
  char *__retres;
  size_t l;
  l = (size_t)0;
  while (l < n) {
    if ((int)*(s + l) == 0) break;
    l ++;
  }
  char *p = malloc(l + (size_t)1);
  if (! p) {
    __fc_errno = 12;
    __retres = (char *)0;
    goto return_label;
  }
  memcpy((void *)p,(void const *)s,l);
  *(p + l) = (char)0;
  __retres = p;
  return_label: return __retres;
}

static int strsignal___fc_strsignal_init;
/*@ ensures result_internal_str: \result ≡ __fc_p_strsignal;
    ensures result_nul_terminated: *(\result + 63) ≡ 0;
    ensures result_valid_string: valid_read_string(\result);
    assigns \result;
    assigns \result \from __fc_p_strsignal, (indirect: signum);
 */
char *strsignal(int signum)
{
  char *__retres;
  if (! strsignal___fc_strsignal_init) {
    Frama_C_make_unknown(__fc_strsignal,(size_t)63);
    __fc_strsignal[63] = (char)0;
    strsignal___fc_strsignal_init = 1;
  }
  __retres = __fc_strsignal;
  return __retres;
}

/*@ requires
      valid_dest: valid_or_empty((void *)dest, (size_t)(sizeof(wchar_t) * n));
    requires
      valid_src:
        valid_read_or_empty((void *)src, (size_t)(sizeof(wchar_t) * n));
    requires
      separation: dest: src:
        \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
wchar_t *wmemcpy(wchar_t *dest, wchar_t const *src, size_t n)
{
  {
    size_t i = (size_t)0;
    while (i < n) {
      *(dest + i) = *(src + i);
      i ++;
    }
  }
  return dest;
}

/*@ requires valid_wcs: \valid(dest + (0 .. len - 1));
    ensures result_ptr: \result ≡ \old(dest);
    ensures
      initialization: wcs: \initialized(\old(dest) + (0 .. \old(len) - 1));
    ensures
      contents_equal_wc:
        \subset(*(\old(dest) + (0 .. \old(len) - 1)), \old(val));
    assigns *(dest + (0 .. len - 1)), \result;
    assigns *(dest + (0 .. len - 1)) \from val, (indirect: len);
    assigns \result \from dest;
 */
wchar_t *wmemset(wchar_t *dest, wchar_t val, size_t len)
{
  {
    size_t i = (size_t)0;
    while (i < len) {
      *(dest + i) = val;
      i ++;
    }
  }
  return dest;
}

/*@ requires valid_wstring_src: valid_read_wstring(src);
    requires room_wstring: \valid(dest + (0 .. wcslen(src)));
    requires
      separation:
        \separated(dest + (0 .. wcslen(src)), src + (0 .. wcslen(src)));
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 .. wcslen{Old}(src))), \result;
    assigns *(dest + (0 .. wcslen{Old}(src)))
      \from *(src + (0 .. wcslen{Old}(src))), (indirect: src);
    assigns \result \from dest;
 */
wchar_t *wcscpy(wchar_t *dest, wchar_t const *src)
{
  size_t i;
  i = (size_t)0;
  while (*(src + i) != 0) {
    *(dest + i) = *(src + i);
    i ++;
  }
  *(dest + i) = 0;
  return dest;
}

/*@ requires valid_string_s: valid_read_wstring(str);
    ensures result_is_length: \result ≡ wcslen(\old(str));
    assigns \result;
    assigns \result \from (indirect: *(str + (0 .. wcslen{Old}(str))));
 */
size_t wcslen(wchar_t const *str)
{
  size_t i;
  i = (size_t)0;
  while (*(str + i) != 0) i ++;
  return i;
}

/*@ requires valid_wstring_src: valid_read_wstring(src);
    requires room_nwstring: \valid(dest + (0 .. n - 1));
    requires
      separation: dest: src:
        \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures result_ptr: \result ≡ \old(dest);
    ensures initialization: \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
wchar_t *wcsncpy(wchar_t *dest, wchar_t const *src, size_t n)
{
  size_t i;
  i = (size_t)0;
  while (i < n) {
    *(dest + i) = *(src + i);
    if (*(src + i) == 0) break;
    i ++;
  }
  while (i < n) {
    *(dest + i) = 0;
    i ++;
  }
  return dest;
}

/*@ requires valid_wstring_src: valid_read_wstring(src);
    requires valid_wstring_dest: valid_wstring(dest);
    requires
      room_for_concatenation:
        \valid(dest + (wcslen(dest) .. wcslen(dest) + wcslen(src)));
    requires
      separation:
        \separated(
          dest + (0 .. wcslen(dest) + wcslen(src)), src + (0 .. wcslen(src))
          );
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 ..)),
            (indirect: src);
    assigns \result \from dest;
 */
wchar_t *wcscat(wchar_t *dest, wchar_t const *src)
{
  size_t i;
  size_t n = wcslen((wchar_t const *)dest);
  i = (size_t)0;
  while (*(src + i) != 0) {
    *(dest + (n + i)) = *(src + i);
    i ++;
  }
  *(dest + (n + i)) = 0;
  return dest;
}

/*@ requires valid_nwstring_src: valid_read_nwstring(src, n);
    requires valid_wstring_dest: valid_wstring(dest);
    requires
      room_for_concatenation:
        \valid(dest + (wcslen(dest) .. wcslen(dest) + \min(wcslen(src), n)));
    requires
      separation:
        \separated(
          dest + (0 .. wcslen(dest) + wcslen(src)), src + (0 .. wcslen(src))
          );
    ensures result_ptr: \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n)
{
  size_t i;
  size_t dest_len = wcslen((wchar_t const *)dest);
  i = (size_t)0;
  while (1) {
    if (i < n) {
      if (! (*(src + i) != 0)) break;
    }
    else break;
    *(dest + (dest_len + i)) = *(src + i);
    i ++;
  }
  *(dest + (dest_len + i)) = 0;
  return dest;
}

wchar_t *wcsdup(wchar_t const *ws)
{
  wchar_t *__retres;
  size_t tmp;
  tmp = wcslen(ws);
  size_t l = tmp + (size_t)1;
  wchar_t *p = malloc(sizeof(wchar_t) * l);
  if (! p) {
    __fc_errno = 12;
    __retres = (wchar_t *)0;
    goto return_label;
  }
  wmemcpy(p,ws,l);
  __retres = p;
  return_label: return __retres;
}

/*@ ghost extern int __fc_stack_status; */

/*@ ensures allocation: \fresh{Old, Here}(\result,\old(size));
    assigns __fc_stack_status, \result;
    assigns __fc_stack_status \from size, __fc_stack_status;
    assigns \result \from (indirect: size), (indirect: __fc_stack_status);
    allocates \result;
 */
extern void *alloca(size_t size);

DIR __fc_opendir[16];
DIR * const __fc_p_opendir = __fc_opendir;
/*@ requires
      dirp_valid_dir_stream: \subset(dirp, &__fc_opendir[0 .. 16 - 1]);
    ensures
      err_or_closed_on_success:
        (\result ≡ 0 ∧ \old(dirp)->__fc_dir_inode ≡ \null) ∨
        \result ≡ -1;
    assigns \result, __fc_errno, *dirp;
    assigns \result \from dirp, *dirp, __fc_p_opendir;
    assigns __fc_errno \from dirp, *dirp, __fc_p_opendir;
    assigns *dirp \from dirp, *dirp, __fc_p_opendir;
 */
extern int closedir(DIR *dirp);

/*@ ensures result_null_or_valid: \result ≡ \null ∨ \valid(\result);
    ensures
      valid_dir_stream_on_success:
        \result ≢ \null ⇒ \result ≡ &__fc_opendir[\result->__fc_dir_id];
    ensures
      stream_positioned_on_success:
        \result ≢ \null ⇒ \result->__fc_dir_inode ≢ \null;
    assigns \result, __fc_errno;
    assigns \result \from *(path + (0 ..)), __fc_p_opendir;
    assigns __fc_errno \from *(path + (0 ..)), __fc_p_opendir;
 */
extern DIR *opendir(char const *path);

/*@ requires
      dirp_valid_dir_stream: \subset(dirp, &__fc_opendir[0 .. 16 - 1]);
    ensures result_null_or_valid: \result ≡ \null ∨ \valid(\result);
    assigns \result, dirp->__fc_dir_position, __fc_errno;
    assigns \result \from *dirp, __fc_p_opendir;
    assigns dirp->__fc_dir_position \from dirp->__fc_dir_position;
    assigns __fc_errno \from dirp, *dirp, __fc_p_opendir;
 */
extern struct dirent *readdir(DIR *dirp);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    ensures never_terminates: \false;
    
    assigns \exit_status \from eval;
 */
void err(int eval, char const *fmt, void * const *__va_params);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    ensures never_terminates: \false;
    
    assigns \exit_status \from eval;
 */
void errx(int eval, char const *fmt, void * const *__va_params);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    assigns \nothing;
 */
void warn(char const *fmt, void * const *__va_params);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    assigns \nothing;
 */
void warnx(char const *fmt, void * const *__va_params);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    ensures never_terminates: \false;
    
    assigns \exit_status \from eval;
 */
void verr(int eval, char const *fmt, va_list args);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    ensures never_terminates: \false;
    
    assigns \exit_status \from eval;
 */
void verrx(int eval, char const *fmt, va_list args);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    assigns \nothing;
 */
void vwarn(char const *fmt, va_list args);

/*@ requires
      fmt_valid_read_or_null: valid_read_string(fmt) ∨ fmt ≡ \null;
    assigns \nothing;
 */
void vwarnx(char const *fmt, va_list args);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (int)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (int)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_sadd_overflow(int a, int b, int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (long)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_saddl_overflow(long a, long b, long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long long)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (long long)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_saddll_overflow(long long a, long long b, long long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned int)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (unsigned int)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_uadd_overflow(unsigned int a, unsigned int b,
                              unsigned int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned long)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (unsigned long)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_uaddl_overflow(unsigned long a, unsigned long b,
                               unsigned long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures
      res_wrapped: *\old(res) ≡ (unsigned long long)(\old(a) + \old(b));
    ensures
      result_overflow:
        \old(a) + \old(b) ≡ (unsigned long long)(\old(a) + \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_uaddll_overflow(unsigned long long a, unsigned long long b,
                                unsigned long long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (int)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (int)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_ssub_overflow(int a, int b, int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (long)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_ssubl_overflow(long a, long b, long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long long)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (long long)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_ssubll_overflow(long long a, long long b, long long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned int)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (unsigned int)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_usub_overflow(unsigned int a, unsigned int b,
                              unsigned int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned long)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (unsigned long)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_usubl_overflow(unsigned long a, unsigned long b,
                               unsigned long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures
      res_wrapped: *\old(res) ≡ (unsigned long long)(\old(a) - \old(b));
    ensures
      result_overflow:
        \old(a) - \old(b) ≡ (unsigned long long)(\old(a) - \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_usubll_overflow(unsigned long long a, unsigned long long b,
                                unsigned long long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (int)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (int)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_smul_overflow(int a, int b, int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (long)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_smull_overflow(long a, long b, long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (long long)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (long long)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_smulll_overflow(long long a, long long b, long long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned int)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (unsigned int)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_umul_overflow(unsigned int a, unsigned int b,
                              unsigned int *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures res_wrapped: *\old(res) ≡ (unsigned long)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (unsigned long)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_umull_overflow(unsigned long a, unsigned long b,
                               unsigned long *res);

/*@ requires valid_res: \valid(res);
    ensures initialization: res: \initialized(\old(res));
    ensures
      res_wrapped: *\old(res) ≡ (unsigned long long)(\old(a) * \old(b));
    ensures
      result_overflow:
        \old(a) * \old(b) ≡ (unsigned long long)(\old(a) * \old(b))?
          \result ≡ 0:
          \result ≡ 1;
    assigns \result, *res;
    assigns \result \from a, b;
    assigns *res \from a, b;
 */
_Bool __builtin_umulll_overflow(unsigned long long a, unsigned long long b,
                                unsigned long long *res);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_clz(unsigned int x);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_clzl(unsigned long x);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_clzll(unsigned long long x);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_ctz(unsigned int x);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_ctzl(unsigned long x);

/*@ requires x_nonzero: x ≢ 0;
    ensures result_is_bit_count: 0 ≤ \result < 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_ctzll(unsigned long long x);

/*@ ensures result_is_bit_count: 0 ≤ \result ≤ 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_popcount(unsigned int x);

/*@ ensures result_is_bit_count: 0 ≤ \result ≤ 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_popcountl(unsigned long x);

/*@ ensures result_is_bit_count: 0 ≤ \result ≤ 8 * sizeof(\old(x));
    assigns \result;
    assigns \result \from (indirect: x);
 */
int __builtin_popcountll(unsigned long long x);

/*@ assigns \nothing; */
void __sync_synchronize(void);

/*@ logic 𝔹 bit_test(ℤ x, ℤ pos) = (x & (1 << pos)) ≢ 0;

*/
/*@ requires valid_filename: valid_read_string(filename);
    assigns \result;
    assigns \result \from (indirect: *(filename + (0 ..))), (indirect: mode);
 */
extern int creat(char const *filename, mode_t mode);

/*@ assigns \result;
    assigns \result \from fd, cmd; */
extern int fcntl(int fd, int cmd, void * const *__va_params);

/*@ requires valid_filename: valid_read_string(filename);
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: *(filename + (0 ..))), (indirect: flags);
 */
extern int open(char const *filename, int flags, void * const *__va_params);

/*@ requires valid_filename: valid_read_string(filename);
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: dirfd), (indirect: *(filename + (0 ..))),
            (indirect: flags);
 */
extern int openat(int dirfd, char const *filename, int flags,
                  void * const *__va_params);

/*@ requires cmd_has_void_arg: cmd ≡ 1 ∨ cmd ≡ 3 ∨ cmd ≡ 9;
    assigns \result;
    assigns \result \from fd, cmd;
 */
extern int __va_fcntl_void(int fd, int cmd);

/*@ requires
      cmd_has_int_arg:
        cmd ≡ 0 ∨ cmd ≡ 0x406 ∨ cmd ≡ 4 ∨ cmd ≡ 8 ∨ cmd ≡ 2;
    assigns \result;
    assigns \result \from fd, cmd, arg;
 */
extern int __va_fcntl_int(int fd, int cmd, int arg);

/*@ requires cmd_as_flock_arg: cmd ≡ 5 ∨ cmd ≡ 6 ∨ cmd ≡ 7;
    requires valid_arg: \valid(arg);
    assigns \result, *arg;
    assigns \result \from fd, cmd, *arg;
    assigns *arg \from fd, cmd, *arg;
 */
extern int __va_fcntl_flock(int fd, int cmd, struct flock *arg);

/*@ requires valid_filename: valid_read_string(filename);
    requires flag_not_CREAT: (flags & 0x40) ≡ 0;
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: *(filename + (0 ..))), (indirect: flags);
 */
extern int __va_open_void(char const *filename, int flags);

/*@ requires valid_filename: valid_read_string(filename);
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: *(filename + (0 ..))), (indirect: flags),
            (indirect: mode);
 */
extern int __va_open_mode_t(char const *filename, int flags, mode_t mode);

/*@ requires valid_filename: valid_read_string(filename);
    requires flag_not_CREAT: (flags & 0x40) ≡ 0;
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: dirfd), (indirect: *(filename + (0 ..))),
            (indirect: flags);
 */
extern int __va_openat_void(int dirfd, char const *filename, int flags);

/*@ requires valid_filename: valid_read_string(filename);
    ensures valid_fd_or_error: \result ≡ -1 ∨ (0 ≤ \result < 1024);
    assigns \result;
    assigns \result
      \from (indirect: dirfd), (indirect: *(filename + (0 ..))),
            (indirect: flags), (indirect: mode);
 */
extern int __va_openat_mode_t(int dirfd, char const *filename, int flags,
                              mode_t mode);

/*@ ghost int volatile __fc_fds_state; */
/*@ requires nfds: nfds ≥ 0;
    requires readfs: readfds ≡ \null ∨ \valid(readfds);
    requires writefds: writefds ≡ \null ∨ \valid(writefds);
    requires errorfds: errorfds ≡ \null ∨ \valid(errorfds);
    requires timeout: timeout ≡ \null ∨ \valid(timeout);
    assigns __fc_fds_state, *readfds, *writefds, *errorfds, *timeout,
            \result;
    assigns __fc_fds_state \from __fc_fds_state;
    assigns *readfds
      \from (indirect: nfds), (indirect: readfds), (indirect: *readfds),
            (indirect: writefds), (indirect: *writefds),
            (indirect: errorfds), (indirect: *errorfds), (indirect: timeout),
            (indirect: *timeout), __fc_fds_state;
    assigns *writefds
      \from (indirect: nfds), (indirect: readfds), (indirect: *readfds),
            (indirect: writefds), (indirect: *writefds),
            (indirect: errorfds), (indirect: *errorfds), (indirect: timeout),
            (indirect: *timeout), __fc_fds_state;
    assigns *errorfds
      \from (indirect: nfds), (indirect: readfds), (indirect: *readfds),
            (indirect: writefds), (indirect: *writefds),
            (indirect: errorfds), (indirect: *errorfds), (indirect: timeout),
            (indirect: *timeout), __fc_fds_state;
    assigns *timeout
      \from (indirect: nfds), (indirect: readfds), (indirect: *readfds),
            (indirect: writefds), (indirect: *writefds),
            (indirect: errorfds), (indirect: *errorfds), (indirect: timeout),
            (indirect: *timeout), __fc_fds_state;
    assigns \result
      \from (indirect: nfds), (indirect: readfds), (indirect: *readfds),
            (indirect: writefds), (indirect: *writefds),
            (indirect: errorfds), (indirect: *errorfds), (indirect: timeout),
            (indirect: *timeout), __fc_fds_state;
    
    behavior read_notnull:
      assumes readfds_is_not_null: readfds ≢ \null;
      ensures initialization: readfds: \initialized(\old(readfds));
    
    behavior write_notnull:
      assumes writefds_is_not_null: writefds ≢ \null;
      ensures initialization: writefds: \initialized(\old(writefds));
    
    behavior error_notnull:
      assumes errorfds_is_not_null: errorfds ≢ \null;
      ensures initialization: errorfds: \initialized(\old(errorfds));
    
    behavior timeout_notnull:
      assumes timeout_is_not_null: timeout ≢ \null;
      ensures initialization: timeout: \initialized(\old(timeout));
 */
extern int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *errorfds, struct timeval *timeout);

/*@ requires valid_path: valid_read_string(path);
    ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨
        __fc_errno ∈ {13, 4, 22, 40, 36, 2, 20, 1, 30};
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_errno;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: mode);
    assigns __fc_errno
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: mode);
 */
extern int chmod(char const *path, mode_t mode);

/*@ requires valid_path: valid_read_string(path);
    ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨
        __fc_errno ∈ {13, 9, 4, 22, 40, 36, 2, 20, 95, 1, 30};
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_errno;
    assigns \result
      \from (indirect: fd), (indirect: path),
            (indirect: *(path + (0 .. strlen{Old}(path)))), (indirect: mode),
            (indirect: flag);
    assigns __fc_errno
      \from (indirect: fd), (indirect: path),
            (indirect: *(path + (0 .. strlen{Old}(path)))), (indirect: mode),
            (indirect: flag);
 */
extern int fchmodat(int fd, char const *path, mode_t mode, int flag);

/*@ ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ∈ {9, 4, 22, 1, 30};
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_errno;
    assigns \result \from (indirect: fildes), (indirect: mode);
    assigns __fc_errno \from (indirect: fildes), (indirect: mode);
 */
extern int fchmod(int fildes, mode_t mode);

/*@ requires valid_buf: \valid(buf);
    ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨ __fc_errno ∈ {9, 5, 75};
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *buf, __fc_errno;
    assigns \result \from (indirect: fildes);
    assigns *buf \from (indirect: fildes);
    assigns __fc_errno \from (indirect: fildes);
 */
extern int fstat(int fildes, struct stat *buf);

/*@ requires valid_path: valid_read_string(path);
    requires valid_buf: \valid(buf);
    ensures
      errno_set:
        __fc_errno ≡ \old(__fc_errno) ∨
        __fc_errno ∈ {13, 9, 22, 5, 40, 36, 2, 12, 20, 75};
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *buf, __fc_errno;
    assigns \result
      \from (indirect: fd), (indirect: path),
            (indirect: *(path + (0 .. strlen{Old}(path)))), (indirect: flag);
    assigns *buf
      \from (indirect: fd), (indirect: path),
            (indirect: *(path + (0 .. strlen{Old}(path)))), (indirect: flag);
    assigns __fc_errno
      \from (indirect: fd), (indirect: path),
            (indirect: *(path + (0 .. strlen{Old}(path)))), (indirect: flag);
 */
extern int fstatat(int fd, char const * restrict path,
                   struct stat * restrict buf, int flag);

/*@ requires valid_path: valid_read_string(path);
    requires valid_buf: \valid(buf);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *buf;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path))));
    assigns *buf
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path))));
 */
extern int lstat(char const *path, struct stat *buf);

/*@ requires valid_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: mode);
 */
extern int mkdir(char const *path, mode_t mode);

/*@ requires valid_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: mode);
 */
extern int mkfifo(char const *path, mode_t mode);

/*@ requires valid_path: valid_read_string(path);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result
      \from (indirect: path), (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: mode), (indirect: dev);
 */
extern int mknod(char const *path, mode_t mode, dev_t dev);

/*@ requires valid_pathname: valid_read_string(pathname);
    requires valid_buf: \valid(buf);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    ensures
      init_on_success: initialization: buf:
        \result ≡ 0 ⇒ \initialized(\old(buf));
    assigns \result, *buf;
    assigns \result \from *(pathname + (0 .. strlen{Old}(pathname)));
    assigns *buf \from *(pathname + (0 .. strlen{Old}(pathname)));
 */
extern int stat(char const *pathname, struct stat *buf);

/*@ assigns \result;
    assigns \result \from (indirect: cmask); */
extern mode_t umask(mode_t cmask);

/*@ assigns *(*(outbuf + (0 .. *outbytesleft - 1))), __fc_errno;
    assigns *(*(outbuf + (0 .. *outbytesleft - 1)))
      \from *(*(inbuf + (0 .. *inbytesleft - 1)));
 */
extern size_t iconv(iconv_t cd, char ** restrict inbuf,
                    size_t * restrict inbytesleft, char ** restrict outbuf,
                    size_t * restrict outbytesleft);

/*@ ensures result_zero_or_neg: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_errno;
 */
extern int iconv_close(iconv_t __x0);

/*@ assigns \result, __fc_errno;
    assigns \result \from *(tocode + (..)), *(fromcode + (..));
 */
extern iconv_t iconv_open(char const *tocode, char const *fromcode);

extern char __fc_basename[256];

char *__fc_p_basename = __fc_basename;
/*@ requires
      null_or_valid_string_path: path ≡ \null ∨ valid_read_string(path);
    ensures
      result_points_to_internal_storage_or_path:
        \subset(\result, {__fc_p_basename, \old(path)});
    assigns *(path + (0 ..)), __fc_basename[0 ..], \result;
    assigns *(path + (0 ..)) \from *(path + (0 ..)), __fc_basename[0 ..];
    assigns __fc_basename[0 ..] \from *(path + (0 ..)), __fc_basename[0 ..];
    assigns \result \from __fc_p_basename, path;
 */
extern char *basename(char *path);

extern char __fc_dirname[256];

char *__fc_p_dirname = __fc_dirname;
/*@ requires
      null_or_valid_string_path: path ≡ \null ∨ valid_read_string(path);
    ensures
      result_points_to_internal_storage_or_path:
        \subset(\result, {__fc_p_dirname, \old(path)});
    assigns *(path + (0 ..)), __fc_dirname[0 ..], \result;
    assigns *(path + (0 ..)) \from *(path + (0 ..)), __fc_dirname[0 ..];
    assigns __fc_dirname[0 ..] \from *(path + (0 ..)), __fc_dirname[0 ..];
    assigns \result \from __fc_p_dirname, path;
 */
extern char *dirname(char *path);

/*@ requires valid_file_descriptors: \valid(fds + (0 .. nfds - 1));
    ensures
      error_timeout_or_bounded:
        \result ≡ -1 ∨ \result ≡ 0 ∨ (1 ≤ \result ≤ \old(nfds));
    ensures
      initialization: revents:
        \initialized(&(\old(fds) + (0 .. \old(nfds) - 1))->revents);
    assigns (fds + (0 .. nfds - 1))->revents, \result;
    assigns (fds + (0 .. nfds - 1))->revents
      \from (indirect: (fds + (0 .. nfds - 1))->fd),
            (fds + (0 .. nfds - 1))->events, (indirect: nfds),
            (indirect: timeout), (indirect: Frama_C_entropy_source);
    assigns \result
      \from (indirect: (fds + (0 .. nfds - 1))->fd),
            (indirect: (fds + (0 .. nfds - 1))->events), (indirect: nfds),
            (indirect: timeout), (indirect: Frama_C_entropy_source);
 */
extern int poll(struct pollfd *fds, nfds_t nfds, int timeout);

/*@ requires valid_cond: \valid(cond);
    ensures sucess: \result ≡ 0;
    assigns \result;
    assigns \result \from \nothing;
 */
extern int pthread_cond_broadcast(pthread_cond_t *cond);

/*@ requires valid_cond: \valid(cond);
    ensures success_or_error: \result ≡ 0 ∨ \result ≡ 16;
    assigns \result;
    assigns \result \from (indirect: *cond);
 */
extern int pthread_cond_destroy(pthread_cond_t *cond);

/*@ requires valid_cond: \valid(cond);
    requires valid_null_attr: attr ≡ \null ∨ \valid_read(attr);
    ensures initialization: cond: \initialized(\old(cond));
    ensures success: \result ≡ 0;
    assigns *cond, \result;
    assigns *cond \from *attr;
    assigns \result \from \nothing;
 */
extern int pthread_cond_init(pthread_cond_t * restrict cond,
                             pthread_condattr_t const * restrict attr);

/*@ requires valid_cond: \valid(cond);
    requires valid_mutex: \valid(mutex);
    ensures success: \result ≡ 0;
    assigns \result;
    assigns \result \from \nothing;
 */
extern int pthread_cond_wait(pthread_cond_t * restrict cond,
                             pthread_mutex_t * restrict mutex);

/*@ requires valid_thread: \valid(thread);
    requires valid_null_attr: attr ≡ \null ∨ \valid_read(attr);
    requires valid_routine: \valid_function(start_routine);
    requires valid_null_arg: arg ≡ \null ∨ \valid((char *)arg);
    ensures
      success_or_error:
        \result ≡ 0 ∨ \result ≡ 11 ∨ \result ≡ 22 ∨ \result ≡ 1;
    assigns *thread, \result;
    assigns *thread \from *attr;
    assigns \result \from (indirect: *attr);
 */
extern int pthread_create(pthread_t * restrict thread,
                          pthread_attr_t const * restrict attr,
                          void *(*start_routine)(void *), void * restrict arg);

/*@ requires valid_or_null_retval: retval ≡ \null ∨ \valid(retval);
    ensures
      success_or_error:
        \result ≡ 0 ∨ \result ≡ 35 ∨ \result ≡ 22 ∨ \result ≡ 3;
    assigns *retval, \result;
    assigns *retval \from thread;
    assigns \result \from (indirect: thread);
    
    behavior ignore_retval:
      assumes null_retval: retval ≡ \null;
      assigns \result;
      assigns \result \from (indirect: thread);
    
    behavior use_retval:
      assumes valid_retval: \valid(retval);
      assigns *retval, \result;
      assigns *retval \from thread;
      assigns \result \from (indirect: thread);
 */
extern int pthread_join(pthread_t thread, void **retval);

/*@ requires mutex_valid: \valid(mutex);
    ensures init_or_busy: \result ≡ 0 ∨ \result ≡ 16;
    assigns *mutex, \result;
    assigns *mutex \from *mutex;
    assigns \result \from (indirect: *mutex);
 */
extern int pthread_mutex_destroy(pthread_mutex_t *mutex);

/*@ requires mutex_valid: \valid(mutex);
    requires attrs_valid_or_null: attrs ≡ \null ∨ \valid_read(attrs);
    ensures
      initialization: success_or_error:
        (\result ≡ 0 ∧ \initialized(\old(mutex))) ∨ \result ≡ 11 ∨
        \result ≡ 12 ∨ \result ≡ 1 ∨ \result ≡ 22;
    assigns *mutex, \result;
    assigns *mutex \from *mutex, *attrs;
    assigns \result \from (indirect: *mutex), (indirect: *attrs);
 */
extern int pthread_mutex_init(pthread_mutex_t * restrict mutex,
                              pthread_mutexattr_t const * restrict attrs);

/*@ requires mutex_valid: \valid(mutex);
    ensures
      success_or_error:
        \result ≡ 0 ∨ \result ≡ 11 ∨ \result ≡ 22 ∨
        \result ≡ 35;
    assigns *mutex, \result;
    assigns *mutex \from *mutex;
    assigns \result \from (indirect: *mutex);
 */
extern int pthread_mutex_lock(pthread_mutex_t *mutex);

/*@ requires mutex_valid: \valid(mutex);
    ensures success_or_error: \result ≡ 0 ∨ \result ≡ 1;
    assigns *mutex, \result;
    assigns *mutex \from *mutex;
    assigns \result \from (indirect: *mutex);
 */
extern int pthread_mutex_unlock(pthread_mutex_t *mutex);

/*@ requires valid_attr: \valid(attr);
    ensures success_or_error: \result ≡ 0 ∨ \result ≡ 22;
    assigns *attr, \result;
    assigns *attr \from *attr;
    assigns \result \from (indirect: *attr);
 */
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

/*@ requires valid_attr: \valid(attr);
    ensures success_or_error: \result ≡ 0 ∨ \result ≡ 12;
    assigns \result, *attr;
    assigns \result \from \nothing;
    assigns *attr \from \nothing;
 */
extern int pthread_mutexattr_init(pthread_mutexattr_t *attr);

/*@ requires valid_attr: \valid(attr);
    ensures success_or_error: \result ≡ 0 ∨ \result ≡ 22;
    assigns \result, *attr;
    assigns \result \from (indirect: type);
    assigns *attr \from (indirect: type);
 */
extern int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

/*@ requires valid_name: valid_read_string(name);
    assigns \result;
    assigns \result
      \from (indirect: thread),
            (indirect: *(name + (0 .. strlen{Old}(name))));
 */
int pthread_setname_np(pthread_t thread, char const *name);

/*@ requires valid_name: \valid(name + (0 .. len - 1));
    ensures
      name_written: initialization:
        \result ≡ 0 ⇒
        valid_string(\old(name)) ∧
        \initialized(\old(name) + (0 .. strlen(\old(name))));
    assigns \result, *(name + (0 .. len - 1));
    assigns \result \from thread;
    assigns *(name + (0 .. len - 1)) \from thread;
 */
int pthread_getname_np(pthread_t thread, char *name, size_t len);

/*@ assigns *(env + (0 .. 4)); */
extern int setjmp(int env[5]);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern void longjmp(int env[5], int val);

/*@ ensures never_terminates: \false;
    assigns \nothing; */
extern void siglongjmp(sigjmp_buf env, int val);

/*@ assigns \result;
    assigns \result \from (indirect: fd), (indirect: request);
 */
extern int __va_ioctl_void(int fd, int request);

/*@ assigns \result;
    assigns \result
      \from (indirect: fd), (indirect: request), (indirect: arg);
 */
extern int __va_ioctl_int(int fd, int request, int arg);

/*@ assigns \result, *((char *)argp + (0 ..));
    assigns \result
      \from (indirect: fd), (indirect: request),
            (indirect: *((char *)argp + (0 ..)));
    assigns *((char *)argp + (0 ..))
      \from (indirect: fd), (indirect: request), *((char *)argp + (0 ..));
 */
extern int __va_ioctl_ptr(int fd, int request, void *argp);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from (indirect: fd), (indirect: operation);
 */
extern int flock(int fd, int operation);

CODE facilitynames[23] =
  {{.c_name = "auth", .c_val = 4 << 3},
   {.c_name = "authpriv", .c_val = 10 << 3},
   {.c_name = "cron", .c_val = 9 << 3},
   {.c_name = "daemon", .c_val = 3 << 3},
   {.c_name = "ftp", .c_val = 11 << 3},
   {.c_name = "kern", .c_val = 0 << 3},
   {.c_name = "lpr", .c_val = 6 << 3},
   {.c_name = "mail", .c_val = 2 << 3},
   {.c_name = "mark", .c_val = 24 | 0},
   {.c_name = "news", .c_val = 7 << 3},
   {.c_name = "security", .c_val = 4 << 3},
   {.c_name = "syslog", .c_val = 5 << 3},
   {.c_name = "user", .c_val = 1 << 3},
   {.c_name = "uucp", .c_val = 8 << 3},
   {.c_name = "local0", .c_val = 16 << 3},
   {.c_name = "local1", .c_val = 17 << 3},
   {.c_name = "local2", .c_val = 18 << 3},
   {.c_name = "local3", .c_val = 19 << 3},
   {.c_name = "local4", .c_val = 20 << 3},
   {.c_name = "local5", .c_val = 21 << 3},
   {.c_name = "local6", .c_val = 22 << 3},
   {.c_name = "local7", .c_val = 23 << 3},
   {.c_name = (char const *)0, .c_val = -1}};
CODE prioritynames[13] =
  {{.c_name = "alert", .c_val = 1},
   {.c_name = "crit", .c_val = 2},
   {.c_name = "debug", .c_val = 7},
   {.c_name = "emerg", .c_val = 0},
   {.c_name = "err", .c_val = 3},
   {.c_name = "error", .c_val = 3},
   {.c_name = "info", .c_val = 6},
   {.c_name = "none", .c_val = 0x10},
   {.c_name = "notice", .c_val = 5},
   {.c_name = "panic", .c_val = 0},
   {.c_name = "warn", .c_val = 4},
   {.c_name = "warning", .c_val = 4},
   {.c_name = (char const *)0, .c_val = -1}};
/*@ assigns \nothing; */
extern void closelog(void);

/*@ assigns \nothing; */
extern void openlog(char const *__x0, int __x1, int __x2);

/*@ assigns \nothing; */
extern int setlogmask(int __x0);

/*@ assigns \nothing; */
extern void syslog(int __x0, char const *__x1, void * const *__va_params);

/*@ assigns \nothing; */
extern void vsyslog(int __x0, char const *__x1, va_list __x2);

/*@ ghost extern int __fc_tz; */

/*@ requires valid_path: valid_read_string(path);
    requires
      valid_times_or_null: \valid_read(times + (0 .. 1)) ∨ times ≡ \null;
    assigns \result;
    assigns \result
      \from (indirect: *(path + (0 .. strlen{Old}(path)))),
            (indirect: times), (indirect: *(times + (0 .. 1)));
 */
extern int utimes(char const *path, struct timeval const times[2]);

/*@ ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns tv->tv_sec, tv->tv_usec, *((struct timezone *)tz), \result;
    assigns tv->tv_sec \from __fc_time;
    assigns tv->tv_usec \from __fc_time;
    assigns *((struct timezone *)tz) \from __fc_tz;
    assigns \result
      \from (indirect: tv), (indirect: tz), *tv, *((struct timezone *)tz),
            __fc_tz;
    
    behavior tv_and_tz_null:
      assumes null_tv_tz: tv ≡ \null ∧ tz ≡ \null;
      assigns \result;
      assigns \result \from (indirect: __fc_tz);
    
    behavior tv_not_null:
      assumes non_null_tv_null_tz: tv ≢ \null ∧ tz ≡ \null;
      ensures
        initialization: tv_sec: tv_usec:
          \initialized(&\old(tv)->tv_sec) ∧
          \initialized(&\old(tv)->tv_usec);
      ensures tv_usec_bounded: 0 ≤ \old(tv)->tv_usec ≤ 999999;
      assigns tv->tv_sec, tv->tv_usec, \result;
      assigns tv->tv_sec \from (indirect: __fc_time);
      assigns tv->tv_usec \from (indirect: __fc_time);
      assigns \result \from (indirect: *tv), (indirect: __fc_tz);
    
    behavior tz_not_null:
      assumes null_tv_non_null_tz: tv ≡ \null ∧ tz ≢ \null;
      ensures initialization: tz: \initialized((struct timezone *)\old(tz));
      assigns *((struct timezone *)tz), \result;
      assigns *((struct timezone *)tz) \from __fc_tz;
      assigns \result
        \from (indirect: *((struct timezone *)tz)), (indirect: __fc_tz);
    
    behavior tv_and_tz_not_null:
      assumes non_null_tv_tz: tv ≢ \null ∧ tz ≢ \null;
      ensures
        initialization: tv_sec: tv_usec:
          \initialized(&\old(tv)->tv_sec) ∧
          \initialized(&\old(tv)->tv_usec);
      ensures initialization: tz: \initialized((struct timezone *)\old(tz));
      assigns tv->tv_sec, tv->tv_usec, *((struct timezone *)tz), \result;
      assigns tv->tv_sec \from (indirect: __fc_time);
      assigns tv->tv_usec \from (indirect: __fc_time);
      assigns *((struct timezone *)tz) \from __fc_tz;
      assigns \result
        \from (indirect: *tv), (indirect: *((struct timezone *)tz)),
              (indirect: __fc_tz);
    
    complete behaviors tv_and_tz_not_null,
                       tz_not_null,
                       tv_not_null,
                       tv_and_tz_null;
    disjoint behaviors tv_and_tz_not_null,
                       tz_not_null,
                       tv_not_null,
                       tv_and_tz_null;
 */
extern int gettimeofday(struct timeval * restrict tv, void * restrict tz);

/*@ requires valid_tv_or_null: \valid_read(tv) ∨ tv ≡ \null;
    requires valid_tz_or_null: \valid_read(tz) ∨ tz ≡ \null;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_time, __fc_tz, \result;
    assigns __fc_time
      \from tv->tv_sec, tv->tv_usec, tz->tz_dsttime, tz->tz_minuteswest;
    assigns __fc_tz
      \from tv->tv_sec, tv->tv_usec, tz->tz_dsttime, tz->tz_minuteswest;
    assigns \result \from (indirect: *tv), (indirect: *tz);
 */
extern int settimeofday(struct timeval const *tv, struct timezone const *tz);

/*@ ghost struct itimerval volatile __fc_itimer_real; */
/*@ ghost struct itimerval volatile __fc_itimer_virtual; */
/*@ ghost struct itimerval volatile __fc_itimer_prof; */
/*@ requires valid_curr_value: \valid(curr_value);
    ensures initialization: curr_value: \initialized(\old(curr_value));
    assigns \result, *curr_value;
    assigns \result \from (indirect: which);
    assigns *curr_value
      \from __fc_itimer_real, __fc_itimer_virtual, __fc_itimer_prof;
    
    behavior real:
      assumes itimer_real: which ≡ 0;
      ensures result_ok: \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_real;
    
    behavior virtual:
      assumes itimer_virtual: which ≡ 1;
      ensures result_ok: \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_virtual;
    
    behavior prof:
      assumes itimer_prof: which ≡ 2;
      ensures result_ok: \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_prof;
    
    behavior invalid:
      assumes invalid_which: which ≢ 0 ∧ which ≢ 1 ∧ which ≢ 2;
      ensures result_error: \result ≡ -1;
      assigns \result;
      assigns \result \from \nothing;
    
    complete behaviors invalid, prof, virtual, real;
    disjoint behaviors invalid, prof, virtual, real;
 */
extern int getitimer(int which, struct itimerval *curr_value);

/*@ requires valid_new_value: \valid_read(new_value);
    requires
      old_value_null_or_valid: old_value ≡ \null ∨ \valid(old_value);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *old_value, \result;
    assigns *old_value
      \from (indirect: which), (indirect: old_value), (indirect: new_value),
            __fc_itimer_real, __fc_itimer_virtual, __fc_itimer_prof;
    assigns \result
      \from (indirect: which), (indirect: new_value), (indirect: *new_value);
    
    behavior real:
      assumes
        itimer_real_and_valid:
          which ≡ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
          0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures result_ok: \result ≡ 0;
      ensures initialization: old_value: \initialized(\old(old_value));
      assigns \result, *old_value, __fc_itimer_real;
      assigns \result \from \nothing;
      assigns *old_value \from __fc_itimer_real;
      assigns __fc_itimer_real \from *new_value;
    
    behavior virtual:
      assumes
        itimer_virtual_and_valid:
          which ≡ 1 ∧ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
          0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures result_ok: \result ≡ 0;
      ensures initialization: old_value: \initialized(\old(old_value));
      assigns \result, *old_value;
      assigns \result \from \nothing;
      assigns *old_value \from __fc_itimer_virtual;
    
    behavior prof:
      assumes
        itimer_prof_and_valid:
          which ≡ 2 ∧ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
          0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures result_ok: \result ≡ 0;
      ensures initialization: old_value: \initialized(\old(old_value));
      assigns \result, *old_value;
      assigns \result \from \nothing;
      assigns *old_value \from __fc_itimer_prof;
    
    behavior invalid:
      assumes
        invalid_itimer_or_new_value:
          (which ≢ 0 ∧ which ≢ 1 ∧ which ≢ 2) ∨
          ¬(0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
             0 ≤ new_value->it_interval.tv_usec ≤ 999999);
      ensures result_error: \result ≡ -1;
      assigns \result;
      assigns \result \from \nothing;
    
    disjoint behaviors invalid, prof, virtual, real;
 */
extern int setitimer(int which, struct itimerval const * restrict new_value,
                     struct itimerval * restrict old_value);

/*@ requires valid_fdset: \valid(fdset);
    requires initialization: \initialized(fdset);
    assigns *fdset;
    assigns *fdset \from *fdset, (indirect: fd);
 */
extern void FD_CLR(int fd, fd_set *fdset);

/*@ requires valid_fdset: \valid_read(fdset);
    requires initialization: \initialized(fdset);
    assigns \result;
    assigns \result \from (indirect: *fdset), (indirect: fd);
 */
extern int FD_ISSET(int fd, fd_set const *fdset);

/*@ requires valid_fdset: \valid(fdset);
    requires initialization: \initialized(fdset);
    assigns *fdset;
    assigns *fdset \from *fdset, (indirect: fd);
 */
extern void FD_SET(int fd, fd_set *fdset);

/*@ requires valid_fdset: \valid(fdset);
    ensures initialization: \initialized(\old(fdset));
    assigns *fdset;
    assigns *fdset \from \nothing;
 */
extern void FD_ZERO(fd_set *fdset);

/*@ assigns \result;
    assigns \result \from which, who; */
extern int getpriority(int which, id_t who);

/*@ assigns \result;
    assigns \result \from which, who, prio; */
extern int setpriority(int which, id_t who, int prio);

/*@ requires valid_rlp: \valid(rlp);
    assigns \result, *rlp;
    assigns \result \from resource;
    assigns *rlp \from resource;
 */
extern int getrlimit(int resource, struct rlimit *rlp);

/*@ requires valid_r_usage: \valid(r_usage);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *r_usage, \result;
    assigns *r_usage \from who;
    assigns \result \from (indirect: who);
 */
extern int getrusage(int who, struct rusage *r_usage);

/*@ requires valid_rlp: \valid_read(rlp);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *rlp, \result;
    assigns *rlp \from resource;
    assigns \result \from (indirect: resource), (indirect: *rlp);
 */
extern int setrlimit(int resource, struct rlimit const *rlp);

/*@ requires valid_in_fd: 0 ≤ in_fd < 1024;
    requires valid_out_fd: 0 ≤ out_fd < 1024;
    requires valid_offset_or_null: offset ≡ \null ∨ \valid(offset);
    requires
      initialization: offset: offset ≡ \null ∨ \initialized(offset);
    ensures
      error_or_chars_sent: \result ≡ -1 ∨ (0 ≤ \result ≤ \old(count));
    ensures initialization: offset: \initialized(\old(offset));
    assigns __fc_errno, \result, *offset;
    assigns __fc_errno
      \from (indirect: out_fd), (indirect: in_fd), (indirect: offset),
            (indirect: count);
    assigns \result
      \from (indirect: out_fd), (indirect: in_fd), (indirect: offset),
            (indirect: count);
    assigns *offset
      \from (indirect: out_fd), (indirect: in_fd), (indirect: offset),
            (indirect: count);
 */
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

/*@ requires valid_buffer: \valid(buffer);
    assigns \result, *buffer;
    assigns \result \from __fc_time;
    assigns *buffer \from __fc_time;
 */
extern clock_t times(struct tms *buffer);

/*@ requires valid_name: \valid(name);
    ensures result_ok_or_error: -1 ≤ \result;
    ensures initialization: name: \initialized(\old(name));
    assigns *name, \result;
    assigns *name \from \nothing;
    assigns \result \from \nothing;
 */
extern int uname(struct utsname *name);

/*@ ensures result_ok_or_error: \result ≡ -1 ∨ \result ≥ 0;
    ensures
      initialization: stat_loc_init_on_success:
        \result ≥ 0 ∧ \old(stat_loc) ≢ \null ⇒
        \initialized(\old(stat_loc));
    assigns \result, *stat_loc;
    assigns \result \from \nothing;
    assigns *stat_loc \from \nothing;
    
    behavior stat_loc_null:
      assumes stat_loc_null: stat_loc ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
    
    behavior stat_loc_non_null:
      assumes stat_loc_non_null: stat_loc ≢ \null;
      requires valid_stat_loc: \valid(stat_loc);
 */
extern pid_t wait(int *stat_loc);

/*@ ensures result_ok_or_error: \result ≡ -1 ∨ \result ≥ 0;
    ensures
      initialization: stat_loc_init_on_success:
        \result ≥ 0 ∧ \old(stat_loc) ≢ \null ⇒
        \initialized(\old(stat_loc));
    assigns \result, *stat_loc;
    assigns \result \from (indirect: options);
    assigns *stat_loc \from (indirect: options);
    
    behavior stat_loc_null:
      assumes stat_loc_null: stat_loc ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
    
    behavior stat_loc_non_null:
      assumes stat_loc_non_null: stat_loc ≢ \null;
      requires valid_stat_loc: \valid(stat_loc);
 */
extern pid_t waitpid(pid_t pid, int *stat_loc, int options);

/*@ requires valid_termios_p: \valid_read(termios_p);
    assigns \result;
    assigns \result \from (indirect: termios_p), *termios_p;
 */
extern speed_t cfgetispeed(struct termios const *termios_p);

/*@ requires valid_termios_p: \valid_read(termios_p);
    assigns \result;
    assigns \result \from (indirect: termios_p), *termios_p;
 */
extern speed_t cfgetospeed(struct termios const *termios_p);

/*@ requires valid_termios_p: \valid(termios_p);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *termios_p;
    assigns \result \from (indirect: termios_p), speed;
    assigns *termios_p \from (indirect: termios_p), speed;
 */
extern int cfsetispeed(struct termios *termios_p, speed_t speed);

/*@ requires valid_termios_p: \valid(termios_p);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, *termios_p;
    assigns \result \from (indirect: termios_p), speed;
    assigns *termios_p \from (indirect: termios_p), speed;
 */
extern int cfsetospeed(struct termios *termios_p, speed_t speed);

/*@ requires
      valid_queue_selector:
        queue_selector ≡ 0 ∨ queue_selector ≡ 1 ∨
        queue_selector ≡ 2;
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, Frama_C_entropy_source;
    assigns \result
      \from (indirect: fd), (indirect: queue_selector),
            (indirect: Frama_C_entropy_source);
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int tcflush(int fd, int queue_selector);

/*@ requires valid_termios_p: \valid(termios_p);
    assigns \result, *termios_p, Frama_C_entropy_source;
    assigns \result \from (indirect: fd), (indirect: Frama_C_entropy_source);
    assigns *termios_p
      \from (indirect: fd), (indirect: Frama_C_entropy_source);
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
    
    behavior ok:
      assumes nondet: Frama_C_entropy_source ≡ 0;
      ensures initialization: termios_p: \initialized(\old(termios_p));
      ensures result_ok: \result ≡ 0;
    
    behavior error:
      assumes nondet: Frama_C_entropy_source ≢ 0;
      ensures result_error: \result ≡ -1;
    
    complete behaviors error, ok;
    disjoint behaviors error, ok;
 */
extern int tcgetattr(int fd, struct termios *termios_p);

/*@ requires valid_termios_p: \valid(termios_p);
    ensures result_ok_or_error: \result ≡ 0 ∨ \result ≡ -1;
    assigns *termios_p, Frama_C_entropy_source, \result;
    assigns *termios_p
      \from (indirect: fd), (indirect: optional_actions),
            (indirect: Frama_C_entropy_source), *termios_p;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
    assigns \result
      \from (indirect: fd), (indirect: optional_actions),
            (indirect: Frama_C_entropy_source), (indirect: *termios_p);
 */
extern int tcsetattr(int fd, int optional_actions, struct termios *termios_p);

void main(void)
{
  /*@ assert __fc_p_fopen ≡ (FILE *)(&__fc_fopen); */ ;
  /*@ assert __fc_p_opendir ≡ (DIR *)(&__fc_opendir); */ ;
  /*@ assert __fc_p_time_tm ≡ &__fc_time_tm; */ ;
  /*@ assert __fc_p_strerror ≡ (char *)__fc_strerror; */ ;
  return;
}


