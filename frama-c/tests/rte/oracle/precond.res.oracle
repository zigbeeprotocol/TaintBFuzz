[kernel] Parsing precond.c (with preprocessing)
[kernel] precond.c:27: Warning: 
  parsing obsolete ACSL construct '\valid_range(addr,min,max)'. '\valid(addr+(min..max))' should be used instead.
[rte:annot] annotating function f
[rte:annot] annotating function g
[rte:annot] annotating function h
[rte:annot] annotating function main
[rte:annot] annotating function next_val
[rte:annot] annotating function set
[rte:annot] annotating function tabtop_set
[rte:annot] annotating function top_next
[rte:annot] annotating function top_set
/* Generated by Frama-C */
struct cell {
   int val ;
   struct cell *next ;
};
typedef struct cell cell;
struct other {
   cell c ;
};
typedef struct other other;
struct top {
   int topv ;
   cell *next ;
   cell *pred ;
};
typedef struct top top;
int global = 15;
/*@ requires x > 0;
    requires (int)(x + y) ≢ 0; */
int f(int x, int y, float z)
{
  int __retres;
  /*@ assert rte: signed_overflow: -2147483648 ≤ x + y; */
  /*@ assert rte: signed_overflow: x + y ≤ 2147483647; */
  /*@ assert rte: float_to_int: z < 2147483648; */
  /*@ assert rte: float_to_int: -2147483649 < z; */
  /*@ assert rte: signed_overflow: -2147483648 ≤ (int)(x + y) - (int)z; */
  /*@ assert rte: signed_overflow: (int)(x + y) - (int)z ≤ 2147483647; */
  __retres = (x + y) - (int)z;
  return __retres;
}

/*@
predicate is_valid_int_range{L}(int *p, int n) =
  \at(0 ≤ n ∧ \valid(p + (0 .. n - 1)),L);

*/
/*@ requires is_valid_int_range(p, i); */
int g(int *p, int i)
{
  int __retres;
  if (i >= 1) {
    /*@ assert rte: signed_overflow: -2147483648 ≤ i - 1; */
    /*@ assert rte: mem_access: \valid_read(p + (int)(i - 1)); */
    __retres = *(p + (i - 1));
    goto return_label;
  }
  else {
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires \valid((p + 1) + 3); */
int h(int *p)
{
  int __retres;
  /*@ assert rte: mem_access: \valid_read(p + 3); */
  __retres = *(p + 3);
  return __retres;
}

/*@ requires \valid(p->next);
    requires \valid(p); */
cell *set(cell *p, int v)
{
  cell *__retres;
  /*@ assert rte: mem_access: \valid(&p->val); */
  p->val = v;
  /*@ assert rte: mem_access: \valid_read(&p->next); */
  __retres = p->next;
  return __retres;
}

/*@ requires \valid(cIn.next);
    requires global > 0; */
int next_val(cell cIn)
{
  int __retres;
  /*@ assert rte: mem_access: \valid_read(&(cIn.next)->val); */
  __retres = (cIn.next)->val;
  return __retres;
}

/*@ requires \valid(ptop->next); */
cell *top_set(top *ptop, int v)
{
  cell *tmp;
  /*@ assert rte: mem_access: \valid_read(&ptop->next); */
  tmp = set(ptop->next,v);
  return tmp;
}

/*@ requires \valid(tIn.next); */
int top_next(top tIn)
{
  int tmp;
  /*@ assert rte: mem_access: \valid_read(tIn.next); */
  tmp = next_val(*(tIn.next));
  return tmp;
}

/*@ requires \valid(tab_top);
    requires \valid(&tab_top);
    requires \valid((*(tab_top + i))->next);
 */
cell *tabtop_set(top **tab_top, int i, int v)
{
  cell *tmp;
  /*@ assert rte: mem_access: \valid_read(tab_top + i); */
  tmp = top_set(*(tab_top + i),v);
  return tmp;
}

int main(void)
{
  cell *pc;
  top T;
  top tabT[2];
  top **pptop;
  void *V;
  int w;
  int *r;
  int **rr;
  int a = 2;
  int b = 3;
  cell c = {.val = 20, .next = (struct cell *)0};
  top *ptabT[3] = {& T, & T, & T};
  other ot = {.c = c};
  int k = 1;
  int l = 1;
  int z = f(2,3,(float)1.0);
  /*@ assert rte: signed_overflow: -2147483648 ≤ b - a; */
  /*@ assert rte: signed_overflow: b - a ≤ 2147483647; */
  int y = f(b - a,a,(float)2.0);
  int tab[4] = {1, 2, 3, 4};
  /*@ assert rte: signed_overflow: -2147483648 ≤ a + b; */
  /*@ assert rte: signed_overflow: a + b ≤ 2147483647; */
  z = f(y,a + b,(float)(- 0.0));
  w = g(& z,1);
  w = g(& tab[1],2);
  w = g(& tab[k],l);
  r = tab;
  rr = & r;
  w = g(r + 2,0);
  w = h(tab);
  w = h(r);
  /*@ assert rte: mem_access: \valid_read(rr); */
  w = h(*rr);
  pc = & c;
  c.next = & c;
  set(pc,15);
  set(& c,10);
  set(& c,20);
  V = (void *)(& c);
  set((cell *)V,20);
  next_val(c);
  /*@ assert rte: mem_access: \valid_read(pc); */
  next_val(*pc);
  /*@ assert rte: mem_access: \valid_read((cell *)V); */
  next_val(*((cell *)V));
  T.pred = & c;
  T.next = & c;
  tabT[0] = T;
  tabT[1] = T;
  set(T.pred,10);
  set(tabT[1].next,20);
  /*@ assert rte: mem_access: \valid_read(T.next); */
  next_val(*(T.next));
  /*@ assert rte: mem_access: \valid_read(tabT[0].pred); */
  next_val(*(tabT[0].pred));
  /*@ assert rte: mem_access: \valid_read(&(ptabT[2])->pred); */
  set((ptabT[2])->pred,15);
  set(tabT[1].pred,10);
  /*@ assert rte: mem_access: \valid_read(&(ptabT[1])->next); */
  /*@ assert rte: mem_access: \valid_read((ptabT[1])->next); */
  next_val(*((ptabT[1])->next));
  top_set(& T,3);
  top_set(& tabT[1],2);
  top_set(ptabT[1],4);
  top_set((top *)c.next,5);
  top_next(T);
  /*@ assert rte: mem_access: \valid_read(ptabT[0]); */
  top_next(*(ptabT[0]));
  tabtop_set(ptabT,2,10);
  pptop = ptabT;
  tabtop_set(pptop,2,15);
  tabtop_set(ptabT,1,20);
  /*@ assert rte: mem_access: \valid_read(&pc->next); */
  tabtop_set((top **)pc->next,1,10);
  return z;
}


