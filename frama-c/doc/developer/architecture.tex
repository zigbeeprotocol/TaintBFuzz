%; whizzy-master "developpeur.tex"

\chapter{Software Architecture}\label{chap:archi}\index{Architecture}

\begin{target}beginners.\end{target}

In this chapter, we present the software architecture of \framac. First,
Section~\ref{archi:general} presents its general overview. Then, we focus on
four different parts:

\begin{itemize}
\item Section~\ref{archi:plugin} explains what a plug-in really is and the main
  mechanisms of plug-in integration.
\item Section~\ref{archi:libraries} introduces the libraries that \framac
  provides.
\item Section~\ref{archi:services} introduces the kernel services that plug-in
  developers might want to use.
\item Section~\ref{archi:internals} introduces the kernel internals. You can
  safely skip it if you are not a \framac kernel developer.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{General Description}\label{archi:general}

From a plug-in developer point of view, the main goals of the \framac platform
is to provide services to ease:
\begin{itemize}
\item analysis and source-to-source transformation of big-size \C programs;
\item addition of new plug-ins; and
\item plug-ins collaboration.
\end{itemize}

In order to reach these goals, \framac has a plug-ins based software
architecture based on a \emph{kernel}\index{Kernel}. Historically the
\emph{kernel} was itself based on \cil~\cite{cil}: even if they have evolved
separately since the \framac Hydrogen age, there are still a lot of similarities
between \cil and several modules of the \framac kernel (\eg the ASTs).

The \framac architecture design is presented in this chapter, and summarized in
Figure~\ref{fig:architecture}. In this figure, each of the four rounded colored
boxes represents a subdirectory $d$ of directory \texttt{src}, while each of the
small square boxes represents a subdirectory in one subdirectory
\texttt{src/$d$}. The remaining sections will explain the goal of each of these
boxes. They do not detail each module of each directory: use the API
documentation generated by \texttt{make doc} for that purpose.

\begin{figure}[htbp]
\begin{center}

\begin{tikzpicture}[remember picture,every node/.style={transform shape}]
\node (bottom) {
\begin{tikz-hbox}[node distance=\bigpadding]{bottom}
% kernel internals
\node[structural,on chain] (internals) {
  \tikztitleboxbig{Kernel Internals}{LightCyan}{
    \begin{tikz-hbox}{internals}
      \node[on chain,draw,plain]{parsing};
      \node[on chain,draw,plain]{typing};
      \node[on chain,draw,plain]{runtime};
    \end{tikz-hbox}
  }
};

% libraries
\node[structural, on chain] (libraries) {%
  \tikztitleboxbig{Libraries}{Orange}{
    \begin{tikz-vbox}[node distance=\bigpadding]{libraries}
      \node[on chain,draw,plain] (stdlib){stdlib};
      \node[on chain,structural]{
        \begin{tikz-hbox}{lib-middle}
          \node[on chain,draw,plain] (datatype) {datatype};
          \node[on chain,draw,plain] (project) {project};
        \end{tikz-hbox}
      };
      \node[on chain,draw,plain] (utils) {utils};
    \end{tikz-vbox}%
  }
};
\end{tikz-hbox}
\begin{tikzpicture}[overlay]
    \draw[Latex-Latex] (stdlib.south) -- (datatype);
    \draw[Latex-Latex] (datatype) -- (utils);
    \draw[-Latex] (project) -- (stdlib);
    \draw[-Latex] (project.west) -- (datatype.east);
    \draw[-Latex] (project) -- (utils);
    \draw[-Latex,looseness=1.7,in=-20,out=20] (utils.east) to (stdlib.east);
\end{tikzpicture}
};

\node[structural, above=\bigpadding] at (bottom.north) (services) {
    % kernel services
  \tikztitleboxbig{Kernel Services}{darkgreen}{
    \begin{tikz-hbox}{services}
      \node[on chain,structural]{
        \begin{tikz-vbox}{services-left}
          \node[on chain,structural] (traversal){
            \tikztitlebox{AST Traversal}{%
              \begin{tikz-vbox}{traversal}
                \node[on chain,draw,plain] (visitor) {visitor};
                \node[on chain,structural] {
                  \begin{tikz-hbox}{traversal-1}
                    \node[on chain,draw,plain] (analysis) {analysis};
                    \node[on chain,draw,plain] (transfo) {ast\_transformations};
                  \end{tikz-hbox}
                };
                \draw[-Latex] (analysis) -- (visitor);
                \draw[-Latex] (transfo) -- (visitor);
              \end{tikz-vbox}
            }
          };
          \node[on chain,structural] (ai) {
            \tikztitlebox{AI}{
              \begin{tikz-vbox}{ai}
                \node[on chain,draw,plain]      {abstract\_interp};
              \end{tikz-vbox}
            }
          };
        \end{tikz-vbox}
      };
      \node[on chain,structural]  {
        \begin{tikz-vbox}{services-right}
          \node[on chain,structural](ast){
            \tikztitlebox{ASTs}{%
              \begin{tikz-vbox}{ast}
                \node[on chain,draw,plain] (data) {ast\_data};
                \node[on chain,draw,plain] (queries) {ast\_queries};
                \node[on chain,draw,plain] (parsetree) {parsetree};
                \draw[-Latex] (queries) -- (data);
              \end{tikz-vbox}
            }
          };
          \node[on chain,structural] (interactions) {
            \tikztitlebox{Plug-in Interactions}{
              \begin{tikz-vbox}{plugin-api}
                \node[on chain,draw,plain] {cmdline\_parameters};
                \node[on chain,draw,plain] {plugin\_entry\_points};
              \end{tikz-vbox}
            }
          };
          \draw[bigarrow,<->] (ast.south) -- (interactions.north);
        \end{tikz-vbox}
      };
    \end{tikz-hbox}
    \begin{tikzpicture}[overlay]
      \coordinate (ai2) at ($(ai.north east)!.75!(ai.south east)$);
      \coordinate (traversal1) at
      ($(traversal.south east)!0.2!(traversal.south west)$);
      \coordinate (interactions1) at
      ($(interactions.north west)!0.2!(interactions.south west)$);
      \draw[bigarrow,->] (traversal.east) -- (ast.west);
      \draw[bigarrow,->] (traversal1) -- (interactions1);
      \draw[bigarrow,bend right, ->] (ai.east) to[in=170] (ast.west);
      \draw[bigarrow,->] (ai.east) -- (interactions.west);
    \end{tikzpicture}
  }
};

%plugins
\node[above=\bigpadding,structural] at (services.north) (plugins) {
  \tikztitleboxbig{Plug-ins}{palered}{
    \begin{tikz-hbox}{plugins}
      \node[on chain,draw,plain] (pi1) {plug-in 1};
      \node[on chain,draw,plain] (pi2) {plug-in 2};
      \node[on chain,plain,minimum height=1ex] (dots) {...};
      \node[on chain,draw,plain] (pin) {plug-in $n$};
      \draw[-Latex,bend left] (pi1.north) to (pi2.north);
      \draw[-Latex,bend left] (pi2.north) to (dots.north);
      \draw[-Latex,bend left] (dots.north) to (pin.north);
      \draw[-Latex,bend left] (pin.south) to (dots.south);
      \draw[-Latex,bend left] (dots.south) to (pi2.south);
      \draw[-Latex,bend left] (pi2.south) to (pi1.south);
    \end{tikz-hbox}
  }
};

   \draw[bigarrow,<->] (services.south) -- (internals.north);
   \draw[bigarrow,->] (plugins.south) -- (services.north);
   \draw[bigarrow,->] (internals.east) -- (libraries.west);
   \draw[bigarrow,->] (services.south) to (libraries.north);
\end{tikzpicture}
\caption{Frama-C Architecture Design.}\label{fig:architecture}
\end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Plug-ins}\label{archi:plugin}
\index{Plug-in}\index{Plug-in!Kernel-integrated}

In \framac, plug-ins are program analysis or source-to-source
transformations. The ones provided within \framac are in directory
\texttt{src/plugins/$plugin\_name$}. Each plug-in is an extension point of \framac which
has to be registered through \texttt{Plugin.Register}\scodeidx{Plugin}{Register}
(see Section~\ref{adv:plugin-services}). \framac allows plug-in collaborations:
a plug-in $p$ can use a list of plug-ins $p_1$, \dots, $p_n$ and
conversely. Mutual dependences between plug-ins are even possible. If a plug-in
is designed to be used by another plug-in, it has to register its API either by
providing a \texttt{.mli} file, or through modules
\texttt{Dynamic}\codeidx{Dynamic} or \texttt{Db}\codeidx{Db}. The first method
is the preferred one, the second one (through module \texttt{Dynamic}) is the
only possible one to define mutually dependent plug-ins while the third one
(through module \texttt{Db}) is now fully deprecated even if most of the older
\framac plug-ins are still defined this way.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Libraries}\label{archi:libraries}

Libraries are defined in the directory \texttt{src/libraries}. They are either
third-party libraries or dedicated independent libraries which may be used by
other parts of \framac.

Extension of the \caml standard library are provided in directory
\texttt{src/libraries/stdlib}. For instance, modules \texttt{FC$module\_name$}
(e.g. \texttt{FCHashtbl}\codeidxdef{FCHashtbl}) provides a
\texttt{$module\_name$}-like interface (e.g. \texttt{Hashtbl}) with an uniform
API for all \ocaml versions supported by \framac and possibly additional useful
operations for the corresponding datastructures.

Single-file libraries are provided in directory
\texttt{src/libraries/utils}. For instance,
\texttt{Pretty\_utils}\codeidxdef{Pretty\_utils} provides pretty-printing
facilities.

\emph{datatype} (directory \texttt{src/libraries/datatype}) and \emph{project}
(directory \texttt{src/libraries/project}) are two multiple-files
libraries. They are respectively presented in Sections~\ref{adv:datatype} and
\ref{adv:project}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kernel Services}\label{archi:services}\index{Kernel!Services|bfit}

The kernel services is defined in directory \texttt{src/kernel\_services}. It
is the part of the \framac kernel which may be useful to develop plug-ins.

This services may be split in four main parts:
\begin{itemize}
\item two ASTs and the data structures directly built upon them;
\item plug-in interactions toolbox;
\item predefined generic analyzers;
\item the abstract interpretation framework.
\end{itemize}

The standard AST used by most analyzers is defined in module
\texttt{Cil\_types}\codeidx{Cil\_types} of directory
\texttt{src/kernel\_services/ast\_data}. It contains the types which describes
both the \C constructs and the \acsl ones~\cite{acsl}. The same directory also
contains modules defining datastructures directly based upon the AST (module
\texttt{Globals}\codeidx{Globals}), functions (module
\texttt{Kernel\_function}\codeidx{Kernel\_function}), annotations (module
\texttt{Annotations}\codeidx{Annotations}) and so on. A related directory is
\texttt{src/kernel\_services/ast\_queries}. It contains modules which provides
specific operations in order to get information about AST-related values.

In the same way, an untyped AST quite close of the \C input source is defined in
module \texttt{Cabs}\codeidx{Cabs} of directory
\texttt{src/kernel\_services/parsetree}. This AST is only well suited
for syntactic analyzers/program transformers.

\framac also provides services to plug-ins which help both their integration in
the platform and their interactions with the kernel and the other plug-ins. They
enforce some platform-wide consistency by ensuring that some common actions
(\emph{e.g.} printing messages to end-users) are handled by all plugins in a
similar way. Directory \texttt{src/kernel\_services/cmdline\_parameters}
provides modules which eases the definition of analyzers' parameters accessible
by the end-user through command-line options. Similarly, directory
\texttt{src/kernel\_services/plugin\_entry\_points} provides modules to interact
with the \framac kernel or other plug-ins.

Next, \framac provides predefined ways to visit the ASTs, in particular through
object-oriented visitors defined in directory
\texttt{src/kernel\_services/visitors} (see Section~\ref{adv:visitors}). 
Some predefined analyzers, such as a multiple generic dataflow analysis
are provided in directory \texttt{src/kernel\_services/analysis}, while some
predefined program transformation, such as cloning a function, are provided in
directory \texttt{src/kernel\_services/ast\_transformations}.
Finally, \framac provides an abstract interpretation 
toolbox\index{Abstract Interpretation}
with various lattices in directory \texttt{abstract\_interp}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kernel Internals}\label{archi:internals}\index{Kernel!Internals|bfit}

\begin{target}kernel developers.\end{target}

The kernel internals is defined in directory \texttt{src/kernel\_internals}. It
is part of the \framac kernel which should be useless to develop analysis
plug-ins, except possibly for very low-level interactions, or to extend the
C or ACSL services of Frama-C. Consequently, if you are not a kernel
developer, you can safely ignore this section.

The internals is split in three different parts, each of them being an
independent subdirectory:
\begin{itemize}
\item the directory \texttt{src/kernel\_internals/parsing} contains the lexer
  and parser which generate the untyped AST (\emph{aka} Cabs) from the \C input
  source code;
\item the directory \texttt{src/kernel\_internals/typing} contains the
  compiler which generates the standard AST (\emph{aka} Cil) from the untyped
  one;
\item the directory \texttt{src/kernel\_internals/runtime} contains modules
  whose primary purpose is to perform side-effects while \framac is booting.
\end{itemize}

% Local Variables:
% TeX-master: "developer.tex"
% ispell-local-dictionary: "english"
% End:
