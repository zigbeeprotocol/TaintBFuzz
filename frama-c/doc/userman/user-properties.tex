\chapter{Property Statuses}
\label{user-properties}

This chapter touches on the topic of program properties, and their validation
by either standalone or cooperating \FramaC plug-ins. The theoretical foundation
of this chapter is described in a research paper~\cite{fmics12}.

\section{A Short Detour through Annotations}
\label{user-properties-annotations}

\FramaC supports writing code annotations with the \acsl language~\cite{acsl}.
The purpose of annotations is to formally specify the properties of \C code:
\FramaC plug-ins can rely on them to demonstrate that an implementation
respects its specification.

Annotations can originate from a number of different sources: 
\begin{description}
\item [the user] who writes his own annotations: an engineer writing code
specifications is the prevalent scenario here;
\item [some plug-ins] may generate code annotations. These annotations can, for
instance, indicate that a variable needs to be within a safe range to guarantee
no runtime errors are triggered (cf the RTE plug-in~\cite{rte}).
\item [the kernel] of \FramaC, that attempts to generate as precise an
annotation as it can, when none is present. 
\end{description}

\begin{important}
Of particular interest is the case of unannotated function
prototypes\footnote{A function prototype is a function declaration that
provides argument types and return type, but lacks a body.}: the \acsl
specification states that a construct of that kind ``potentially modifies
\emph{everything}''~\cite[Sec.~2.3.5]{acsl}.  For the sake of precision and
conciseness, the \FramaC kernel breaks this specification, and generates a
function contract with clauses that relate its formal parameters to its
results\footnote{Results here include the return value, and the formal
modifiable parameters.}. This behavior might be incorrect -- for instance
because it does not consider functions that can modify globals. While
convenient in a wide range of cases, this  can be averted by writing a
custom function contract for the contentious prototypes.
\end{important}

The rest of this chapter will examine how plug-ins can deal with code
annotations, and in particular what kind of information can be attached to
them.

\section{Properties, and the Statuses Thereof}

A property is a logical statement bound to a precise code location. A property
might originate from:
\begin{itemize}
\item an \acsl code annotation -- e.g. \verb+assert p[i] * p[i] <= INT_MAX+.
Recall from the previous section that annotations can either be written by the
user, or generated by the \FramaC plug-ins or kernel;
\item a plugin-dependent meta-information -- such as the memory model assumptions.
%the proof method of a loop invariant.
\end{itemize}

Consider a program point $i$, and call $T$ the set of traces that run through
$i$. More precisely, we only consider the traces that are coming from the
program entry point\footnote{Some plug-ins might consider \emph{all possible
traces}, which constitute a safe over-approximation of the intended property.}
(see option \verb+-main+ in chapter~\ref{user-analysis}).  A logical property
$P$ is valid at $i$ if it is valid on all $t\in T$. Conversely, any trace $u$
that does not validate $P$, stops at $i$: properties are \emph{blocking}.

As an example, a property might consist in a statement $p[j]\times p[j] \leq 2
147 483 647$ at a program point $i$. A trace where $p[j]=46341$ at $i$
will invalidate this property, and will stop short of reaching any instruction
succeeding $i$.

An important part of the interactions between \FramaC components (the
plug-ins/the kernel) rely on their capacity to \emph{emit} a judgment on the
validity of a property $P$ at program point $i$. In \FramaC nomenclature, this
judgment is called a \emph{local property status}. The first part of a local
status ranges over the following values:

\begin{itemize}
\item \verb+True+ when the property is true for all traces;
\item \verb+False+ when there exists a trace that falsifies the property;
%\item \verb+False_if_reachable+ when the property is false, but there is no
%guarantee that there exists a trace $t$ that reaches the point $i$. This status
%can be set when an over-approximation has led to the falsification of the
%property;
%\item \verb+False_and_reachable+ when the property is false, and there exists a trace
%$t$ that reaches the point $i$;
\item \verb+Maybe+ when the emitter $e$ cannot decide the status of $P$.
\end{itemize}

As a second part of a local property status, an emitter can add a list of
\emph{dependencies}, which is the set of properties whose validity may be
necessary to establish the judgment.  For instance, when the WP
plug-in~\cite{wp} provides a demonstration of a Hoare triple $\{A\}\ c\ \{B\}$,
it starts by setting the status of $B$ to ``True'', and then adds to this
status a dependency on property $A$. In more formal terms, it corresponds to the
judgment $\vdash A\Rightarrow B$: ``for a trace to be valid in $B$, it may be
necessary for $A$ to hold''. This information on the conditional validity of
$B$ is provided \emph{as a guide} for validation engineers, and should not be
mistaken for the formal proof of $B$, which only holds when \emph{all} program
properties are verified -- hence the \emph{local} status.

%In addition, if the local status is
%  \verb+False_if_reachable+, a reachability meta-property is added to the
%  status dependencies.

%The kernel module \verb+Property_status+ is responsible for the property status
%data-structures and manipulations.

\section{Consolidating Property Statuses}

Recall our previous example, where the WP plug-in sets the local status of a
property $B$ to ``True'', with a dependency on a property $A$.  This might help
another plug-in decide that the validity of a third property $C$, that hinges
upon $B$, now depends on $A$. When at last $A$ is proven by, say, the value
analysis plug-in, the cooperative proofs of $A$, $B$, and $C$ are marked as
completed. 
%
In formal terms, \FramaC has combined the judgments: $\vdash A\Rightarrow B$,
$\vdash B\Rightarrow C$, and $\vdash A$ into proofs of $\vdash B$ and $\vdash
C$, by using the equivalent of a \emph{modus ponens} inference:
$$
\frac{\overline{\vdash A} \quad \overline{\vdash A\Rightarrow B}}{\vdash B}
$$
Notice how, without the final $\vdash A$ judgment, both proofs would be incomplete.

This short example illustrates how incremental the construction of program
property proofs can be. By \emph{consolidating} property statuses into an
easily readable display, \FramaC aims at informing its users of the progress of
this process, allowing them to track unresolved dependencies, and selectively
validate subsets of the program's properties.

As a result, a consolidated property status can either be a \emph{simple} status:

\begin{description}
  \item [{\includegraphics[height=1em]{../../share/theme/default/never_tried.png}}] %Local.Never_tried
  -- \verb+never_tried+: when no status is available for the property.
  \item [{\includegraphics[height=1em]{../../share/theme/default/unknown.png}}] %Consolidation.Unknown
  -- \verb+unknown+: whenever the status is \verb+Maybe+.
  \item [{\includegraphics[height=1em]{../../share/theme/default/surely_valid.png}}] %Consolidation.Valid
  -- \verb+surely_valid+: when the status is \verb+True+, and dependencies have the consolidated status
  \verb+surely_valid+ or \verb+considered_valid+.
  \item [{\includegraphics[height=1em]{../../share/theme/default/surely_invalid.png}}] %Consolidation.Invalid
  -- \verb+surely_invalid+: when the status is \verb+False+, and all dependencies have the consolidated status
  \verb+surely_valid+.  
  \item [{\includegraphics[height=1em]{../../share/theme/default/inconsistent.png}}] %Consolidation.Inconsistent
  -- \verb+inconsistent+: when there exist two conflicting consolidated statuses for
  the same property, for instance with values \verb+surely_valid+ and
  \verb+surely_invalid+. This case may also arise when an invalid cyclic proof
  is detected. This is symptomatic of an incoherent axiomatization.
\end{description}

or an \emph{incomplete} status:

\begin{description}
  \item [{\includegraphics[height=1em]{../../share/theme/default/considered_valid.png}}] %Consolidation.Considered_valid
  -- \verb+considered_valid+: when there is no possible way to prove the
  property (e.g., the post-condition of an external function). We assume this
  property will be validated by external means.
  \item [{\includegraphics[height=1em]{../../share/theme/default/valid_under_hyp.png}}] %Consolidation.Valid_under_hyp
  -- \verb+valid_under_hyp+: when the local status is \verb+True+ but at least
  one of the dependencies has consolidated status \verb+unknown+. This is
  typical of proofs in progress.
  \item [{\includegraphics[height=1em]{../../share/theme/default/invalid_under_hyp.png}}] %Consolidation.Invalid_under_hyp
  -- \verb+invalid_under_hyp+: when the local status is \verb+False+, but at
  least one of the dependencies has status \verb+unknown+.  This is a telltale
  sign of a dead code property, or of an erroneous annotation.
\end{description}

and finally:

\begin{description}
  \item [{\includegraphics[height=1em]{../../share/theme/default/unknown_but_dead.png}}] %Consolidation.Unknown_but_dead
  -- \verb+unknown_but_dead+: when the status is locally \verb+Maybe+, but in a
  dead or incoherent branch.
  \item [{\includegraphics[height=1em]{../../share/theme/default/valid_but_dead.png}}] %Consolidation.Valid_but_dead
  -- \verb+valid_but_dead+: when the status is locally \verb+True+, but in a
  dead or incoherent branch.
  \item [{\includegraphics[height=1em]{../../share/theme/default/invalid_but_dead.png}}] %Consolidation.Invalid_but_dead
  -- \verb+invalid_but_dead+: when the status is locally
  \verb+False+, but in a dead or incoherent branch.
\end{description}

\begin{important}
The dependencies are meant \emph{as a guide} to safety engineers. They are
neither correct, nor complete, and should not be relied on for formal
assessment purposes. In particular, as long as partial proofs exist (there are
\verb+unknown+ or \verb+never_tried+), there is no certainty with regards to
any other status (including \verb+surely_valid+ properties).
\end{important}

These consolidated statuses are displayed in the GUI (see
section~\ref{user-gui} for details), or in batch  mode by the \verb+report+
plug-in.

%Finally, when two or more plug-ins position different statuses on a same
%property, \FramaC only retains the best status available.

%Consolidation is performed by the \FramaC kernel, in the
%\verb+Property_status.Consolidation+ module.

% Local Variables:
% TeX-master: "userman.tex"
% compile-command: "make"
% ispell-local-dictionary: "english"
% End:
